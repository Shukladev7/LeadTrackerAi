{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h3\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <p\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n"],"names":[],"mappings":";;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG1B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,4DACA;QAED,GAAG,KAAK;;;;;;AAGb,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,sDACA;QAED,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGrC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QAAI,KAAK;QAAK,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,YAAY;QAAa,GAAG,KAAK;;;;;;AAEhE,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/badge.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n"],"names":[],"mappings":";;;;;AACA;AAEA;;;;AAEA,MAAM,gBAAgB,CAAA,GAAA,gKAAA,CAAA,MAAG,AAAD,EACtB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SAAS;QACX;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAOF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBACE,8OAAC;QAAI,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAExE","debugId":null}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/data/index.ts"],"sourcesContent":["\n'use server';\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { Lead, Activity, Product, LeadSource, UpdatableLeadData, Quotation, QuotationTemplate, NewProduct, Employee, NewEmployee, EmployeeRoleData, Department } from '../types';\n\nconst dataPath = path.join(process.cwd(), 'src', 'lib', 'data');\n\nasync function readData<T>(filename: string): Promise<T[]> {\n  try {\n    const filePath = path.join(dataPath, filename);\n    const fileContent = await fs.readFile(filePath, 'utf-8');\n    return JSON.parse(fileContent);\n  } catch (error) {\n    if (isNodeError(error) && error.code === 'ENOENT') {\n      // If the file doesn't exist, create it with an empty array\n      await writeData(filename, []);\n      return [];\n    }\n    console.error(`Error reading ${filename}:`, error);\n    throw new Error(`Could not read ${filename}`);\n  }\n}\n\nasync function writeData<T>(filename: string, data: T[]): Promise<void> {\n  try {\n    const filePath = path.join(dataPath, filename);\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n  } catch (error)\n{\n    console.error(`Error writing ${filename}:`, error);\n    throw new Error(`Could not write to ${filename}`);\n  }\n}\n\nfunction isNodeError(error: unknown): error is NodeJS.ErrnoException {\n    return error instanceof Error;\n}\n\nexport const getLeads = async (query?: string, status?: string): Promise<Lead[]> => {\n  let leads = await readData<Lead>('leads.json');\n  \n  if (query) {\n    const lowercasedQuery = query.toLowerCase();\n    leads = leads.filter(\n      lead =>\n        lead.name.toLowerCase().includes(lowercasedQuery) ||\n        lead.company.toLowerCase().includes(lowercasedQuery)\n    );\n  }\n\n  if (status) {\n    leads = leads.filter(lead => lead.status === status);\n  }\n  \n  return leads.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getLeadById = async (id: string): Promise<Lead | undefined> => {\n    const leads = await getLeads();\n    const lead = leads.find(lead => lead.id === id);\n    if (!lead) return undefined;\n    \n    return {\n      ...lead,\n      activities: lead.activities.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())\n    };\n};\n\nexport const getRecentActivities = async (limit: number): Promise<{ lead: Lead; activity: Activity }[]> => {\n    const leads = await getLeads();\n    const allActivities = leads.flatMap(lead => \n        lead.activities.map(activity => ({ lead, activity }))\n    );\n    return allActivities\n        .sort((a, b) => new Date(b.activity.date).getTime() - new Date(a.activity.date).getTime())\n        .slice(0, limit);\n}\n\nexport const getProducts = async (): Promise<Product[]> => {\n  return await readData<Product>('products.json');\n}\n\nexport const getLeadSources = async (): Promise<LeadSource[]> => {\n    return await readData<LeadSource>('lead-sources.json');\n}\n\nexport const addProduct = async (productData: NewProduct): Promise<Product> => {\n  const products = await getProducts();\n  const newProduct: Product = {\n    ...productData,\n    id: `prod-${Date.now()}`,\n  };\n  products.unshift(newProduct);\n  await writeData<Product>('products.json', products);\n  return newProduct;\n};\n\nexport const updateProduct = async (id: string, productData: NewProduct): Promise<Product> => {\n    const products = await getProducts();\n    const productIndex = products.findIndex(p => p.id === id);\n    if (productIndex === -1) {\n        throw new Error('Product not found');\n    }\n    const updatedProduct = { ...products[productIndex], ...productData };\n    products[productIndex] = updatedProduct;\n    await writeData<Product>('products.json', products);\n    return updatedProduct;\n};\n\nexport const deleteProduct = async (id: string): Promise<{ success: boolean }> => {\n    let products = await getProducts();\n    const initialLength = products.length;\n    products = products.filter(p => p.id !== id);\n    if (products.length === initialLength) {\n        throw new Error('Product not found for deletion');\n    }\n    await writeData<Product>('products.json', products);\n    return { success: true };\n};\n\n\nexport const addLeadSource = async (name: string): Promise<LeadSource> => {\n    const leadSources = await getLeadSources();\n    const newSource: LeadSource = {\n        id: `source-${Date.now()}`,\n        name,\n    };\n    leadSources.unshift(newSource);\n    await writeData<LeadSource>('lead-sources.json', leadSources);\n    return newSource;\n};\n\nexport const deleteLeadSource = async (id: string): Promise<{ success: boolean }> => {\n    let leadSources = await getLeadSources();\n    const initialLength = leadSources.length;\n    leadSources = leadSources.filter(source => source.id !== id);\n    await writeData<LeadSource>('lead-sources.json', leadSources);\n    return { success: leadSources.length < initialLength };\n};\n\nexport const addLead = async (leadData: Omit<Lead, 'id' | 'createdAt' | 'activities'> & { notes?: string }): Promise<Lead> => {\n  const leads = await getLeads();\n  const newId = `lead-${Date.now()}`;\n  \n  const initialActivity: Activity[] = [];\n  if (leadData.notes) {\n    initialActivity.push({\n      id: `act-${newId}-1`,\n      date: new Date().toISOString(),\n      type: 'Email', \n      notes: `Lead created in the system. Initial notes: ${leadData.notes}`,\n    });\n  }\n\n  const { notes, ...restOfLeadData } = leadData;\n\n  const newLead: Lead = {\n    ...restOfLeadData,\n    id: newId,\n    createdAt: new Date().toISOString(),\n    activities: initialActivity,\n  };\n  leads.unshift(newLead);\n  await writeData<Lead>('leads.json', leads);\n  return newLead;\n};\n\nexport const addActivityToLead = async (leadId: string, activityData: Omit<Activity, 'id' | 'date'>): Promise<Activity> => {\n  const leads = await getLeads();\n  const leadIndex = leads.findIndex(l => l.id === leadId);\n  if (leadIndex === -1) {\n    throw new Error('Lead not found');\n  }\n\n  const lead = leads[leadIndex];\n  const newActivity: Activity = {\n    ...activityData,\n    id: `act-${leadId}-${lead.activities.length + 1}`,\n    date: new Date().toISOString(),\n  };\n  lead.activities.unshift(newActivity);\n  \n  await writeData<Lead>('leads.json', leads);\n  return newActivity;\n};\n\nexport const updateLeadStatus = async (leadId: string, status: Lead['status']): Promise<Lead> => {\n  const leads = await getLeads();\n  const leadIndex = leads.findIndex(l => l.id === leadId);\n  if (leadIndex === -1) {\n    throw new Error('Lead not found');\n  }\n\n  leads[leadIndex].status = status;\n  await writeData<Lead>('leads.json', leads);\n  return leads[leadIndex];\n};\n\nexport const updateLead = async (leadId: string, leadData: UpdatableLeadData): Promise<Lead> => {\n    const leads = await getLeads();\n    const leadIndex = leads.findIndex(l => l.id === leadId);\n    if (leadIndex === -1) {\n      throw new Error('Lead not found');\n    }\n  \n    const originalLead = leads[leadIndex];\n    const updatedLead: Lead = {\n      ...originalLead,\n      ...leadData,\n    };\n  \n    leads[leadIndex] = updatedLead;\n    await writeData<Lead>('leads.json', leads);\n    return updatedLead;\n};\n\n// Quotation specific functions\nexport const getQuotations = async (): Promise<Quotation[]> => {\n    const quotations = await readData<Quotation>('quotations.json');\n    return quotations.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getQuotationById = async (id: string): Promise<Quotation | undefined> => {\n    const quotations = await getQuotations();\n    return quotations.find(q => q.id === id);\n};\n\nexport const addQuotation = async (quotationData: Omit<Quotation, 'id' | 'createdAt' | 'quotationNumber'>): Promise<Quotation> => {\n    const quotations = await getQuotations();\n    const newQuotationNumber = `QUO-${String(quotations.length + 1).padStart(4, '0')}`;\n    const newQuotation: Quotation = {\n        ...quotationData,\n        id: `quo-${Date.now()}`,\n        quotationNumber: newQuotationNumber,\n        createdAt: new Date().toISOString(),\n    };\n    quotations.unshift(newQuotation);\n    await writeData<Quotation>('quotations.json', quotations);\n    return newQuotation;\n};\n\nexport const getQuotationTemplates = async (): Promise<QuotationTemplate[]> => {\n    return await readData<QuotationTemplate>('quotation-templates.json');\n};\n\nexport const getQuotationTemplateById = async (id: string): Promise<QuotationTemplate | undefined> => {\n    const templates = await getQuotationTemplates();\n    return templates.find(t => t.id === id);\n};\n\nexport const addQuotationTemplate = async (templateData: Omit<QuotationTemplate, 'id'>): Promise<QuotationTemplate> => {\n    const templates = await getQuotationTemplates();\n    const newTemplate: QuotationTemplate = {\n        ...templateData,\n        id: `template-${Date.now()}`,\n    };\n    templates.unshift(newTemplate);\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return newTemplate;\n};\n\nexport const updateQuotationTemplate = async (id: string, templateData: QuotationTemplate): Promise<QuotationTemplate> => {\n    const templates = await getQuotationTemplates();\n    const templateIndex = templates.findIndex(t => t.id === id);\n    if (templateIndex === -1) {\n        throw new Error('Template not found');\n    }\n    templates[templateIndex] = { ...templates[templateIndex], ...templateData };\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return templates[templateIndex];\n}\n\nexport const deleteQuotationTemplate = async (id: string): Promise<{ success: boolean }> => {\n    let templates = await getQuotationTemplates();\n    const initialLength = templates.length;\n    templates = templates.filter(t => t.id !== id);\n    if (templates.length === initialLength) {\n        throw new Error('Template not found for deletion');\n    }\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return { success: true };\n}\n\n\n// Employee specific functions\nexport const getEmployees = async (): Promise<Employee[]> => {\n    const employees = await readData<Employee>('employees.json');\n    return employees.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getEmployeeById = async (id: string): Promise<Employee | undefined> => {\n    const employees = await getEmployees();\n    return employees.find(employee => employee.id === id);\n};\n\nexport const addEmployee = async (employeeData: NewEmployee): Promise<Employee> => {\n    const employees = await getEmployees();\n    const newEmployee: Employee = {\n        ...employeeData,\n        id: `emp-${Date.now()}`,\n        createdAt: new Date().toISOString(),\n    };\n    employees.unshift(newEmployee);\n    await writeData<Employee>('employees.json', employees);\n    return newEmployee;\n};\n\nexport const getEmployeeRoles = async (): Promise<EmployeeRoleData[]> => {\n    return await readData<EmployeeRoleData>('employee-roles.json');\n}\n\nexport const addEmployeeRole = async (name: string): Promise<EmployeeRoleData> => {\n    const roles = await getEmployeeRoles();\n    const newRole: EmployeeRoleData = {\n        id: `role-${Date.now()}`,\n        name,\n    };\n    roles.push(newRole);\n    await writeData<EmployeeRoleData>('employee-roles.json', roles);\n    return newRole;\n}\n\nexport const deleteEmployeeRole = async (id: string): Promise<{ success: boolean }> => {\n    let roles = await getEmployeeRoles();\n    const initialLength = roles.length;\n    roles = roles.filter(role => role.id !== id);\n    await writeData<EmployeeRoleData>('employee-roles.json', roles);\n    return { success: roles.length < initialLength };\n}\n\nexport const getDepartments = async (): Promise<Department[]> => {\n    return await readData<Department>('departments.json');\n}\n\nexport const addDepartment = async (name: string): Promise<Department> => {\n    const departments = await getDepartments();\n    const newDepartment: Department = {\n        id: `dept-${Date.now()}`,\n        name,\n    };\n    departments.push(newDepartment);\n    await writeData<Department>('departments.json', departments);\n    return newDepartment;\n}\n\nexport const deleteDepartment = async (id: string): Promise<{ success: boolean }> => {\n    let departments = await getDepartments();\n    const initialLength = departments.length;\n    departments = departments.filter(dept => dept.id !== id);\n    await writeData<Department>('departments.json', departments);\n    return { success: departments.length < initialLength };\n}\n"],"names":[],"mappings":";;;;;;IAwCa,WAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/data/index.ts"],"sourcesContent":["\n'use server';\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { Lead, Activity, Product, LeadSource, UpdatableLeadData, Quotation, QuotationTemplate, NewProduct, Employee, NewEmployee, EmployeeRoleData, Department } from '../types';\n\nconst dataPath = path.join(process.cwd(), 'src', 'lib', 'data');\n\nasync function readData<T>(filename: string): Promise<T[]> {\n  try {\n    const filePath = path.join(dataPath, filename);\n    const fileContent = await fs.readFile(filePath, 'utf-8');\n    return JSON.parse(fileContent);\n  } catch (error) {\n    if (isNodeError(error) && error.code === 'ENOENT') {\n      // If the file doesn't exist, create it with an empty array\n      await writeData(filename, []);\n      return [];\n    }\n    console.error(`Error reading ${filename}:`, error);\n    throw new Error(`Could not read ${filename}`);\n  }\n}\n\nasync function writeData<T>(filename: string, data: T[]): Promise<void> {\n  try {\n    const filePath = path.join(dataPath, filename);\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n  } catch (error)\n{\n    console.error(`Error writing ${filename}:`, error);\n    throw new Error(`Could not write to ${filename}`);\n  }\n}\n\nfunction isNodeError(error: unknown): error is NodeJS.ErrnoException {\n    return error instanceof Error;\n}\n\nexport const getLeads = async (query?: string, status?: string): Promise<Lead[]> => {\n  let leads = await readData<Lead>('leads.json');\n  \n  if (query) {\n    const lowercasedQuery = query.toLowerCase();\n    leads = leads.filter(\n      lead =>\n        lead.name.toLowerCase().includes(lowercasedQuery) ||\n        lead.company.toLowerCase().includes(lowercasedQuery)\n    );\n  }\n\n  if (status) {\n    leads = leads.filter(lead => lead.status === status);\n  }\n  \n  return leads.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getLeadById = async (id: string): Promise<Lead | undefined> => {\n    const leads = await getLeads();\n    const lead = leads.find(lead => lead.id === id);\n    if (!lead) return undefined;\n    \n    return {\n      ...lead,\n      activities: lead.activities.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())\n    };\n};\n\nexport const getRecentActivities = async (limit: number): Promise<{ lead: Lead; activity: Activity }[]> => {\n    const leads = await getLeads();\n    const allActivities = leads.flatMap(lead => \n        lead.activities.map(activity => ({ lead, activity }))\n    );\n    return allActivities\n        .sort((a, b) => new Date(b.activity.date).getTime() - new Date(a.activity.date).getTime())\n        .slice(0, limit);\n}\n\nexport const getProducts = async (): Promise<Product[]> => {\n  return await readData<Product>('products.json');\n}\n\nexport const getLeadSources = async (): Promise<LeadSource[]> => {\n    return await readData<LeadSource>('lead-sources.json');\n}\n\nexport const addProduct = async (productData: NewProduct): Promise<Product> => {\n  const products = await getProducts();\n  const newProduct: Product = {\n    ...productData,\n    id: `prod-${Date.now()}`,\n  };\n  products.unshift(newProduct);\n  await writeData<Product>('products.json', products);\n  return newProduct;\n};\n\nexport const updateProduct = async (id: string, productData: NewProduct): Promise<Product> => {\n    const products = await getProducts();\n    const productIndex = products.findIndex(p => p.id === id);\n    if (productIndex === -1) {\n        throw new Error('Product not found');\n    }\n    const updatedProduct = { ...products[productIndex], ...productData };\n    products[productIndex] = updatedProduct;\n    await writeData<Product>('products.json', products);\n    return updatedProduct;\n};\n\nexport const deleteProduct = async (id: string): Promise<{ success: boolean }> => {\n    let products = await getProducts();\n    const initialLength = products.length;\n    products = products.filter(p => p.id !== id);\n    if (products.length === initialLength) {\n        throw new Error('Product not found for deletion');\n    }\n    await writeData<Product>('products.json', products);\n    return { success: true };\n};\n\n\nexport const addLeadSource = async (name: string): Promise<LeadSource> => {\n    const leadSources = await getLeadSources();\n    const newSource: LeadSource = {\n        id: `source-${Date.now()}`,\n        name,\n    };\n    leadSources.unshift(newSource);\n    await writeData<LeadSource>('lead-sources.json', leadSources);\n    return newSource;\n};\n\nexport const deleteLeadSource = async (id: string): Promise<{ success: boolean }> => {\n    let leadSources = await getLeadSources();\n    const initialLength = leadSources.length;\n    leadSources = leadSources.filter(source => source.id !== id);\n    await writeData<LeadSource>('lead-sources.json', leadSources);\n    return { success: leadSources.length < initialLength };\n};\n\nexport const addLead = async (leadData: Omit<Lead, 'id' | 'createdAt' | 'activities'> & { notes?: string }): Promise<Lead> => {\n  const leads = await getLeads();\n  const newId = `lead-${Date.now()}`;\n  \n  const initialActivity: Activity[] = [];\n  if (leadData.notes) {\n    initialActivity.push({\n      id: `act-${newId}-1`,\n      date: new Date().toISOString(),\n      type: 'Email', \n      notes: `Lead created in the system. Initial notes: ${leadData.notes}`,\n    });\n  }\n\n  const { notes, ...restOfLeadData } = leadData;\n\n  const newLead: Lead = {\n    ...restOfLeadData,\n    id: newId,\n    createdAt: new Date().toISOString(),\n    activities: initialActivity,\n  };\n  leads.unshift(newLead);\n  await writeData<Lead>('leads.json', leads);\n  return newLead;\n};\n\nexport const addActivityToLead = async (leadId: string, activityData: Omit<Activity, 'id' | 'date'>): Promise<Activity> => {\n  const leads = await getLeads();\n  const leadIndex = leads.findIndex(l => l.id === leadId);\n  if (leadIndex === -1) {\n    throw new Error('Lead not found');\n  }\n\n  const lead = leads[leadIndex];\n  const newActivity: Activity = {\n    ...activityData,\n    id: `act-${leadId}-${lead.activities.length + 1}`,\n    date: new Date().toISOString(),\n  };\n  lead.activities.unshift(newActivity);\n  \n  await writeData<Lead>('leads.json', leads);\n  return newActivity;\n};\n\nexport const updateLeadStatus = async (leadId: string, status: Lead['status']): Promise<Lead> => {\n  const leads = await getLeads();\n  const leadIndex = leads.findIndex(l => l.id === leadId);\n  if (leadIndex === -1) {\n    throw new Error('Lead not found');\n  }\n\n  leads[leadIndex].status = status;\n  await writeData<Lead>('leads.json', leads);\n  return leads[leadIndex];\n};\n\nexport const updateLead = async (leadId: string, leadData: UpdatableLeadData): Promise<Lead> => {\n    const leads = await getLeads();\n    const leadIndex = leads.findIndex(l => l.id === leadId);\n    if (leadIndex === -1) {\n      throw new Error('Lead not found');\n    }\n  \n    const originalLead = leads[leadIndex];\n    const updatedLead: Lead = {\n      ...originalLead,\n      ...leadData,\n    };\n  \n    leads[leadIndex] = updatedLead;\n    await writeData<Lead>('leads.json', leads);\n    return updatedLead;\n};\n\n// Quotation specific functions\nexport const getQuotations = async (): Promise<Quotation[]> => {\n    const quotations = await readData<Quotation>('quotations.json');\n    return quotations.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getQuotationById = async (id: string): Promise<Quotation | undefined> => {\n    const quotations = await getQuotations();\n    return quotations.find(q => q.id === id);\n};\n\nexport const addQuotation = async (quotationData: Omit<Quotation, 'id' | 'createdAt' | 'quotationNumber'>): Promise<Quotation> => {\n    const quotations = await getQuotations();\n    const newQuotationNumber = `QUO-${String(quotations.length + 1).padStart(4, '0')}`;\n    const newQuotation: Quotation = {\n        ...quotationData,\n        id: `quo-${Date.now()}`,\n        quotationNumber: newQuotationNumber,\n        createdAt: new Date().toISOString(),\n    };\n    quotations.unshift(newQuotation);\n    await writeData<Quotation>('quotations.json', quotations);\n    return newQuotation;\n};\n\nexport const getQuotationTemplates = async (): Promise<QuotationTemplate[]> => {\n    return await readData<QuotationTemplate>('quotation-templates.json');\n};\n\nexport const getQuotationTemplateById = async (id: string): Promise<QuotationTemplate | undefined> => {\n    const templates = await getQuotationTemplates();\n    return templates.find(t => t.id === id);\n};\n\nexport const addQuotationTemplate = async (templateData: Omit<QuotationTemplate, 'id'>): Promise<QuotationTemplate> => {\n    const templates = await getQuotationTemplates();\n    const newTemplate: QuotationTemplate = {\n        ...templateData,\n        id: `template-${Date.now()}`,\n    };\n    templates.unshift(newTemplate);\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return newTemplate;\n};\n\nexport const updateQuotationTemplate = async (id: string, templateData: QuotationTemplate): Promise<QuotationTemplate> => {\n    const templates = await getQuotationTemplates();\n    const templateIndex = templates.findIndex(t => t.id === id);\n    if (templateIndex === -1) {\n        throw new Error('Template not found');\n    }\n    templates[templateIndex] = { ...templates[templateIndex], ...templateData };\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return templates[templateIndex];\n}\n\nexport const deleteQuotationTemplate = async (id: string): Promise<{ success: boolean }> => {\n    let templates = await getQuotationTemplates();\n    const initialLength = templates.length;\n    templates = templates.filter(t => t.id !== id);\n    if (templates.length === initialLength) {\n        throw new Error('Template not found for deletion');\n    }\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return { success: true };\n}\n\n\n// Employee specific functions\nexport const getEmployees = async (): Promise<Employee[]> => {\n    const employees = await readData<Employee>('employees.json');\n    return employees.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getEmployeeById = async (id: string): Promise<Employee | undefined> => {\n    const employees = await getEmployees();\n    return employees.find(employee => employee.id === id);\n};\n\nexport const addEmployee = async (employeeData: NewEmployee): Promise<Employee> => {\n    const employees = await getEmployees();\n    const newEmployee: Employee = {\n        ...employeeData,\n        id: `emp-${Date.now()}`,\n        createdAt: new Date().toISOString(),\n    };\n    employees.unshift(newEmployee);\n    await writeData<Employee>('employees.json', employees);\n    return newEmployee;\n};\n\nexport const getEmployeeRoles = async (): Promise<EmployeeRoleData[]> => {\n    return await readData<EmployeeRoleData>('employee-roles.json');\n}\n\nexport const addEmployeeRole = async (name: string): Promise<EmployeeRoleData> => {\n    const roles = await getEmployeeRoles();\n    const newRole: EmployeeRoleData = {\n        id: `role-${Date.now()}`,\n        name,\n    };\n    roles.push(newRole);\n    await writeData<EmployeeRoleData>('employee-roles.json', roles);\n    return newRole;\n}\n\nexport const deleteEmployeeRole = async (id: string): Promise<{ success: boolean }> => {\n    let roles = await getEmployeeRoles();\n    const initialLength = roles.length;\n    roles = roles.filter(role => role.id !== id);\n    await writeData<EmployeeRoleData>('employee-roles.json', roles);\n    return { success: roles.length < initialLength };\n}\n\nexport const getDepartments = async (): Promise<Department[]> => {\n    return await readData<Department>('departments.json');\n}\n\nexport const addDepartment = async (name: string): Promise<Department> => {\n    const departments = await getDepartments();\n    const newDepartment: Department = {\n        id: `dept-${Date.now()}`,\n        name,\n    };\n    departments.push(newDepartment);\n    await writeData<Department>('departments.json', departments);\n    return newDepartment;\n}\n\nexport const deleteDepartment = async (id: string): Promise<{ success: boolean }> => {\n    let departments = await getDepartments();\n    const initialLength = departments.length;\n    departments = departments.filter(dept => dept.id !== id);\n    await writeData<Department>('departments.json', departments);\n    return { success: departments.length < initialLength };\n}\n"],"names":[],"mappings":";;;;;;IAsEa,sBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/data/index.ts"],"sourcesContent":["\n'use server';\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { Lead, Activity, Product, LeadSource, UpdatableLeadData, Quotation, QuotationTemplate, NewProduct, Employee, NewEmployee, EmployeeRoleData, Department } from '../types';\n\nconst dataPath = path.join(process.cwd(), 'src', 'lib', 'data');\n\nasync function readData<T>(filename: string): Promise<T[]> {\n  try {\n    const filePath = path.join(dataPath, filename);\n    const fileContent = await fs.readFile(filePath, 'utf-8');\n    return JSON.parse(fileContent);\n  } catch (error) {\n    if (isNodeError(error) && error.code === 'ENOENT') {\n      // If the file doesn't exist, create it with an empty array\n      await writeData(filename, []);\n      return [];\n    }\n    console.error(`Error reading ${filename}:`, error);\n    throw new Error(`Could not read ${filename}`);\n  }\n}\n\nasync function writeData<T>(filename: string, data: T[]): Promise<void> {\n  try {\n    const filePath = path.join(dataPath, filename);\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n  } catch (error)\n{\n    console.error(`Error writing ${filename}:`, error);\n    throw new Error(`Could not write to ${filename}`);\n  }\n}\n\nfunction isNodeError(error: unknown): error is NodeJS.ErrnoException {\n    return error instanceof Error;\n}\n\nexport const getLeads = async (query?: string, status?: string): Promise<Lead[]> => {\n  let leads = await readData<Lead>('leads.json');\n  \n  if (query) {\n    const lowercasedQuery = query.toLowerCase();\n    leads = leads.filter(\n      lead =>\n        lead.name.toLowerCase().includes(lowercasedQuery) ||\n        lead.company.toLowerCase().includes(lowercasedQuery)\n    );\n  }\n\n  if (status) {\n    leads = leads.filter(lead => lead.status === status);\n  }\n  \n  return leads.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getLeadById = async (id: string): Promise<Lead | undefined> => {\n    const leads = await getLeads();\n    const lead = leads.find(lead => lead.id === id);\n    if (!lead) return undefined;\n    \n    return {\n      ...lead,\n      activities: lead.activities.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())\n    };\n};\n\nexport const getRecentActivities = async (limit: number): Promise<{ lead: Lead; activity: Activity }[]> => {\n    const leads = await getLeads();\n    const allActivities = leads.flatMap(lead => \n        lead.activities.map(activity => ({ lead, activity }))\n    );\n    return allActivities\n        .sort((a, b) => new Date(b.activity.date).getTime() - new Date(a.activity.date).getTime())\n        .slice(0, limit);\n}\n\nexport const getProducts = async (): Promise<Product[]> => {\n  return await readData<Product>('products.json');\n}\n\nexport const getLeadSources = async (): Promise<LeadSource[]> => {\n    return await readData<LeadSource>('lead-sources.json');\n}\n\nexport const addProduct = async (productData: NewProduct): Promise<Product> => {\n  const products = await getProducts();\n  const newProduct: Product = {\n    ...productData,\n    id: `prod-${Date.now()}`,\n  };\n  products.unshift(newProduct);\n  await writeData<Product>('products.json', products);\n  return newProduct;\n};\n\nexport const updateProduct = async (id: string, productData: NewProduct): Promise<Product> => {\n    const products = await getProducts();\n    const productIndex = products.findIndex(p => p.id === id);\n    if (productIndex === -1) {\n        throw new Error('Product not found');\n    }\n    const updatedProduct = { ...products[productIndex], ...productData };\n    products[productIndex] = updatedProduct;\n    await writeData<Product>('products.json', products);\n    return updatedProduct;\n};\n\nexport const deleteProduct = async (id: string): Promise<{ success: boolean }> => {\n    let products = await getProducts();\n    const initialLength = products.length;\n    products = products.filter(p => p.id !== id);\n    if (products.length === initialLength) {\n        throw new Error('Product not found for deletion');\n    }\n    await writeData<Product>('products.json', products);\n    return { success: true };\n};\n\n\nexport const addLeadSource = async (name: string): Promise<LeadSource> => {\n    const leadSources = await getLeadSources();\n    const newSource: LeadSource = {\n        id: `source-${Date.now()}`,\n        name,\n    };\n    leadSources.unshift(newSource);\n    await writeData<LeadSource>('lead-sources.json', leadSources);\n    return newSource;\n};\n\nexport const deleteLeadSource = async (id: string): Promise<{ success: boolean }> => {\n    let leadSources = await getLeadSources();\n    const initialLength = leadSources.length;\n    leadSources = leadSources.filter(source => source.id !== id);\n    await writeData<LeadSource>('lead-sources.json', leadSources);\n    return { success: leadSources.length < initialLength };\n};\n\nexport const addLead = async (leadData: Omit<Lead, 'id' | 'createdAt' | 'activities'> & { notes?: string }): Promise<Lead> => {\n  const leads = await getLeads();\n  const newId = `lead-${Date.now()}`;\n  \n  const initialActivity: Activity[] = [];\n  if (leadData.notes) {\n    initialActivity.push({\n      id: `act-${newId}-1`,\n      date: new Date().toISOString(),\n      type: 'Email', \n      notes: `Lead created in the system. Initial notes: ${leadData.notes}`,\n    });\n  }\n\n  const { notes, ...restOfLeadData } = leadData;\n\n  const newLead: Lead = {\n    ...restOfLeadData,\n    id: newId,\n    createdAt: new Date().toISOString(),\n    activities: initialActivity,\n  };\n  leads.unshift(newLead);\n  await writeData<Lead>('leads.json', leads);\n  return newLead;\n};\n\nexport const addActivityToLead = async (leadId: string, activityData: Omit<Activity, 'id' | 'date'>): Promise<Activity> => {\n  const leads = await getLeads();\n  const leadIndex = leads.findIndex(l => l.id === leadId);\n  if (leadIndex === -1) {\n    throw new Error('Lead not found');\n  }\n\n  const lead = leads[leadIndex];\n  const newActivity: Activity = {\n    ...activityData,\n    id: `act-${leadId}-${lead.activities.length + 1}`,\n    date: new Date().toISOString(),\n  };\n  lead.activities.unshift(newActivity);\n  \n  await writeData<Lead>('leads.json', leads);\n  return newActivity;\n};\n\nexport const updateLeadStatus = async (leadId: string, status: Lead['status']): Promise<Lead> => {\n  const leads = await getLeads();\n  const leadIndex = leads.findIndex(l => l.id === leadId);\n  if (leadIndex === -1) {\n    throw new Error('Lead not found');\n  }\n\n  leads[leadIndex].status = status;\n  await writeData<Lead>('leads.json', leads);\n  return leads[leadIndex];\n};\n\nexport const updateLead = async (leadId: string, leadData: UpdatableLeadData): Promise<Lead> => {\n    const leads = await getLeads();\n    const leadIndex = leads.findIndex(l => l.id === leadId);\n    if (leadIndex === -1) {\n      throw new Error('Lead not found');\n    }\n  \n    const originalLead = leads[leadIndex];\n    const updatedLead: Lead = {\n      ...originalLead,\n      ...leadData,\n    };\n  \n    leads[leadIndex] = updatedLead;\n    await writeData<Lead>('leads.json', leads);\n    return updatedLead;\n};\n\n// Quotation specific functions\nexport const getQuotations = async (): Promise<Quotation[]> => {\n    const quotations = await readData<Quotation>('quotations.json');\n    return quotations.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getQuotationById = async (id: string): Promise<Quotation | undefined> => {\n    const quotations = await getQuotations();\n    return quotations.find(q => q.id === id);\n};\n\nexport const addQuotation = async (quotationData: Omit<Quotation, 'id' | 'createdAt' | 'quotationNumber'>): Promise<Quotation> => {\n    const quotations = await getQuotations();\n    const newQuotationNumber = `QUO-${String(quotations.length + 1).padStart(4, '0')}`;\n    const newQuotation: Quotation = {\n        ...quotationData,\n        id: `quo-${Date.now()}`,\n        quotationNumber: newQuotationNumber,\n        createdAt: new Date().toISOString(),\n    };\n    quotations.unshift(newQuotation);\n    await writeData<Quotation>('quotations.json', quotations);\n    return newQuotation;\n};\n\nexport const getQuotationTemplates = async (): Promise<QuotationTemplate[]> => {\n    return await readData<QuotationTemplate>('quotation-templates.json');\n};\n\nexport const getQuotationTemplateById = async (id: string): Promise<QuotationTemplate | undefined> => {\n    const templates = await getQuotationTemplates();\n    return templates.find(t => t.id === id);\n};\n\nexport const addQuotationTemplate = async (templateData: Omit<QuotationTemplate, 'id'>): Promise<QuotationTemplate> => {\n    const templates = await getQuotationTemplates();\n    const newTemplate: QuotationTemplate = {\n        ...templateData,\n        id: `template-${Date.now()}`,\n    };\n    templates.unshift(newTemplate);\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return newTemplate;\n};\n\nexport const updateQuotationTemplate = async (id: string, templateData: QuotationTemplate): Promise<QuotationTemplate> => {\n    const templates = await getQuotationTemplates();\n    const templateIndex = templates.findIndex(t => t.id === id);\n    if (templateIndex === -1) {\n        throw new Error('Template not found');\n    }\n    templates[templateIndex] = { ...templates[templateIndex], ...templateData };\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return templates[templateIndex];\n}\n\nexport const deleteQuotationTemplate = async (id: string): Promise<{ success: boolean }> => {\n    let templates = await getQuotationTemplates();\n    const initialLength = templates.length;\n    templates = templates.filter(t => t.id !== id);\n    if (templates.length === initialLength) {\n        throw new Error('Template not found for deletion');\n    }\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return { success: true };\n}\n\n\n// Employee specific functions\nexport const getEmployees = async (): Promise<Employee[]> => {\n    const employees = await readData<Employee>('employees.json');\n    return employees.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getEmployeeById = async (id: string): Promise<Employee | undefined> => {\n    const employees = await getEmployees();\n    return employees.find(employee => employee.id === id);\n};\n\nexport const addEmployee = async (employeeData: NewEmployee): Promise<Employee> => {\n    const employees = await getEmployees();\n    const newEmployee: Employee = {\n        ...employeeData,\n        id: `emp-${Date.now()}`,\n        createdAt: new Date().toISOString(),\n    };\n    employees.unshift(newEmployee);\n    await writeData<Employee>('employees.json', employees);\n    return newEmployee;\n};\n\nexport const getEmployeeRoles = async (): Promise<EmployeeRoleData[]> => {\n    return await readData<EmployeeRoleData>('employee-roles.json');\n}\n\nexport const addEmployeeRole = async (name: string): Promise<EmployeeRoleData> => {\n    const roles = await getEmployeeRoles();\n    const newRole: EmployeeRoleData = {\n        id: `role-${Date.now()}`,\n        name,\n    };\n    roles.push(newRole);\n    await writeData<EmployeeRoleData>('employee-roles.json', roles);\n    return newRole;\n}\n\nexport const deleteEmployeeRole = async (id: string): Promise<{ success: boolean }> => {\n    let roles = await getEmployeeRoles();\n    const initialLength = roles.length;\n    roles = roles.filter(role => role.id !== id);\n    await writeData<EmployeeRoleData>('employee-roles.json', roles);\n    return { success: roles.length < initialLength };\n}\n\nexport const getDepartments = async (): Promise<Department[]> => {\n    return await readData<Department>('departments.json');\n}\n\nexport const addDepartment = async (name: string): Promise<Department> => {\n    const departments = await getDepartments();\n    const newDepartment: Department = {\n        id: `dept-${Date.now()}`,\n        name,\n    };\n    departments.push(newDepartment);\n    await writeData<Department>('departments.json', departments);\n    return newDepartment;\n}\n\nexport const deleteDepartment = async (id: string): Promise<{ success: boolean }> => {\n    let departments = await getDepartments();\n    const initialLength = departments.length;\n    departments = departments.filter(dept => dept.id !== id);\n    await writeData<Department>('departments.json', departments);\n    return { success: departments.length < initialLength };\n}\n"],"names":[],"mappings":";;;;;;IAgFa,cAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/data/index.ts"],"sourcesContent":["\n'use server';\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { Lead, Activity, Product, LeadSource, UpdatableLeadData, Quotation, QuotationTemplate, NewProduct, Employee, NewEmployee, EmployeeRoleData, Department } from '../types';\n\nconst dataPath = path.join(process.cwd(), 'src', 'lib', 'data');\n\nasync function readData<T>(filename: string): Promise<T[]> {\n  try {\n    const filePath = path.join(dataPath, filename);\n    const fileContent = await fs.readFile(filePath, 'utf-8');\n    return JSON.parse(fileContent);\n  } catch (error) {\n    if (isNodeError(error) && error.code === 'ENOENT') {\n      // If the file doesn't exist, create it with an empty array\n      await writeData(filename, []);\n      return [];\n    }\n    console.error(`Error reading ${filename}:`, error);\n    throw new Error(`Could not read ${filename}`);\n  }\n}\n\nasync function writeData<T>(filename: string, data: T[]): Promise<void> {\n  try {\n    const filePath = path.join(dataPath, filename);\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n  } catch (error)\n{\n    console.error(`Error writing ${filename}:`, error);\n    throw new Error(`Could not write to ${filename}`);\n  }\n}\n\nfunction isNodeError(error: unknown): error is NodeJS.ErrnoException {\n    return error instanceof Error;\n}\n\nexport const getLeads = async (query?: string, status?: string): Promise<Lead[]> => {\n  let leads = await readData<Lead>('leads.json');\n  \n  if (query) {\n    const lowercasedQuery = query.toLowerCase();\n    leads = leads.filter(\n      lead =>\n        lead.name.toLowerCase().includes(lowercasedQuery) ||\n        lead.company.toLowerCase().includes(lowercasedQuery)\n    );\n  }\n\n  if (status) {\n    leads = leads.filter(lead => lead.status === status);\n  }\n  \n  return leads.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getLeadById = async (id: string): Promise<Lead | undefined> => {\n    const leads = await getLeads();\n    const lead = leads.find(lead => lead.id === id);\n    if (!lead) return undefined;\n    \n    return {\n      ...lead,\n      activities: lead.activities.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())\n    };\n};\n\nexport const getRecentActivities = async (limit: number): Promise<{ lead: Lead; activity: Activity }[]> => {\n    const leads = await getLeads();\n    const allActivities = leads.flatMap(lead => \n        lead.activities.map(activity => ({ lead, activity }))\n    );\n    return allActivities\n        .sort((a, b) => new Date(b.activity.date).getTime() - new Date(a.activity.date).getTime())\n        .slice(0, limit);\n}\n\nexport const getProducts = async (): Promise<Product[]> => {\n  return await readData<Product>('products.json');\n}\n\nexport const getLeadSources = async (): Promise<LeadSource[]> => {\n    return await readData<LeadSource>('lead-sources.json');\n}\n\nexport const addProduct = async (productData: NewProduct): Promise<Product> => {\n  const products = await getProducts();\n  const newProduct: Product = {\n    ...productData,\n    id: `prod-${Date.now()}`,\n  };\n  products.unshift(newProduct);\n  await writeData<Product>('products.json', products);\n  return newProduct;\n};\n\nexport const updateProduct = async (id: string, productData: NewProduct): Promise<Product> => {\n    const products = await getProducts();\n    const productIndex = products.findIndex(p => p.id === id);\n    if (productIndex === -1) {\n        throw new Error('Product not found');\n    }\n    const updatedProduct = { ...products[productIndex], ...productData };\n    products[productIndex] = updatedProduct;\n    await writeData<Product>('products.json', products);\n    return updatedProduct;\n};\n\nexport const deleteProduct = async (id: string): Promise<{ success: boolean }> => {\n    let products = await getProducts();\n    const initialLength = products.length;\n    products = products.filter(p => p.id !== id);\n    if (products.length === initialLength) {\n        throw new Error('Product not found for deletion');\n    }\n    await writeData<Product>('products.json', products);\n    return { success: true };\n};\n\n\nexport const addLeadSource = async (name: string): Promise<LeadSource> => {\n    const leadSources = await getLeadSources();\n    const newSource: LeadSource = {\n        id: `source-${Date.now()}`,\n        name,\n    };\n    leadSources.unshift(newSource);\n    await writeData<LeadSource>('lead-sources.json', leadSources);\n    return newSource;\n};\n\nexport const deleteLeadSource = async (id: string): Promise<{ success: boolean }> => {\n    let leadSources = await getLeadSources();\n    const initialLength = leadSources.length;\n    leadSources = leadSources.filter(source => source.id !== id);\n    await writeData<LeadSource>('lead-sources.json', leadSources);\n    return { success: leadSources.length < initialLength };\n};\n\nexport const addLead = async (leadData: Omit<Lead, 'id' | 'createdAt' | 'activities'> & { notes?: string }): Promise<Lead> => {\n  const leads = await getLeads();\n  const newId = `lead-${Date.now()}`;\n  \n  const initialActivity: Activity[] = [];\n  if (leadData.notes) {\n    initialActivity.push({\n      id: `act-${newId}-1`,\n      date: new Date().toISOString(),\n      type: 'Email', \n      notes: `Lead created in the system. Initial notes: ${leadData.notes}`,\n    });\n  }\n\n  const { notes, ...restOfLeadData } = leadData;\n\n  const newLead: Lead = {\n    ...restOfLeadData,\n    id: newId,\n    createdAt: new Date().toISOString(),\n    activities: initialActivity,\n  };\n  leads.unshift(newLead);\n  await writeData<Lead>('leads.json', leads);\n  return newLead;\n};\n\nexport const addActivityToLead = async (leadId: string, activityData: Omit<Activity, 'id' | 'date'>): Promise<Activity> => {\n  const leads = await getLeads();\n  const leadIndex = leads.findIndex(l => l.id === leadId);\n  if (leadIndex === -1) {\n    throw new Error('Lead not found');\n  }\n\n  const lead = leads[leadIndex];\n  const newActivity: Activity = {\n    ...activityData,\n    id: `act-${leadId}-${lead.activities.length + 1}`,\n    date: new Date().toISOString(),\n  };\n  lead.activities.unshift(newActivity);\n  \n  await writeData<Lead>('leads.json', leads);\n  return newActivity;\n};\n\nexport const updateLeadStatus = async (leadId: string, status: Lead['status']): Promise<Lead> => {\n  const leads = await getLeads();\n  const leadIndex = leads.findIndex(l => l.id === leadId);\n  if (leadIndex === -1) {\n    throw new Error('Lead not found');\n  }\n\n  leads[leadIndex].status = status;\n  await writeData<Lead>('leads.json', leads);\n  return leads[leadIndex];\n};\n\nexport const updateLead = async (leadId: string, leadData: UpdatableLeadData): Promise<Lead> => {\n    const leads = await getLeads();\n    const leadIndex = leads.findIndex(l => l.id === leadId);\n    if (leadIndex === -1) {\n      throw new Error('Lead not found');\n    }\n  \n    const originalLead = leads[leadIndex];\n    const updatedLead: Lead = {\n      ...originalLead,\n      ...leadData,\n    };\n  \n    leads[leadIndex] = updatedLead;\n    await writeData<Lead>('leads.json', leads);\n    return updatedLead;\n};\n\n// Quotation specific functions\nexport const getQuotations = async (): Promise<Quotation[]> => {\n    const quotations = await readData<Quotation>('quotations.json');\n    return quotations.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getQuotationById = async (id: string): Promise<Quotation | undefined> => {\n    const quotations = await getQuotations();\n    return quotations.find(q => q.id === id);\n};\n\nexport const addQuotation = async (quotationData: Omit<Quotation, 'id' | 'createdAt' | 'quotationNumber'>): Promise<Quotation> => {\n    const quotations = await getQuotations();\n    const newQuotationNumber = `QUO-${String(quotations.length + 1).padStart(4, '0')}`;\n    const newQuotation: Quotation = {\n        ...quotationData,\n        id: `quo-${Date.now()}`,\n        quotationNumber: newQuotationNumber,\n        createdAt: new Date().toISOString(),\n    };\n    quotations.unshift(newQuotation);\n    await writeData<Quotation>('quotations.json', quotations);\n    return newQuotation;\n};\n\nexport const getQuotationTemplates = async (): Promise<QuotationTemplate[]> => {\n    return await readData<QuotationTemplate>('quotation-templates.json');\n};\n\nexport const getQuotationTemplateById = async (id: string): Promise<QuotationTemplate | undefined> => {\n    const templates = await getQuotationTemplates();\n    return templates.find(t => t.id === id);\n};\n\nexport const addQuotationTemplate = async (templateData: Omit<QuotationTemplate, 'id'>): Promise<QuotationTemplate> => {\n    const templates = await getQuotationTemplates();\n    const newTemplate: QuotationTemplate = {\n        ...templateData,\n        id: `template-${Date.now()}`,\n    };\n    templates.unshift(newTemplate);\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return newTemplate;\n};\n\nexport const updateQuotationTemplate = async (id: string, templateData: QuotationTemplate): Promise<QuotationTemplate> => {\n    const templates = await getQuotationTemplates();\n    const templateIndex = templates.findIndex(t => t.id === id);\n    if (templateIndex === -1) {\n        throw new Error('Template not found');\n    }\n    templates[templateIndex] = { ...templates[templateIndex], ...templateData };\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return templates[templateIndex];\n}\n\nexport const deleteQuotationTemplate = async (id: string): Promise<{ success: boolean }> => {\n    let templates = await getQuotationTemplates();\n    const initialLength = templates.length;\n    templates = templates.filter(t => t.id !== id);\n    if (templates.length === initialLength) {\n        throw new Error('Template not found for deletion');\n    }\n    await writeData<QuotationTemplate>('quotation-templates.json', templates);\n    return { success: true };\n}\n\n\n// Employee specific functions\nexport const getEmployees = async (): Promise<Employee[]> => {\n    const employees = await readData<Employee>('employees.json');\n    return employees.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n};\n\nexport const getEmployeeById = async (id: string): Promise<Employee | undefined> => {\n    const employees = await getEmployees();\n    return employees.find(employee => employee.id === id);\n};\n\nexport const addEmployee = async (employeeData: NewEmployee): Promise<Employee> => {\n    const employees = await getEmployees();\n    const newEmployee: Employee = {\n        ...employeeData,\n        id: `emp-${Date.now()}`,\n        createdAt: new Date().toISOString(),\n    };\n    employees.unshift(newEmployee);\n    await writeData<Employee>('employees.json', employees);\n    return newEmployee;\n};\n\nexport const getEmployeeRoles = async (): Promise<EmployeeRoleData[]> => {\n    return await readData<EmployeeRoleData>('employee-roles.json');\n}\n\nexport const addEmployeeRole = async (name: string): Promise<EmployeeRoleData> => {\n    const roles = await getEmployeeRoles();\n    const newRole: EmployeeRoleData = {\n        id: `role-${Date.now()}`,\n        name,\n    };\n    roles.push(newRole);\n    await writeData<EmployeeRoleData>('employee-roles.json', roles);\n    return newRole;\n}\n\nexport const deleteEmployeeRole = async (id: string): Promise<{ success: boolean }> => {\n    let roles = await getEmployeeRoles();\n    const initialLength = roles.length;\n    roles = roles.filter(role => role.id !== id);\n    await writeData<EmployeeRoleData>('employee-roles.json', roles);\n    return { success: roles.length < initialLength };\n}\n\nexport const getDepartments = async (): Promise<Department[]> => {\n    return await readData<Department>('departments.json');\n}\n\nexport const addDepartment = async (name: string): Promise<Department> => {\n    const departments = await getDepartments();\n    const newDepartment: Department = {\n        id: `dept-${Date.now()}`,\n        name,\n    };\n    departments.push(newDepartment);\n    await writeData<Department>('departments.json', departments);\n    return newDepartment;\n}\n\nexport const deleteDepartment = async (id: string): Promise<{ success: boolean }> => {\n    let departments = await getDepartments();\n    const initialLength = departments.length;\n    departments = departments.filter(dept => dept.id !== id);\n    await writeData<Department>('departments.json', departments);\n    return { success: departments.length < initialLength };\n}\n"],"names":[],"mappings":";;;;;;IA2Na,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/dashboard-chart.tsx"],"sourcesContent":["'use client';\n\nimport {\n  BarChart,\n  Bar,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  ResponsiveContainer,\n  Cell,\n} from 'recharts';\n\nconst statusColors: { [key: string]: string } = {\n  New: 'hsl(var(--chart-1))',\n  'In Discussion': 'hsl(var(--chart-2))',\n  Negotiation: 'hsl(var(--chart-3))',\n  'Closed - Won': 'hsl(var(--chart-4))',\n  'Closed - Lost': 'hsl(var(--chart-5))',\n};\n\ntype ChartData = {\n    name: string;\n    value: number;\n}\n\nconst statusToColor = (status: string) => {\n    if (status === 'Discussion') return statusColors['In Discussion'];\n    if (status === 'Won') return statusColors['Closed - Won'];\n    if (status === 'Lost') return statusColors['Closed - Lost'];\n    return statusColors[status] || '#8884d8';\n  };\n\nexport default function DashboardChart({ data }: { data: ChartData[] }) {\n  return (\n    <ResponsiveContainer width=\"100%\" height={350}>\n      <BarChart data={data}>\n        <CartesianGrid strokeDasharray=\"3 3\" vertical={false} />\n        <XAxis\n          dataKey=\"name\"\n          stroke=\"#888888\"\n          fontSize={12}\n          tickLine={false}\n          axisLine={false}\n        />\n        <YAxis\n          stroke=\"#888888\"\n          fontSize={12}\n          tickLine={false}\n          axisLine={false}\n          tickFormatter={(value) => `${value}`}\n        />\n        <Tooltip\n          cursor={{ fill: 'hsl(var(--muted))' }}\n          contentStyle={{\n            backgroundColor: 'hsl(var(--background))',\n            border: '1px solid hsl(var(--border))',\n          }}\n        />\n        <Bar dataKey=\"value\" radius={[4, 4, 0, 0]}>\n          {data.map((entry, index) => (\n            <Cell\n              key={`cell-${index}`}\n              fill={statusToColor(entry.name)}\n            />\n          ))}\n        </Bar>\n      </BarChart>\n    </ResponsiveContainer>\n  );\n}"],"names":[],"mappings":";;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;;;AAaA,MAAM,eAA0C;IAC9C,KAAK;IACL,iBAAiB;IACjB,aAAa;IACb,gBAAgB;IAChB,iBAAiB;AACnB;AAOA,MAAM,gBAAgB,CAAC;IACnB,IAAI,WAAW,cAAc,OAAO,YAAY,CAAC,gBAAgB;IACjE,IAAI,WAAW,OAAO,OAAO,YAAY,CAAC,eAAe;IACzD,IAAI,WAAW,QAAQ,OAAO,YAAY,CAAC,gBAAgB;IAC3D,OAAO,YAAY,CAAC,OAAO,IAAI;AACjC;AAEa,SAAS,eAAe,EAAE,IAAI,EAAyB;IACpE,qBACE,8OAAC,mKAAA,CAAA,sBAAmB;QAAC,OAAM;QAAO,QAAQ;kBACxC,cAAA,8OAAC,oJAAA,CAAA,WAAQ;YAAC,MAAM;;8BACd,8OAAC,6JAAA,CAAA,gBAAa;oBAAC,iBAAgB;oBAAM,UAAU;;;;;;8BAC/C,8OAAC,qJAAA,CAAA,QAAK;oBACJ,SAAQ;oBACR,QAAO;oBACP,UAAU;oBACV,UAAU;oBACV,UAAU;;;;;;8BAEZ,8OAAC,qJAAA,CAAA,QAAK;oBACJ,QAAO;oBACP,UAAU;oBACV,UAAU;oBACV,UAAU;oBACV,eAAe,CAAC,QAAU,GAAG,OAAO;;;;;;8BAEtC,8OAAC,uJAAA,CAAA,UAAO;oBACN,QAAQ;wBAAE,MAAM;oBAAoB;oBACpC,cAAc;wBACZ,iBAAiB;wBACjB,QAAQ;oBACV;;;;;;8BAEF,8OAAC,mJAAA,CAAA,MAAG;oBAAC,SAAQ;oBAAQ,QAAQ;wBAAC;wBAAG;wBAAG;wBAAG;qBAAE;8BACtC,KAAK,GAAG,CAAC,CAAC,OAAO,sBAChB,8OAAC,oJAAA,CAAA,OAAI;4BAEH,MAAM,cAAc,MAAM,IAAI;2BADzB,CAAC,KAAK,EAAE,OAAO;;;;;;;;;;;;;;;;;;;;;AAQlC","debugId":null}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/product-demand-chart.tsx"],"sourcesContent":["'use client';\n\nimport {\n  BarChart,\n  Bar,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  ResponsiveContainer,\n} from 'recharts';\n\ntype ChartData = {\n    name: string;\n    count: number;\n}\n\nexport default function ProductDemandChart({ data }: { data: ChartData[] }) {\n  if (data.length === 0) {\n    return (\n        <div className=\"text-center text-muted-foreground py-10\">\n            No product data available to display.\n        </div>\n    );\n  }\n  return (\n    <ResponsiveContainer width=\"100%\" height={350}>\n      <BarChart data={data}>\n        <CartesianGrid strokeDasharray=\"3 3\" vertical={false} />\n        <XAxis\n          dataKey=\"name\"\n          stroke=\"#888888\"\n          fontSize={12}\n          tickLine={false}\n          axisLine={false}\n          angle={-45}\n          textAnchor=\"end\"\n          height={60}\n        />\n        <YAxis\n          stroke=\"#888888\"\n          fontSize={12}\n          tickLine={false}\n          axisLine={false}\n          tickFormatter={(value) => `${value}`}\n          allowDecimals={false}\n        />\n        <Tooltip\n          cursor={{ fill: 'hsl(var(--muted))' }}\n          contentStyle={{\n            backgroundColor: 'hsl(var(--background))',\n            border: '1px solid hsl(var(--border))',\n          }}\n        />\n        <Bar dataKey=\"count\" fill=\"hsl(var(--primary))\" radius={[4, 4, 0, 0]} />\n      </BarChart>\n    </ResponsiveContainer>\n  );\n}\n"],"names":[],"mappings":";;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;;;AAiBe,SAAS,mBAAmB,EAAE,IAAI,EAAyB;IACxE,IAAI,KAAK,MAAM,KAAK,GAAG;QACrB,qBACI,8OAAC;YAAI,WAAU;sBAA0C;;;;;;IAI/D;IACA,qBACE,8OAAC,mKAAA,CAAA,sBAAmB;QAAC,OAAM;QAAO,QAAQ;kBACxC,cAAA,8OAAC,oJAAA,CAAA,WAAQ;YAAC,MAAM;;8BACd,8OAAC,6JAAA,CAAA,gBAAa;oBAAC,iBAAgB;oBAAM,UAAU;;;;;;8BAC/C,8OAAC,qJAAA,CAAA,QAAK;oBACJ,SAAQ;oBACR,QAAO;oBACP,UAAU;oBACV,UAAU;oBACV,UAAU;oBACV,OAAO,CAAC;oBACR,YAAW;oBACX,QAAQ;;;;;;8BAEV,8OAAC,qJAAA,CAAA,QAAK;oBACJ,QAAO;oBACP,UAAU;oBACV,UAAU;oBACV,UAAU;oBACV,eAAe,CAAC,QAAU,GAAG,OAAO;oBACpC,eAAe;;;;;;8BAEjB,8OAAC,uJAAA,CAAA,UAAO;oBACN,QAAQ;wBAAE,MAAM;oBAAoB;oBACpC,cAAc;wBACZ,iBAAiB;wBACjB,QAAQ;oBACV;;;;;;8BAEF,8OAAC,mJAAA,CAAA,MAAG;oBAAC,SAAQ;oBAAQ,MAAK;oBAAsB,QAAQ;wBAAC;wBAAG;wBAAG;wBAAG;qBAAE;;;;;;;;;;;;;;;;;AAI5E","debugId":null}},
    {"offset": {"line": 408, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/average-conversion-time-chart.tsx"],"sourcesContent":["\n'use client';\n\nimport {\n  RadialBarChart,\n  RadialBar,\n  PolarAngleAxis,\n  ResponsiveContainer,\n} from 'recharts';\n\nexport default function AverageConversionTimeChart({ timeInDays }: { timeInDays: number }) {\n  const data = [{ name: 'Conversion Time', value: timeInDays }];\n\n  return (\n    <ResponsiveContainer width=\"100%\" height={150}>\n      <RadialBarChart\n        innerRadius=\"80%\"\n        outerRadius=\"100%\"\n        barSize={10}\n        data={data}\n        startAngle={90}\n        endAngle={-270}\n      >\n        <PolarAngleAxis\n          type=\"number\"\n          domain={[0, Math.max(timeInDays, 30)]} // Ensure a reasonable max value\n          angleAxisId={0}\n          tick={false}\n        />\n        <RadialBar\n          background\n          dataKey=\"value\"\n          cornerRadius={10}\n          fill=\"hsl(var(--primary))\"\n        />\n        <text\n          x=\"50%\"\n          y=\"50%\"\n          textAnchor=\"middle\"\n          dominantBaseline=\"middle\"\n          className=\"fill-foreground text-3xl font-bold\"\n        >\n          {timeInDays}\n        </text>\n        <text\n          x=\"50%\"\n          y=\"65%\"\n          textAnchor=\"middle\"\n          dominantBaseline=\"middle\"\n          className=\"fill-muted-foreground text-sm\"\n        >\n          Days\n        </text>\n      </RadialBarChart>\n    </ResponsiveContainer>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AAAA;AAAA;AAAA;AAFA;;;AASe,SAAS,2BAA2B,EAAE,UAAU,EAA0B;IACvF,MAAM,OAAO;QAAC;YAAE,MAAM;YAAmB,OAAO;QAAW;KAAE;IAE7D,qBACE,8OAAC,mKAAA,CAAA,sBAAmB;QAAC,OAAM;QAAO,QAAQ;kBACxC,cAAA,8OAAC,0JAAA,CAAA,iBAAc;YACb,aAAY;YACZ,aAAY;YACZ,SAAS;YACT,MAAM;YACN,YAAY;YACZ,UAAU,CAAC;;8BAEX,8OAAC,0JAAA,CAAA,iBAAc;oBACb,MAAK;oBACL,QAAQ;wBAAC;wBAAG,KAAK,GAAG,CAAC,YAAY;qBAAI;oBACrC,aAAa;oBACb,MAAM;;;;;;8BAER,8OAAC,qJAAA,CAAA,YAAS;oBACR,UAAU;oBACV,SAAQ;oBACR,cAAc;oBACd,MAAK;;;;;;8BAEP,8OAAC;oBACC,GAAE;oBACF,GAAE;oBACF,YAAW;oBACX,kBAAiB;oBACjB,WAAU;8BAET;;;;;;8BAEH,8OAAC;oBACC,GAAE;oBACF,GAAE;oBACF,YAAW;oBACX,kBAAiB;oBACjB,WAAU;8BACX;;;;;;;;;;;;;;;;;AAMT","debugId":null}},
    {"offset": {"line": 502, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/quotations-by-month-chart.tsx"],"sourcesContent":["\n'use client';\n\nimport {\n  BarChart,\n  Bar,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  ResponsiveContainer,\n} from 'recharts';\n\ntype ChartData = {\n  month: string;\n  count: number;\n}\n\nexport default function QuotationsByMonthChart({ data }: { data: ChartData[] }) {\n  if (data.length === 0) {\n    return (\n        <div className=\"text-center text-muted-foreground py-10\">\n            No quotation data available for the last 12 months.\n        </div>\n    );\n  }\n  return (\n    <ResponsiveContainer width=\"100%\" height={350}>\n      <BarChart data={data}>\n        <CartesianGrid strokeDasharray=\"3 3\" vertical={false} />\n        <XAxis\n          dataKey=\"month\"\n          stroke=\"#888888\"\n          fontSize={12}\n          tickLine={false}\n          axisLine={false}\n        />\n        <YAxis\n          stroke=\"#888888\"\n          fontSize={12}\n          tickLine={false}\n          axisLine={false}\n          tickFormatter={(value) => `${value}`}\n          allowDecimals={false}\n        />\n        <Tooltip\n          cursor={{ fill: 'hsl(var(--muted))' }}\n          contentStyle={{\n            backgroundColor: 'hsl(var(--background))',\n            border: '1px solid hsl(var(--border))',\n          }}\n        />\n        <Bar dataKey=\"count\" fill=\"hsl(var(--primary))\" radius={[4, 4, 0, 0]} />\n      </BarChart>\n    </ResponsiveContainer>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;;;AAiBe,SAAS,uBAAuB,EAAE,IAAI,EAAyB;IAC5E,IAAI,KAAK,MAAM,KAAK,GAAG;QACrB,qBACI,8OAAC;YAAI,WAAU;sBAA0C;;;;;;IAI/D;IACA,qBACE,8OAAC,mKAAA,CAAA,sBAAmB;QAAC,OAAM;QAAO,QAAQ;kBACxC,cAAA,8OAAC,oJAAA,CAAA,WAAQ;YAAC,MAAM;;8BACd,8OAAC,6JAAA,CAAA,gBAAa;oBAAC,iBAAgB;oBAAM,UAAU;;;;;;8BAC/C,8OAAC,qJAAA,CAAA,QAAK;oBACJ,SAAQ;oBACR,QAAO;oBACP,UAAU;oBACV,UAAU;oBACV,UAAU;;;;;;8BAEZ,8OAAC,qJAAA,CAAA,QAAK;oBACJ,QAAO;oBACP,UAAU;oBACV,UAAU;oBACV,UAAU;oBACV,eAAe,CAAC,QAAU,GAAG,OAAO;oBACpC,eAAe;;;;;;8BAEjB,8OAAC,uJAAA,CAAA,UAAO;oBACN,QAAQ;wBAAE,MAAM;oBAAoB;oBACpC,cAAc;wBACZ,iBAAiB;wBACjB,QAAQ;oBACV;;;;;;8BAEF,8OAAC,mJAAA,CAAA,MAAG;oBAAC,SAAQ;oBAAQ,MAAK;oBAAsB,QAAQ;wBAAC;wBAAG;wBAAG;wBAAG;qBAAE;;;;;;;;;;;;;;;;;AAI5E","debugId":null}},
    {"offset": {"line": 609, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/page.tsx"],"sourcesContent":["\n'use client';\nimport * as React from 'react';\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardHeader,\n  CardTitle,\n} from \"@/components/ui/card\";\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from \"@/components/ui/table\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { getLeads, getRecentActivities, getProducts, getQuotations } from \"@/lib/data\";\nimport {\n  Users,\n  Briefcase,\n  Handshake,\n  User,\n  Package,\n} from \"lucide-react\";\nimport { format, parseISO, differenceInDays, subMonths } from \"date-fns\";\nimport DashboardChart from \"./dashboard-chart\";\nimport { Lead, Activity, Product, LeadStatus } from '@/lib/types';\nimport ProductDemandChart from './product-demand-chart';\nimport AverageConversionTimeChart from './average-conversion-time-chart';\nimport QuotationsByMonthChart from './quotations-by-month-chart';\n\n\n// We can't render the time on the server, as it may be in a different timezone than the client.\n// Instead, we can render it on the client after the initial render.\nfunction ClientTime({ date }: { date: string }) {\n  const [time, setTime] = React.useState<string | null>(null);\n\n  React.useEffect(() => {\n    setTime(format(parseISO(date), \"p\"));\n  }, [date]);\n\n  if (!time) {\n    return null;\n  }\n  return (\n    <Badge variant=\"outline\" className=\"ml-auto shrink-0\">\n      {time}\n    </Badge>\n  );\n}\n\ntype ProductDemandData = {\n    name: string;\n    count: number;\n}\n\ntype QuotationsByMonthData = {\n    month: string;\n    count: number;\n}\n\ntype DashboardData = {\n    leads: Lead[];\n    recentActivities: { lead: Lead; activity: Activity }[];\n    productDemand: ProductDemandData[];\n    averageConversionTime: number;\n    quotationsByMonth: QuotationsByMonthData[];\n};\n\nfunction getConversionDate(lead: Lead): Date | null {\n    if (lead.status !== 'Closed - Won') return null;\n    \n    // Find the activity where status was changed to 'Closed - Won'\n    const statusChangeActivity = lead.activities.find(a => \n      a.notes.includes(\"Status changed from\") && a.notes.includes(`to \"${'Closed - Won'}\"`)\n    );\n\n    if (statusChangeActivity) {\n      return parseISO(statusChangeActivity.date);\n    }\n    \n    // Fallback: use the date of the last activity if no explicit status change is found\n    if (lead.activities.length > 0) {\n        // Activities are sorted by date descending, so the first one is the latest\n        return parseISO(lead.activities[0].date);\n    }\n    \n    return null;\n}\n\nfunction Dashboard({ data }: { data: DashboardData }) {\n    const { leads, recentActivities, productDemand, averageConversionTime, quotationsByMonth } = data;\n    const stats = {\n        total: leads.length,\n        new: leads.filter((l) => l.status === \"New\").length,\n        inDiscussion: leads.filter((l) => l.status === \"In Discussion\").length,\n        negotiation: leads.filter((l) => l.status === \"Negotiation\").length,\n        closedWon: leads.filter((l) => l.status === \"Closed - Won\").length,\n        closedLost: leads.filter((l) => l.status === \"Closed - Lost\").length,\n    };\n    \n    const chartData = [\n        { name: \"New\", value: stats.new },\n        { name: \"Discussion\", value: stats.inDiscussion },\n        { name: \"Negotiation\", value: stats.negotiation },\n        { name: \"Won\", value: stats.closedWon },\n        { name: \"Lost\", value: stats.closedLost },\n    ];\n    \n  return (\n    <>\n      <div className=\"flex items-center justify-between space-y-2\">\n        <h2 className=\"text-3xl font-bold tracking-tight\">Dashboard</h2>\n      </div>\n      <div className=\"grid gap-4 sm:grid-cols-2 lg:grid-cols-3\">\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Total Leads</CardTitle>\n            <Users className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{stats.total}</div>\n            <p className=\"text-xs text-muted-foreground\">\n              All leads in the system\n            </p>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">In Discussion</CardTitle>\n            <Briefcase className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{stats.inDiscussion}</div>\n            <p className=\"text-xs text-muted-foreground\">\n              Leads currently in discussion\n            </p>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">In Negotiation</CardTitle>\n            <Handshake className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{stats.negotiation}</div>\n            <p className=\"text-xs text-muted-foreground\">\n              Leads in negotiation phase\n            </p>\n          </CardContent>\n        </Card>\n      </div>\n\n      <div className=\"grid gap-4 lg:grid-cols-2 xl:grid-cols-7\">\n        <Card className=\"xl:col-span-4\">\n          <CardHeader>\n            <CardTitle>Leads Overview</CardTitle>\n            <CardDescription>A summary of leads by current status.</CardDescription>\n          </CardHeader>\n          <CardContent className=\"pl-2\">\n            <DashboardChart data={chartData} />\n          </CardContent>\n        </Card>\n        <div className=\"xl:col-span-3 grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-1 gap-4\">\n            <Card className=\"sm:col-span-1 xl:col-span-1\">\n                <CardHeader>\n                    <CardTitle>Average Conversion Time</CardTitle>\n                    <CardDescription>\n                    Average time from lead creation to closing a deal.\n                    </CardDescription>\n                </CardHeader>\n                <CardContent className=\"flex items-center justify-center\">\n                   <AverageConversionTimeChart timeInDays={averageConversionTime} />\n                </CardContent>\n            </Card>\n            <Card className=\"sm:col-span-2 xl:col-span-1\">\n            <CardHeader>\n                <CardTitle>Recent Activities</CardTitle>\n                <CardDescription>\n                A log of the most recent interactions with leads.\n                </CardDescription>\n            </CardHeader>\n            <CardContent>\n                <div className=\"space-y-4\">\n                {recentActivities.map(({ lead, activity }) => (\n                    <div key={activity.id} className=\"flex items-start gap-4\">\n                    <div className=\"flex h-9 w-9 items-center justify-center rounded-full bg-muted text-muted-foreground border shrink-0\">\n                        <User className=\"h-5 w-5\" />\n                    </div>\n                    <div className=\"grid gap-1 text-sm\">\n                        <div className=\"font-medium\">\n                        {lead.name}\n                        <span className=\"font-normal text-muted-foreground\"> from {lead.company}</span>\n                        </div>\n                        <p className=\"text-muted-foreground\">{activity.type}</p>\n                        <p className=\"text-xs text-muted-foreground\">\n                        {format(parseISO(activity.date), \"PPP\")}\n                        </p>\n                    </div>\n                    <ClientTime date={activity.date} />\n                    </div>\n                ))}\n                </div>\n            </CardContent>\n            </Card>\n        </div>\n      </div>\n      <div className=\"grid gap-4 md:grid-cols-2\">\n        <Card>\n            <CardHeader>\n              <CardTitle>Quotations Sent by Month</CardTitle>\n              <CardDescription>\n                Number of quotations created over the last 12 months.\n              </CardDescription>\n            </CardHeader>\n            <CardContent>\n              <QuotationsByMonthChart data={quotationsByMonth} />\n            </CardContent>\n          </Card>\n        <Card>\n            <CardHeader>\n              <CardTitle>Product Demand</CardTitle>\n              <CardDescription>\n                Number of leads interested in each product.\n              </CardDescription>\n            </CardHeader>\n            <CardContent>\n              <ProductDemandChart data={productDemand} />\n            </CardContent>\n          </Card>\n      </div>\n    </>\n  );\n}\n\n\nexport default function DashboardPage() {\n    const [data, setData] = React.useState<DashboardData | null>(null);\n\n    React.useEffect(() => {\n      async function fetchData() {\n        const [leads, recentActivities, allProducts, quotations] = await Promise.all([\n          getLeads(),\n          getRecentActivities(5),\n          getProducts(),\n          getQuotations(),\n        ]);\n        \n        let productDemand: ProductDemandData[] = [];\n        if (leads.length > 0 && allProducts.length > 0) {\n            const productCounts = new Map<string, number>();\n            leads.forEach(lead => {\n                if(lead.products) {\n                    lead.products.forEach(p => {\n                        productCounts.set(p.productId, (productCounts.get(p.productId) || 0) + 1);\n                    });\n                }\n            });\n\n            productDemand = Array.from(productCounts.entries()).map(([productId, count]) => {\n                const product = allProducts.find(p => p.id === productId);\n                return {\n                    name: product ? product.name : 'Unknown Product',\n                    count: count\n                };\n            }).sort((a, b) => b.count - a.count);\n        }\n\n        const wonLeads = leads.filter(lead => lead.status === 'Closed - Won');\n        let totalConversionDays = 0;\n        let convertedCount = 0;\n\n        wonLeads.forEach(lead => {\n            const creationDate = parseISO(lead.createdAt);\n            const conversionDate = getConversionDate(lead);\n\n            if(conversionDate) {\n                totalConversionDays += differenceInDays(conversionDate, creationDate);\n                convertedCount++;\n            }\n        });\n        \n        const averageConversionTime = convertedCount > 0 ? Math.round(totalConversionDays / convertedCount) : 0;\n\n        const twelveMonthsAgo = subMonths(new Date(), 11);\n        const monthlyCounts: { [key: string]: number } = {};\n\n        // Initialize last 12 months\n        for (let i = 0; i < 12; i++) {\n            const monthKey = format(subMonths(new Date(), i), 'MMM yyyy');\n            monthlyCounts[monthKey] = 0;\n        }\n\n        quotations.forEach(q => {\n            const qDate = parseISO(q.createdAt);\n            if (qDate >= twelveMonthsAgo) {\n                const monthKey = format(qDate, 'MMM yyyy');\n                if (monthlyCounts.hasOwnProperty(monthKey)) {\n                    monthlyCounts[monthKey]++;\n                }\n            }\n        });\n\n        const quotationsByMonth = Object.entries(monthlyCounts)\n            .map(([month, count]) => ({ month, count }))\n            .sort((a, b) => parseISO(format(new Date(a.month), 'yyyy-MM-dd')).getTime() - parseISO(format(new Date(b.month), 'yyyy-MM-dd')).getTime());\n\n        \n        setData({ leads, recentActivities, productDemand, averageConversionTime, quotationsByMonth });\n      }\n      fetchData();\n    }, []);\n\n    if (!data) {\n        return (\n            <div className=\"flex-1 space-y-4 pt-6\">\n                <div className=\"flex items-center justify-between space-y-2\">\n                    <h2 className=\"text-3xl font-bold tracking-tight\">Dashboard</h2>\n                </div>\n                <div className=\"text-center text-muted-foreground py-10\">\n                    Loading dashboard...\n                </div>\n            </div>\n        );\n    }\n  \n    return <Dashboard data={data} />;\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AAeA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AA/BA;;;;;;;;;;;;AAkCA,gGAAgG;AAChG,oEAAoE;AACpE,SAAS,WAAW,EAAE,IAAI,EAAoB;IAC5C,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAc,AAAD,EAAiB;IAEtD,CAAA,GAAA,qMAAA,CAAA,YAAe,AAAD,EAAE;QACd,QAAQ,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE,OAAO;IACjC,GAAG;QAAC;KAAK;IAET,IAAI,CAAC,MAAM;QACT,OAAO;IACT;IACA,qBACE,8OAAC,iIAAA,CAAA,QAAK;QAAC,SAAQ;QAAU,WAAU;kBAChC;;;;;;AAGP;AAoBA,SAAS,kBAAkB,IAAU;IACjC,IAAI,KAAK,MAAM,KAAK,gBAAgB,OAAO;IAE3C,+DAA+D;IAC/D,MAAM,uBAAuB,KAAK,UAAU,CAAC,IAAI,CAAC,CAAA,IAChD,EAAE,KAAK,CAAC,QAAQ,CAAC,0BAA0B,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;IAGtF,IAAI,sBAAsB;QACxB,OAAO,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE,qBAAqB,IAAI;IAC3C;IAEA,oFAAoF;IACpF,IAAI,KAAK,UAAU,CAAC,MAAM,GAAG,GAAG;QAC5B,2EAA2E;QAC3E,OAAO,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE,KAAK,UAAU,CAAC,EAAE,CAAC,IAAI;IAC3C;IAEA,OAAO;AACX;AAEA,SAAS,UAAU,EAAE,IAAI,EAA2B;IAChD,MAAM,EAAE,KAAK,EAAE,gBAAgB,EAAE,aAAa,EAAE,qBAAqB,EAAE,iBAAiB,EAAE,GAAG;IAC7F,MAAM,QAAQ;QACV,OAAO,MAAM,MAAM;QACnB,KAAK,MAAM,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK,OAAO,MAAM;QACnD,cAAc,MAAM,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK,iBAAiB,MAAM;QACtE,aAAa,MAAM,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK,eAAe,MAAM;QACnE,WAAW,MAAM,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK,gBAAgB,MAAM;QAClE,YAAY,MAAM,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK,iBAAiB,MAAM;IACxE;IAEA,MAAM,YAAY;QACd;YAAE,MAAM;YAAO,OAAO,MAAM,GAAG;QAAC;QAChC;YAAE,MAAM;YAAc,OAAO,MAAM,YAAY;QAAC;QAChD;YAAE,MAAM;YAAe,OAAO,MAAM,WAAW;QAAC;QAChD;YAAE,MAAM;YAAO,OAAO,MAAM,SAAS;QAAC;QACtC;YAAE,MAAM;YAAQ,OAAO,MAAM,UAAU;QAAC;KAC3C;IAEH,qBACE;;0BACE,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC;oBAAG,WAAU;8BAAoC;;;;;;;;;;;0BAEpD,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,gIAAA,CAAA,OAAI;;0CACH,8OAAC,gIAAA,CAAA,aAAU;gCAAC,WAAU;;kDACpB,8OAAC,gIAAA,CAAA,YAAS;wCAAC,WAAU;kDAAsB;;;;;;kDAC3C,8OAAC,oMAAA,CAAA,QAAK;wCAAC,WAAU;;;;;;;;;;;;0CAEnB,8OAAC,gIAAA,CAAA,cAAW;;kDACV,8OAAC;wCAAI,WAAU;kDAAsB,MAAM,KAAK;;;;;;kDAChD,8OAAC;wCAAE,WAAU;kDAAgC;;;;;;;;;;;;;;;;;;kCAKjD,8OAAC,gIAAA,CAAA,OAAI;;0CACH,8OAAC,gIAAA,CAAA,aAAU;gCAAC,WAAU;;kDACpB,8OAAC,gIAAA,CAAA,YAAS;wCAAC,WAAU;kDAAsB;;;;;;kDAC3C,8OAAC,4MAAA,CAAA,YAAS;wCAAC,WAAU;;;;;;;;;;;;0CAEvB,8OAAC,gIAAA,CAAA,cAAW;;kDACV,8OAAC;wCAAI,WAAU;kDAAsB,MAAM,YAAY;;;;;;kDACvD,8OAAC;wCAAE,WAAU;kDAAgC;;;;;;;;;;;;;;;;;;kCAKjD,8OAAC,gIAAA,CAAA,OAAI;;0CACH,8OAAC,gIAAA,CAAA,aAAU;gCAAC,WAAU;;kDACpB,8OAAC,gIAAA,CAAA,YAAS;wCAAC,WAAU;kDAAsB;;;;;;kDAC3C,8OAAC,4MAAA,CAAA,YAAS;wCAAC,WAAU;;;;;;;;;;;;0CAEvB,8OAAC,gIAAA,CAAA,cAAW;;kDACV,8OAAC;wCAAI,WAAU;kDAAsB,MAAM,WAAW;;;;;;kDACtD,8OAAC;wCAAE,WAAU;kDAAgC;;;;;;;;;;;;;;;;;;;;;;;;0BAOnD,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,gIAAA,CAAA,OAAI;wBAAC,WAAU;;0CACd,8OAAC,gIAAA,CAAA,aAAU;;kDACT,8OAAC,gIAAA,CAAA,YAAS;kDAAC;;;;;;kDACX,8OAAC,gIAAA,CAAA,kBAAe;kDAAC;;;;;;;;;;;;0CAEnB,8OAAC,gIAAA,CAAA,cAAW;gCAAC,WAAU;0CACrB,cAAA,8OAAC,iIAAA,CAAA,UAAc;oCAAC,MAAM;;;;;;;;;;;;;;;;;kCAG1B,8OAAC;wBAAI,WAAU;;0CACX,8OAAC,gIAAA,CAAA,OAAI;gCAAC,WAAU;;kDACZ,8OAAC,gIAAA,CAAA,aAAU;;0DACP,8OAAC,gIAAA,CAAA,YAAS;0DAAC;;;;;;0DACX,8OAAC,gIAAA,CAAA,kBAAe;0DAAC;;;;;;;;;;;;kDAIrB,8OAAC,gIAAA,CAAA,cAAW;wCAAC,WAAU;kDACpB,cAAA,8OAAC,qJAAA,CAAA,UAA0B;4CAAC,YAAY;;;;;;;;;;;;;;;;;0CAG/C,8OAAC,gIAAA,CAAA,OAAI;gCAAC,WAAU;;kDAChB,8OAAC,gIAAA,CAAA,aAAU;;0DACP,8OAAC,gIAAA,CAAA,YAAS;0DAAC;;;;;;0DACX,8OAAC,gIAAA,CAAA,kBAAe;0DAAC;;;;;;;;;;;;kDAIrB,8OAAC,gIAAA,CAAA,cAAW;kDACR,cAAA,8OAAC;4CAAI,WAAU;sDACd,iBAAiB,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,iBACrC,8OAAC;oDAAsB,WAAU;;sEACjC,8OAAC;4DAAI,WAAU;sEACX,cAAA,8OAAC,kMAAA,CAAA,OAAI;gEAAC,WAAU;;;;;;;;;;;sEAEpB,8OAAC;4DAAI,WAAU;;8EACX,8OAAC;oEAAI,WAAU;;wEACd,KAAK,IAAI;sFACV,8OAAC;4EAAK,WAAU;;gFAAoC;gFAAO,KAAK,OAAO;;;;;;;;;;;;;8EAEvE,8OAAC;oEAAE,WAAU;8EAAyB,SAAS,IAAI;;;;;;8EACnD,8OAAC;oEAAE,WAAU;8EACZ,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE,SAAS,IAAI,GAAG;;;;;;;;;;;;sEAGrC,8OAAC;4DAAW,MAAM,SAAS,IAAI;;;;;;;mDAdrB,SAAS,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAsBnC,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,gIAAA,CAAA,OAAI;;0CACD,8OAAC,gIAAA,CAAA,aAAU;;kDACT,8OAAC,gIAAA,CAAA,YAAS;kDAAC;;;;;;kDACX,8OAAC,gIAAA,CAAA,kBAAe;kDAAC;;;;;;;;;;;;0CAInB,8OAAC,gIAAA,CAAA,cAAW;0CACV,cAAA,8OAAC,iJAAA,CAAA,UAAsB;oCAAC,MAAM;;;;;;;;;;;;;;;;;kCAGpC,8OAAC,gIAAA,CAAA,OAAI;;0CACD,8OAAC,gIAAA,CAAA,aAAU;;kDACT,8OAAC,gIAAA,CAAA,YAAS;kDAAC;;;;;;kDACX,8OAAC,gIAAA,CAAA,kBAAe;kDAAC;;;;;;;;;;;;0CAInB,8OAAC,gIAAA,CAAA,cAAW;0CACV,cAAA,8OAAC,yIAAA,CAAA,UAAkB;oCAAC,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;AAMxC;AAGe,SAAS;IACpB,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAc,AAAD,EAAwB;IAE7D,CAAA,GAAA,qMAAA,CAAA,YAAe,AAAD,EAAE;QACd,eAAe;YACb,MAAM,CAAC,OAAO,kBAAkB,aAAa,WAAW,GAAG,MAAM,QAAQ,GAAG,CAAC;gBAC3E,CAAA,GAAA,0JAAA,CAAA,WAAQ,AAAD;gBACP,CAAA,GAAA,0JAAA,CAAA,sBAAmB,AAAD,EAAE;gBACpB,CAAA,GAAA,0JAAA,CAAA,cAAW,AAAD;gBACV,CAAA,GAAA,0JAAA,CAAA,gBAAa,AAAD;aACb;YAED,IAAI,gBAAqC,EAAE;YAC3C,IAAI,MAAM,MAAM,GAAG,KAAK,YAAY,MAAM,GAAG,GAAG;gBAC5C,MAAM,gBAAgB,IAAI;gBAC1B,MAAM,OAAO,CAAC,CAAA;oBACV,IAAG,KAAK,QAAQ,EAAE;wBACd,KAAK,QAAQ,CAAC,OAAO,CAAC,CAAA;4BAClB,cAAc,GAAG,CAAC,EAAE,SAAS,EAAE,CAAC,cAAc,GAAG,CAAC,EAAE,SAAS,KAAK,CAAC,IAAI;wBAC3E;oBACJ;gBACJ;gBAEA,gBAAgB,MAAM,IAAI,CAAC,cAAc,OAAO,IAAI,GAAG,CAAC,CAAC,CAAC,WAAW,MAAM;oBACvE,MAAM,UAAU,YAAY,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;oBAC/C,OAAO;wBACH,MAAM,UAAU,QAAQ,IAAI,GAAG;wBAC/B,OAAO;oBACX;gBACJ,GAAG,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,GAAG,EAAE,KAAK;YACvC;YAEA,MAAM,WAAW,MAAM,MAAM,CAAC,CAAA,OAAQ,KAAK,MAAM,KAAK;YACtD,IAAI,sBAAsB;YAC1B,IAAI,iBAAiB;YAErB,SAAS,OAAO,CAAC,CAAA;gBACb,MAAM,eAAe,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE,KAAK,SAAS;gBAC5C,MAAM,iBAAiB,kBAAkB;gBAEzC,IAAG,gBAAgB;oBACf,uBAAuB,CAAA,GAAA,gJAAA,CAAA,mBAAgB,AAAD,EAAE,gBAAgB;oBACxD;gBACJ;YACJ;YAEA,MAAM,wBAAwB,iBAAiB,IAAI,KAAK,KAAK,CAAC,sBAAsB,kBAAkB;YAEtG,MAAM,kBAAkB,CAAA,GAAA,yIAAA,CAAA,YAAS,AAAD,EAAE,IAAI,QAAQ;YAC9C,MAAM,gBAA2C,CAAC;YAElD,4BAA4B;YAC5B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,IAAK;gBACzB,MAAM,WAAW,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,CAAA,GAAA,yIAAA,CAAA,YAAS,AAAD,EAAE,IAAI,QAAQ,IAAI;gBAClD,aAAa,CAAC,SAAS,GAAG;YAC9B;YAEA,WAAW,OAAO,CAAC,CAAA;gBACf,MAAM,QAAQ,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE,EAAE,SAAS;gBAClC,IAAI,SAAS,iBAAiB;oBAC1B,MAAM,WAAW,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,OAAO;oBAC/B,IAAI,cAAc,cAAc,CAAC,WAAW;wBACxC,aAAa,CAAC,SAAS;oBAC3B;gBACJ;YACJ;YAEA,MAAM,oBAAoB,OAAO,OAAO,CAAC,eACpC,GAAG,CAAC,CAAC,CAAC,OAAO,MAAM,GAAK,CAAC;oBAAE;oBAAO;gBAAM,CAAC,GACzC,IAAI,CAAC,CAAC,GAAG,IAAM,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,IAAI,KAAK,EAAE,KAAK,GAAG,eAAe,OAAO,KAAK,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,IAAI,KAAK,EAAE,KAAK,GAAG,eAAe,OAAO;YAG3I,QAAQ;gBAAE;gBAAO;gBAAkB;gBAAe;gBAAuB;YAAkB;QAC7F;QACA;IACF,GAAG,EAAE;IAEL,IAAI,CAAC,MAAM;QACP,qBACI,8OAAC;YAAI,WAAU;;8BACX,8OAAC;oBAAI,WAAU;8BACX,cAAA,8OAAC;wBAAG,WAAU;kCAAoC;;;;;;;;;;;8BAEtD,8OAAC;oBAAI,WAAU;8BAA0C;;;;;;;;;;;;IAKrE;IAEA,qBAAO,8OAAC;QAAU,MAAM;;;;;;AAC5B","debugId":null}}]
}