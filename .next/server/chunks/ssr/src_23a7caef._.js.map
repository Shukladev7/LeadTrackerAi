{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n"],"names":[],"mappings":";;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAC3B,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAO,EAAE;IAC9B,qBACE,8OAAC;QACC,MAAM;QACN,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,kYACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;AAEF,MAAM,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,gBAAgB,CAAA,GAAA,gKAAA,CAAA,MAAG,AAAD,EACtB;AAGF,MAAM,sBAAQ,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAI3B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,iKAAA,CAAA,OAAmB;QAClB,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iBAAiB;QAC9B,GAAG,KAAK;;;;;;AAGb,MAAM,WAAW,GAAG,iKAAA,CAAA,OAAmB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/textarea.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport {cn} from '@/lib/utils';\n\nconst Textarea = React.forwardRef<HTMLTextAreaElement, React.ComponentProps<'textarea'>>(\n  ({className, ...props}, ref) => {\n    return (\n      <textarea\n        className={cn(\n          'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    );\n  }\n);\nTextarea.displayName = 'Textarea';\n\nexport {Textarea};\n"],"names":[],"mappings":";;;;AAAA;AAEA;;;;AAEA,MAAM,yBAAW,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAC9B,CAAC,EAAC,SAAS,EAAE,GAAG,OAAM,EAAE;IACtB,qBACE,8OAAC;QACC,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,qTACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;AAEF,SAAS,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { getAuth } from 'firebase-admin/auth';\nimport { initializeApp, getApps, cert } from 'firebase-admin/app';\nimport { summarizeMeetingNotes } from '@/ai/flows/summarize-meeting-notes';\nimport { addLead as dbAddLead, addActivityToLead, updateLeadStatus as updateStatus, addProduct as dbAddProduct, addLeadSource as dbAddLeadSource, deleteLeadSource as dbDeleteLeadSource, addProductCategory as dbAddProductCategory, deleteProductCategory as dbDeleteProductCategory, getProductCategories, updateLead as dbUpdateLead, getLeadById as dbGetLeadById, deleteLead as dbDeleteLead, addQuotation as dbAddQuotation, updateQuotation as dbUpdateQuotation, deleteQuotation as dbDeleteQuotation, addQuotationTemplate as dbAddQuotationTemplate, updateProduct as dbUpdateProduct, deleteProduct as dbDeleteProduct, addEmployee as dbAddEmployee, deleteEmployee as dbDeleteEmployee, updateEmployee as dbUpdateEmployee, getEmployeeByEmail, getEmployeeRoles, addEmployeeRole as dbAddEmployeeRole, deleteEmployeeRole as dbDeleteEmployeeRole, getDepartments, addDepartment as dbAddDepartment, deleteDepartment as dbDeleteDepartment, updateQuotationTemplate as dbUpdateQuotationTemplate, deleteQuotationTemplate as dbDeleteQuotationTemplate, getLeadsCount, getQuotationsCount, getProductsCount, getEmployeesCount, getLeadsCountByStatus, getQuotationsCountByStatus, getActiveProductsCount, getActiveEmployeesCount, updateProductCategory as dbUpdateProductCategory } from './data';\nimport { deletePDFFromStorage, deleteImageFromStorage, uploadImageToStorage } from './storage-utils';\nimport type { Lead, LeadStatus, LeadProduct, UpdatableLeadData, Product, NewQuotationTemplate, Quotation, NewEmployee, QuotationTemplate } from './types';\nimport type { Employee } from './business-types';\nimport { getProducts } from './data';\n\n// Initialize Firebase Admin SDK\nfunction initializeFirebaseAdmin() {\n  if (getApps().length === 0) {\n    // Check if all required environment variables are present\n    const requiredEnvVars = [\n      'FIREBASE_PROJECT_ID',\n      'FIREBASE_PRIVATE_KEY',\n      'FIREBASE_CLIENT_EMAIL'\n    ];\n    \n    const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n    \n    if (missingVars.length > 0) {\n      throw new Error(`Missing required Firebase environment variables: ${missingVars.join(', ')}`);\n    }\n\n    const serviceAccount = {\n      type: \"service_account\",\n      project_id: process.env.FIREBASE_PROJECT_ID!,\n      private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,\n      private_key: process.env.FIREBASE_PRIVATE_KEY!.replace(/\\\\n/g, '\\n'),\n      client_email: process.env.FIREBASE_CLIENT_EMAIL!,\n      client_id: process.env.FIREBASE_CLIENT_ID,\n      auth_uri: \"https://accounts.google.com/o/oauth2/auth\",\n      token_uri: \"https://oauth2.googleapis.com/token\",\n      auth_provider_x509_cert_url: \"https://www.googleapis.com/oauth2/v1/certs\",\n      client_x509_cert_url: `https://www.googleapis.com/robot/v1/metadata/x509/${process.env.FIREBASE_CLIENT_EMAIL}`\n    };\n\n    initializeApp({\n      credential: cert(serviceAccount as any),\n      projectId: process.env.FIREBASE_PROJECT_ID,\n    });\n  }\n}\n\nconst LeadProductSchema = z.object({\n    productId: z.string().min(1, 'Product must be selected'),\n    quantity: z.coerce.number().min(1),\n    rate: z.coerce.number().min(0),\n    selectedSku: z.string().optional(),\n});\n\nconst CreateLeadSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  company: z.string().min(2, 'Company must be at least 2 characters'),\n  email: z.string().email('Invalid email address'),\n  phone: z.string().min(10, 'Phone number seems too short'),\n  whatsappNumber: z.string().optional().or(z.literal('')),\n  client_address: z.string().optional().or(z.literal('')),\n  client_gst_no: z.string().optional().or(z.literal('')),\n  status: z.enum(['New', 'In Discussion', 'Negotiation', 'Closed - Won', 'Closed - Lost']),\n  source: z.string().min(1, 'Please select a lead source'),\n  notes: z.string().optional(),\n  products: z.array(LeadProductSchema).optional(),\n  createdBy: z.string().min(1, 'Created by field is required'),\n});\n\nexport async function createLead(formData: FormData) {\n  const productsJSON = formData.get('products');\n  const products = productsJSON ? JSON.parse(productsJSON as string) : [];\n\n  const validatedFields = CreateLeadSchema.safeParse({\n    name: formData.get('name'),\n    company: formData.get('company'),\n    email: formData.get('email'),\n    phone: formData.get('phone'),\n    whatsappNumber: formData.get('whatsappNumber'),\n    client_address: formData.get('client_address'),\n    client_gst_no: formData.get('client_gst_no'),\n    status: formData.get('status'),\n    source: formData.get('source'),\n    notes: formData.get('notes'),\n    products: products,\n    createdBy: formData.get('createdBy'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Failed to create lead.',\n    };\n  }\n  \n  let newLeadId: string | undefined;\n  try {\n    const leadData = {\n      ...validatedFields.data,\n      products: validatedFields.data.products || []\n    };\n    const newLead = await dbAddLead(leadData);\n    newLeadId = newLead.id;\n  } catch (error) {\n    return { message: 'Database Error: Failed to Create Lead.' };\n  }\n\n  revalidatePath('/leads');\n  revalidatePath('/');\n  if (newLeadId) {\n    revalidatePath(`/leads/${newLeadId}`);\n  }\n  return { message: 'Successfully created lead.' };\n}\n\nconst UpdateLeadSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  company: z.string().min(2, 'Company must be at least 2 characters'),\n  email: z.string().email('Invalid email address'),\n  phone: z.string().min(10, 'Phone number seems too short'),\n  whatsappNumber: z.string().optional().or(z.literal('')),\n  client_address: z.string().optional().or(z.literal('')),\n  client_gst_no: z.string().optional().or(z.literal('')),\n  status: z.enum(['New', 'In Discussion', 'Negotiation', 'Closed - Won', 'Closed - Lost']),\n  source: z.string().min(1, 'Please select a lead source'),\n  products: z.array(LeadProductSchema).optional(),\n});\n\nfunction generateChangeNotes(oldLead: Lead, newLeadData: UpdatableLeadData, allProducts: Product[]): string {\n    const changes: string[] = [];\n\n    if (oldLead.name !== newLeadData.name) {\n        changes.push(`Name changed from \"${oldLead.name}\" to \"${newLeadData.name}\".`);\n    }\n    if (oldLead.company !== newLeadData.company) {\n        changes.push(`Company changed from \"${oldLead.company}\" to \"${newLeadData.company}\".`);\n    }\n    if (oldLead.email !== newLeadData.email) {\n        changes.push(`Email changed from \"${oldLead.email}\" to \"${newLeadData.email}\".`);\n    }\n    if (oldLead.phone !== newLeadData.phone) {\n        changes.push(`Phone changed from \"${oldLead.phone}\" to \"${newLeadData.phone}\".`);\n    }\n    if (oldLead.whatsappNumber !== newLeadData.whatsappNumber) {\n        changes.push(`WhatsApp Number changed from \"${oldLead.whatsappNumber || 'N/A'}\" to \"${newLeadData.whatsappNumber || 'N/A'}\".`);\n    }\n    if (oldLead.client_address !== newLeadData.client_address) {\n        changes.push(`Client Address changed from \"${oldLead.client_address || 'N/A'}\" to \"${newLeadData.client_address || 'N/A'}\".`);\n    }\n    if (oldLead.client_gst_no !== newLeadData.client_gst_no) {\n        changes.push(`Client GST Number changed from \"${oldLead.client_gst_no || 'N/A'}\" to \"${newLeadData.client_gst_no || 'N/A'}\".`);\n    }\n    if (oldLead.status !== newLeadData.status) {\n        changes.push(`Status changed from \"${oldLead.status}\" to \"${newLeadData.status}\".`);\n    }\n    if (oldLead.source !== newLeadData.source) {\n        changes.push(`Source changed from \"${oldLead.source}\" to \"${newLeadData.source}\".`);\n    }\n\n    const oldProducts = oldLead.products || [];\n    const newProducts = newLeadData.products || [];\n    if (JSON.stringify(oldProducts) !== JSON.stringify(newProducts)) {\n        const getProductName = (productId: string) => allProducts.find(p => p.id === productId)?.name || productId;\n        \n        const formatProduct = (p: LeadProduct) => `${getProductName(p.productId)} (Qty: ${p.quantity}, Rate: ${p.rate}, SKU: ${p.selectedSku || 'N/A'})`;\n\n        const oldProductStr = oldProducts.map(formatProduct).join(', ') || 'None';\n        const newProductStr = newProducts.map(formatProduct).join(', ') || 'None';\n\n        changes.push(`Interested products updated.\\n- Old: ${oldProductStr}\\n- New: ${newProductStr}`);\n    }\n\n    if (changes.length === 0) {\n        return 'No changes were made to the lead details.';\n    }\n\n    return 'Lead details were updated:\\n' + changes.map(c => `- ${c}`).join('\\n');\n}\n\nexport async function updateLead(leadId: string, formData: FormData) {\n    const [oldLead, allProducts] = await Promise.all([\n        dbGetLeadById(leadId),\n        getProducts()\n    ]);\n\n    if (!oldLead) {\n        return { message: 'Error: Lead not found.' };\n    }\n\n    const productsJSON = formData.get('products');\n    const products = productsJSON ? JSON.parse(productsJSON as string) : [];\n  \n    const validatedFields = UpdateLeadSchema.safeParse({\n      name: formData.get('name'),\n      company: formData.get('company'),\n      email: formData.get('email'),\n      phone: formData.get('phone'),\n      whatsappNumber: formData.get('whatsappNumber'),\n      client_address: formData.get('client_address'),\n      client_gst_no: formData.get('client_gst_no'),\n      status: formData.get('status'),\n      source: formData.get('source'),\n      products: products,\n    });\n  \n    if (!validatedFields.success) {\n      return {\n        errors: validatedFields.error.flatten().fieldErrors,\n        message: 'Failed to update lead.',\n      };\n    }\n\n    const newLeadData = validatedFields.data as UpdatableLeadData;\n    const changeNotes = generateChangeNotes(oldLead, newLeadData, allProducts);\n  \n    try {\n        await dbUpdateLead(leadId, newLeadData);\n        if (changeNotes !== 'No changes were made to the lead details.') {\n            await addActivityToLead(leadId, {\n                type: 'Revision Request',\n                notes: changeNotes\n            });\n        }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'An unknown error occurred';\n      return { message: `Database Error: Failed to Update Lead. ${message}` };\n    }\n  \n    revalidatePath('/leads');\n    revalidatePath('/');\n    revalidatePath(`/leads/${leadId}`);\n    return { message: 'Successfully updated lead.' };\n}\n\nconst ProductSchema = z.object({\n    name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n    price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n    gstRate: z.coerce.number().min(0).max(100),\n    categoryId: z.string().optional(),\n    description: z.string().optional(),\n    skus: z.array(z.string()).optional(),\n    catalogueUrl: z.string().url('Please enter a valid URL.').optional().or(z.literal('')),\n    cataloguePdf: z.object({\n        url: z.string(),\n        fileName: z.string(),\n        filePath: z.string(),\n        uploadedAt: z.string(),\n    }).optional(),\n    productImage: z.object({\n        url: z.string(),\n        fileName: z.string(),\n        filePath: z.string(),\n        uploadedAt: z.string(),\n    }).optional(),\n});\n\nexport async function addProduct(formData: FormData) {\n  const skusJSON = formData.get('skus');\n  const skus = skusJSON ? JSON.parse(skusJSON as string) : [];\n  \n  const catalogPdfJSON = formData.get('catalogPdf');\n  const catalogPdf = catalogPdfJSON ? JSON.parse(catalogPdfJSON as string) : undefined;\n  \n  const productImageJSON = formData.get('productImage');\n  console.log('Product Image JSON received:', productImageJSON);\n  const productImage = productImageJSON ? JSON.parse(productImageJSON as string) : undefined;\n  console.log('Product Image parsed:', productImage);\n  \n  const validatedFields = ProductSchema.safeParse({\n    name: formData.get('name'),\n    price: formData.get('price'),\n    gstRate: formData.get('gstRate'),\n    categoryId: formData.get('categoryId'),\n    description: formData.get('description') || undefined,\n    skus: skus,\n    catalogueUrl: formData.get('catalogueUrl') || '',\n    cataloguePdf: catalogPdf,\n    productImage: productImage,\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Failed to add product.',\n    };\n  }\n\n  try {\n    const data = validatedFields.data;\n    // Remove undefined values before sending to Firestore\n    const cleanData = Object.fromEntries(\n      Object.entries(data).filter(([_, v]) => v !== undefined)\n    );\n    \n    console.log('Clean data being sent to database:', JSON.stringify(cleanData, null, 2));\n    \n    // Create the product\n    const newProduct = await dbAddProduct(cleanData as any);\n    \n  } catch (error) {\n    return { message: 'Database Error: Failed to add product.' };\n  }\n\n  revalidatePath('/products');\n  revalidatePath('/leads'); // Revalidate leads in case product info is needed\n  return { message: 'Successfully added product.' };\n}\n\nexport async function updateProduct(id: string, formData: FormData) {\n    const skusJSON = formData.get('skus');\n    const skus = skusJSON ? JSON.parse(skusJSON as string) : [];\n\n    const catalogPdfJSON = formData.get('catalogPdf');\n    const catalogPdf = catalogPdfJSON ? JSON.parse(catalogPdfJSON as string) : undefined;\n    const removeCatalogPdf = String(formData.get('removeCatalogPdf') || '').toLowerCase() === 'true';\n\n    // Handle product image - can be File object (new upload) or JSON string (existing metadata)\n    const productImageData = formData.get('productImage');\n    const existingProductImageJSON = formData.get('existingProductImage');\n    const removeProductImage = String(formData.get('removeProductImage') || '').toLowerCase() === 'true';\n    \n    let productImage: any = undefined;\n    \n    // If there's a new file upload, handle it\n    if (productImageData instanceof File) {\n      try {\n        const uploadResult = await uploadImageToStorage(productImageData, 'products');\n        productImage = {\n          url: uploadResult.url,\n          fileName: uploadResult.fileName,\n          filePath: uploadResult.path,\n          uploadedAt: new Date().toISOString(),\n        };\n      } catch (error) {\n        console.error('Failed to upload product image:', error);\n        return { message: 'Failed to upload product image.' };\n      }\n    } else if (existingProductImageJSON && !removeProductImage) {\n      // Keep existing image metadata\n      productImage = JSON.parse(existingProductImageJSON as string);\n    }\n\n    // Debug logs removed\n    \n    const validatedFields = ProductSchema.safeParse({\n      name: formData.get('name'),\n      price: formData.get('price'),\n      gstRate: formData.get('gstRate'),\n      categoryId: formData.get('categoryId'),\n      description: formData.get('description') || undefined,\n      skus: skus,\n      catalogueUrl: formData.get('catalogueUrl') || '',\n      cataloguePdf: catalogPdf,\n      productImage: productImage,\n    });\n\n    if (!validatedFields.success) {\n      return {\n        errors: validatedFields.error.flatten().fieldErrors,\n        message: 'Failed to update product.',\n      };\n    }\n\n    try {\n      // Get the current product to check for existing PDF\n      const currentProduct = await getProducts().then(products => \n        products.find(p => p.id === id)\n      );\n      \n      const data = validatedFields.data as any;\n      const updateData: any = { ...data };\n      \n      // If user explicitly removed the existing PDF and didn't upload a new one, clear the field\n      if (removeCatalogPdf && !catalogPdf) {\n        // Delete the old PDF from Firebase Storage if it exists\n        if (currentProduct?.cataloguePdf?.filePath) {\n          try {\n            await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n          } catch (error) {\n            console.error('Failed to delete PDF from storage:', error);\n            // Continue with the update even if PDF deletion fails\n          }\n        }\n        updateData.cataloguePdf = null; // This will clear the field in Firestore\n      } else if (catalogPdf && currentProduct?.cataloguePdf?.filePath && \n                 currentProduct.cataloguePdf.filePath !== catalogPdf.filePath) {\n        // If a new PDF was uploaded, delete the old one from storage\n        try {\n          await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n        } catch (error) {\n          console.error('Failed to delete old PDF from storage:', error);\n          // Continue with the update even if old PDF deletion fails\n        }\n      }\n      \n      // Handle product image storage cleanup if new image was uploaded\n      if (productImageData instanceof File && currentProduct?.productImage?.filePath) {\n        // Delete the old image from storage since we have a new one\n        try {\n          await deleteImageFromStorage(currentProduct.productImage.filePath);\n        } catch (error) {\n          console.error('Failed to delete old product image from storage:', error);\n          // Continue with the update even if old image deletion fails\n        }\n      }\n      \n      // Handle product image removal\n      if (removeProductImage && !productImageData) {\n        // Delete the existing image from storage\n        if (currentProduct?.productImage?.filePath) {\n          try {\n            await deleteImageFromStorage(currentProduct.productImage.filePath);\n          } catch (error) {\n            console.error('Failed to delete product image from storage:', error);\n          }\n        }\n        updateData.productImage = null; // This will clear the field in Firestore\n      }\n      \n      // Ensure new uploads are persisted\n      if (catalogPdf) {\n        updateData.cataloguePdf = catalogPdf;\n      }\n      if (productImage) {\n        updateData.productImage = productImage;\n      }\n      \n      // Remove undefined values from updateData as Firestore doesn't accept them\n      const cleanedUpdateData: any = {};\n      for (const [key, value] of Object.entries(updateData)) {\n        if (value !== undefined) {\n          cleanedUpdateData[key] = value;\n        }\n      }\n      \n      console.log('[updateProduct] cleanedUpdateData keys:', Object.keys(cleanedUpdateData));\n      console.log('[updateProduct] cleanedUpdateData.productImage:', cleanedUpdateData.productImage);\n      \n      await dbUpdateProduct(id, cleanedUpdateData);\n    } catch (error) {\n      return { message: 'Database Error: Failed to update product.' };\n    }\n\n    revalidatePath('/products');\n    revalidatePath('/leads');\n    return { message: 'Successfully updated product.' };\n  }\n  \n  export async function deleteProduct(id: string) {\n    try {\n      // Get the current product to check for PDF before deletion\n      const currentProduct = await getProducts().then(products => \n        products.find(p => p.id === id)\n      );\n      \n      // Delete the PDF from Firebase Storage if it exists\n      if (currentProduct?.cataloguePdf?.filePath) {\n        try {\n          await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n        } catch (error) {\n          console.error('Failed to delete PDF from storage:', error);\n          // Continue with product deletion even if PDF deletion fails\n        }\n      }\n      \n      await dbDeleteProduct(id);\n    } catch (error) {\n      return { message: 'Database Error: Failed to delete product.' };\n    }\n\n    revalidatePath('/products');\n    revalidatePath('/leads');\n    return { message: 'Successfully deleted product.' };\n  }\n\n\nconst LogActivitySchema = z.object({\n    leadId: z.string(),\n    type: z.enum(['Meeting', 'Call', 'Email', 'Revision Request', 'Proposal Sent']),\n    notes: z.string().optional(),\n    summary: z.string().optional(),\n});\n\nexport async function logActivity(formData: FormData) {\n    const validatedFields = LogActivitySchema.safeParse({\n        leadId: formData.get('leadId'),\n        type: formData.get('type'),\n        notes: formData.get('notes'),\n        summary: formData.get('summary') || undefined,\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to log activity.',\n        };\n    }\n\n    try {\n        const { leadId, ...activityData } = validatedFields.data;\n        await addActivityToLead(leadId, activityData);\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        console.error('LogActivity Error:', message);\n        if (message.includes('Lead not found')) {\n            return { message: 'Lead not found. Please refresh the page and try again.' };\n        }\n        return { message: 'Database Error: Failed to log activity.' };\n    }\n\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    revalidatePath('/');\n    return { message: 'Successfully logged activity.' };\n}\n\nexport async function getSummaryForNotes(notes: string): Promise<{ summary?: string; error?: string }> {\n  if (!notes || notes.trim().length < 50) {\n    return { error: 'Please provide at least 50 characters of notes to summarize.' };\n  }\n  try {\n    const result = await summarizeMeetingNotes({ notes });\n    return result;\n  } catch (e) {\n    console.error('AI Summarization Error:', e);\n    return { error: 'Failed to generate summary due to an internal error.' };\n  }\n}\n\n\nexport async function updateLeadStatusAction(leadId: string, status: LeadStatus, userId?: string, userName?: string) {\n  try {\n    // Get the current lead to capture the previous status\n    const currentLead = await dbGetLeadById(leadId);\n    if (!currentLead) {\n      return { message: 'Lead not found.' };\n    }\n    \n    const previousStatus = currentLead.status;\n    \n    // Only update if status is actually changing\n    if (previousStatus === status) {\n      return { message: 'Status is already set to this value.' };\n    }\n    \n    // Update the status\n    await updateStatus(leadId, status);\n    \n    // Add a status change activity\n    const changedBy = userName || userId || 'Unknown User';\n    const statusChangeNotes = `Status changed from \"${previousStatus}\" to \"${status}\" by ${changedBy}`;\n    \n    await addActivityToLead(leadId, {\n      type: 'Status Change',\n      notes: statusChangeNotes\n    });\n    \n  } catch (error) {\n    return { message: 'Database Error: Failed to update status.' };\n  }\n  revalidatePath(`/leads/${leadId}`);\n  revalidatePath('/leads');\n  revalidatePath('/');\n  return { message: 'Status updated successfully.' };\n}\n\nexport async function deleteLeadAction(leadId: string) {\n  try {\n    await dbDeleteLead(leadId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete lead.' };\n  }\n  revalidatePath('/leads');\n  revalidatePath('/');\n  return { message: 'Successfully deleted lead.' };\n}\n\nconst AddLeadSourceSchema = z.object({\n    name: z.string().min(2, 'Source name must be at least 2 characters'),\n});\n\nexport async function addLeadSourceAction(formData: FormData) {\n    const validatedFields = AddLeadSourceSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddLeadSource(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add lead source.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/leads');\n    return { message: `Successfully added '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteLeadSourceAction(id: string) {\n    try {\n        await dbDeleteLeadSource(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete lead source.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/leads');\n    return { message: 'Successfully deleted lead source.' };\n}\n\nconst AddProductCategorySchema = z.object({\n    name: z.string().min(2, 'Category name must be at least 2 characters'),\n    description: z.string().optional().nullable(),\n});\n\nexport async function addProductCategoryAction(formData: FormData) {\n    const validatedFields = AddProductCategorySchema.safeParse({\n        name: formData.get('name'),\n        description: formData.get('description'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        // Convert null to undefined for optional description\n        const description = validatedFields.data.description || '';\n        await dbAddProductCategory(validatedFields.data.name, description);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add product category.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: `Successfully added '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteProductCategoryAction(id: string) {\n    try {\n        await dbDeleteProductCategory(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete product category.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: 'Successfully deleted product category.' };\n}\n\n// Update an existing product category's name/description\nexport async function updateProductCategoryAction(id: string, name: string, description?: string) {\n    try {\n        await dbUpdateProductCategory(id, name, description || '');\n    } catch (error) {\n        const message = error instanceof Error ? error.message : 'Unknown error';\n        return { message: `Database Error: Failed to update product category. ${message}` };\n    }\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: 'Successfully updated product category.' };\n}\n\nexport async function getProductCategoriesAction() {\n    try {\n        const categories = await getProductCategories();\n        return categories;\n    } catch (error) {\n        console.error('Error fetching product categories:', error);\n        return [];\n    }\n}\n\n\nconst CreateQuotationSchema = z.object({\n  leadId: z.string().min(1),\n  templateId: z.string().min(1),\n  date: z.string(),\n  validUntil: z.string(),\n  status: z.enum(['Draft', 'Sent', 'Accepted', 'Rejected']),\n  products: z.string(), // JSON string\n  subTotal: z.coerce.number(),\n  totalGst: z.coerce.number(),\n  grandTotal: z.coerce.number(),\n  quotationPrefix: z.string().optional(),\n  // Overridable template fields\n  companyName: z.string().min(1),\n  companyAddress: z.string().min(1),\n  companyGst: z.string().optional().or(z.literal('')).nullable(),\n  // Client billing fields\n  client_address: z.string().optional().or(z.literal('')).nullable(),\n  client_gst_no: z.string().optional().or(z.literal('')).nullable(),\n  termsAndConditions: z.string(),\n  logoUrl: z.string().optional().nullable(),\n  // Additional charges (numeric or empty/null)\n  freightCharges: z.coerce.number().min(0).optional().or(z.literal('')).nullable(),\n  courierCharges: z.coerce.number().min(0).optional().or(z.literal('')).nullable(),\n  // Flags to show/hide charges in PDF\n  showFreight: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return false; // default to false\n  }, z.boolean()).optional(),\n  showCourier: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return false; // default to false\n  }, z.boolean()).optional(),\n  // GST visibility control\n  showGst: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return true; // default to true for backward compatibility\n  }, z.boolean()).optional(),\n  // Currency fields\n  currencyCode: z.string().optional(),\n  currencySymbol: z.string().optional(),\n  conversionRate: z.coerce.number().optional(),\n});\n\n\nexport async function addQuotation(formData: FormData) {\n    console.log('Server received quotationPrefix:', formData.get('quotationPrefix'));\n    const validatedFields = CreateQuotationSchema.safeParse({\n        leadId: formData.get('leadId'),\n        templateId: formData.get('templateId'),\n        date: formData.get('date'),\n        validUntil: formData.get('validUntil'),\n        status: formData.get('status'),\n        products: formData.get('products'),\n        subTotal: formData.get('subTotal'),\n        totalGst: formData.get('totalGst'),\n        grandTotal: formData.get('grandTotal'),\n        quotationPrefix: formData.get('quotationPrefix') || '',\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        client_address: formData.get('client_address'),\n        client_gst_no: formData.get('client_gst_no'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n        freightCharges: formData.get('freightCharges'),\n        courierCharges: formData.get('courierCharges'),\n        showFreight: formData.get('showFreight'),\n        showCourier: formData.get('showCourier'),\n        showGst: formData.get('showGst'),\n        currencyCode: formData.get('currencyCode'),\n        currencySymbol: formData.get('currencySymbol'),\n        conversionRate: formData.get('conversionRate'),\n      });\n    \n      if (!validatedFields.success) {\n        console.error(validatedFields.error.flatten().fieldErrors);\n        return {\n          errors: validatedFields.error.flatten().fieldErrors,\n          message: 'Validation Error: Failed to create quotation.',\n        };\n      }\n      \n      let newQuotation: Quotation | undefined;\n      try {\n        const data = validatedFields.data;\n        const parsedProducts = JSON.parse(data.products);\n        const prefix = (data.quotationPrefix?.trim() || 'QUO');\n        console.log('Using prefix:', prefix);\n        const { quotationPrefix: _omitPrefix, logoUrl, ...rest } = data as any;\n        \n        // Clean up null values - convert to undefined for Firestore\n        const payload: any = {\n          ...rest,\n          products: parsedProducts,\n          companyGst: rest.companyGst || undefined,\n          client_address: rest.client_address || undefined,\n          client_gst_no: rest.client_gst_no || undefined,\n          freightCharges: rest.freightCharges || undefined,\n          courierCharges: rest.courierCharges || undefined,\n          showFreight: rest.showFreight === true || rest.showFreight === 'true',\n          showCourier: rest.showCourier === true || rest.showCourier === 'true',\n        };\n        if (logoUrl) payload.logoUrl = logoUrl;\n        newQuotation = await dbAddQuotation(payload, prefix);\n\n        // Log activity on the lead\n        await addActivityToLead(data.leadId, {\n            type: 'Proposal Sent',\n            notes: `Quotation ${newQuotation.quotationNumber} was created and sent.`\n        });\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return { message: `Database Error: Failed to Create Quotation. ${message}` };\n      }\n\n    revalidatePath('/quotations');\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    return { message: 'Successfully created quotation.' };\n}\n\nexport async function updateQuotation(id: string, formData: FormData) {\n    const validatedFields = CreateQuotationSchema.safeParse({\n        leadId: formData.get('leadId'),\n        templateId: formData.get('templateId'),\n        date: formData.get('date'),\n        validUntil: formData.get('validUntil'),\n        status: formData.get('status'),\n        products: formData.get('products'),\n        subTotal: formData.get('subTotal'),\n        totalGst: formData.get('totalGst'),\n        grandTotal: formData.get('grandTotal'),\n        quotationPrefix: formData.get('quotationPrefix') || '',\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        client_address: formData.get('client_address'),\n        client_gst_no: formData.get('client_gst_no'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n        freightCharges: formData.get('freightCharges'),\n        courierCharges: formData.get('courierCharges'),\n        showFreight: formData.get('showFreight'),\n        showCourier: formData.get('showCourier'),\n        showGst: formData.get('showGst'),\n        currencyCode: formData.get('currencyCode'),\n        currencySymbol: formData.get('currencySymbol'),\n        conversionRate: formData.get('conversionRate'),\n      });\n    \n      if (!validatedFields.success) {\n        console.error(validatedFields.error.flatten().fieldErrors);\n        return {\n          errors: validatedFields.error.flatten().fieldErrors,\n          message: 'Validation Error: Failed to update quotation.',\n        };\n      }\n      \n      try {\n        const data = validatedFields.data;\n        const parsedProducts = JSON.parse(data.products);\n        \n        // Clean up null values - convert to undefined for Firestore\n        await dbUpdateQuotation(id, {\n            ...data,\n            logoUrl: data.logoUrl || undefined,\n            companyGst: data.companyGst || undefined,\n            client_address: data.client_address || undefined,\n            client_gst_no: data.client_gst_no || undefined,\n            freightCharges: data.freightCharges || undefined,\n            courierCharges: data.courierCharges || undefined,\n            showFreight: data.showFreight === true || data.showFreight === 'true',\n            showCourier: data.showCourier === true || data.showCourier === 'true',\n            products: parsedProducts,\n        });\n\n        // Log activity on the lead\n        await addActivityToLead(data.leadId, {\n            type: 'Revision Request',\n            notes: `Quotation was updated.`\n        });\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return { message: `Database Error: Failed to Update Quotation. ${message}` };\n      }\n\n    revalidatePath('/quotations');\n    revalidatePath(`/quotations/${id}`);\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    return { message: 'Successfully updated quotation.' };\n}\n\nexport async function deleteQuotationAction(quotationId: string) {\n  try {\n    await dbDeleteQuotation(quotationId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete quotation.' };\n  }\n  revalidatePath('/quotations');\n  revalidatePath('/');\n  return { message: 'Successfully deleted quotation.' };\n}\n\n\nconst QuotationTemplateSchema = z.object({\n    name: z.string().min(3, 'Template name must be at least 3 characters.'),\n    prefix: z.string().min(1, 'Prefix is required.'),\n    companyName: z.string().min(3, 'Company name is required.'),\n    companyAddress: z.string().min(10, 'Full company address is required.'),\n    companyGst: z.string().min(15, 'A valid GSTIN is required.').max(15),\n    termsAndConditions: z.string().min(20, 'Terms and conditions are required.'),\n    logoUrl: z.string().url('Please enter a valid URL for the logo.').optional().or(z.literal('')),\n});\n\nexport async function addQuotationTemplateAction(formData: FormData) {\n    const validatedFields = QuotationTemplateSchema.safeParse({\n        name: formData.get('name'),\n        prefix: formData.get('prefix'),\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to create template. Please check the fields.',\n        };\n    }\n\n    try {\n        await dbAddQuotationTemplate(validatedFields.data as NewQuotationTemplate);\n    } catch (error) {\n        return { message: 'Database Error: Failed to create template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully created quotation template.' };\n}\n\nexport async function updateQuotationTemplateAction(id: string, formData: FormData) {\n    const validatedFields = QuotationTemplateSchema.safeParse({\n        name: formData.get('name'),\n        prefix: formData.get('prefix'),\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to update template. Please check the fields.',\n        };\n    }\n\n    try {\n        await dbUpdateQuotationTemplate(id, validatedFields.data as QuotationTemplate);\n    } catch (error) {\n        return { message: 'Database Error: Failed to update template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully updated quotation template.' };\n}\n\nexport async function deleteQuotationTemplateAction(id: string) {\n    try {\n        await dbDeleteQuotationTemplate(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully deleted quotation template.' };\n}\n\n\nconst AddEmployeeSchema = z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters.'),\n    email: z.string().email('Please enter a valid email.'),\n    phone: z.string().min(10, 'Please enter a valid phone number.'),\n    role: z.string({\n      required_error: \"You need to select a role.\",\n    }),\n    department: z.string({\n        required_error: \"You need to select a department.\",\n    }),\n    address: z.string().min(10, 'Address is required.'),\n});\n\nexport async function addEmployeeAction(formData: FormData) {\n    const validatedFields = AddEmployeeSchema.safeParse({\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        role: formData.get('role'),\n        department: formData.get('department'),\n        address: formData.get('address'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to add employee.',\n        };\n    }\n\n    const [employeeRoles, departments] = await Promise.all([\n        getEmployeeRoles(),\n        getDepartments(),\n    ]);\n\n    const roleExists = employeeRoles.some(r => r.name === validatedFields.data.role);\n    if (!roleExists) {\n        return { message: 'Invalid role selected.' };\n    }\n    const departmentExists = departments.some(d => d.name === validatedFields.data.department);\n    if (!departmentExists) {\n        return { message: 'Invalid department selected.' };\n    }\n\n    try {\n        // Check if Firebase Admin environment variables are configured\n        const requiredEnvVars = ['FIREBASE_PROJECT_ID', 'FIREBASE_PRIVATE_KEY', 'FIREBASE_CLIENT_EMAIL'];\n        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n        \n        if (missingVars.length > 0) {\n            console.warn(`Firebase Admin not configured. Missing: ${missingVars.join(', ')}`);\n            // Just add to database without Firebase Auth integration\n            await dbAddEmployee(validatedFields.data as NewEmployee);\n            revalidatePath('/employees');\n            return { \n                message: 'Employee added to database. Note: Firebase Auth integration requires environment variables to be configured for automatic account creation and email sending.'\n            };\n        }\n\n        // Initialize Firebase Admin\n        initializeFirebaseAdmin();\n        const auth = getAuth();\n\n        // Create user in Firebase Auth\n        const userRecord = await auth.createUser({\n            email: validatedFields.data.email,\n            displayName: validatedFields.data.name,\n            emailVerified: false,\n        });\n\n        // Add employee to database first\n        await dbAddEmployee(validatedFields.data as NewEmployee);\n\n        // Set a temporary password for the user\n        const tempPassword = Math.random().toString(36).slice(-12) + 'A1!'; // Ensure it meets Firebase requirements\n        \n        // Update the user with the temporary password\n        await auth.updateUser(userRecord.uid, {\n            password: tempPassword,\n        });\n\n        // Send password reset email using Firebase Auth's REST API\n        try {\n            const webApiKey = process.env.FIREBASE_WEB_API_KEY;\n            \n            if (!webApiKey) {\n                throw new Error('FIREBASE_WEB_API_KEY not configured');\n            }\n\n            // Use Firebase Auth REST API to send password reset email\n            const response = await fetch(`https://identitytoolkit.googleapis.com/v1/accounts:sendOobCode?key=${webApiKey}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    requestType: 'PASSWORD_RESET',\n                    email: validatedFields.data.email,\n                    continueUrl: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/login`,\n                }),\n            });\n\n            if (response.ok) {\n                const responseData = await response.json();\n                console.log('='.repeat(80));\n                console.log(`‚úÖ EMPLOYEE CREATED: ${validatedFields.data.name}`);\n                console.log(`üìß Email: ${validatedFields.data.email}`);\n                console.log(`üì® Password reset email sent successfully!`);\n                console.log(`üì¨ Email will be delivered by Firebase Auth`);\n                console.log('='.repeat(80));\n\n                revalidatePath('/employees');\n                return { \n                    message: `Successfully added employee ${validatedFields.data.name}. Password reset email has been sent to ${validatedFields.data.email}.`,\n                };\n            } else {\n                const errorData = await response.json();\n                console.error('Failed to send password reset email:', errorData);\n                throw new Error(`Email sending failed: ${errorData.error?.message || 'Unknown error'}`);\n            }\n        } catch (emailError) {\n            console.error('Error sending password reset email:', emailError);\n            \n            // Fallback: generate link for manual sharing\n            const resetLink = await auth.generatePasswordResetLink(validatedFields.data.email, {\n                url: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/login`,\n                handleCodeInApp: false,\n            });\n\n            console.log('='.repeat(80));\n            console.log(`‚úÖ EMPLOYEE CREATED: ${validatedFields.data.name}`);\n            console.log(`üìß Email: ${validatedFields.data.email}`);\n            console.log(`‚ùå Email sending failed: ${emailError.message}`);\n            console.log(`üîó Manual Reset Link: ${resetLink}`);\n            console.log(`üìù Please share this link with the employee`);\n            console.log('='.repeat(80));\n\n            revalidatePath('/employees');\n            return { \n                message: `Successfully added employee ${validatedFields.data.name}. Email sending failed - please share the reset link manually (check console).`,\n                resetLink: resetLink\n            };\n        }\n    } catch (error: any) {\n        console.error('Error adding employee:', error);\n        \n        // Handle specific Firebase errors\n        if (error.code === 'auth/email-already-exists') {\n            return { message: 'An account with this email already exists.' };\n        }\n        \n        if (error.message?.includes('Missing required Firebase environment variables')) {\n            // Fallback: add to database only\n            try {\n                await dbAddEmployee(validatedFields.data as NewEmployee);\n                revalidatePath('/employees');\n                return { \n                    message: 'Employee added to database. Firebase Auth integration requires proper environment configuration for automatic account creation.'\n                };\n            } catch (dbError) {\n                return { message: 'Failed to add employee to database.' };\n            }\n        }\n        \n        return { message: 'Failed to add employee. Please check Firebase configuration and try again.' };\n    }\n}\n\nexport async function deleteEmployeeAction(employeeId: string) {\n  try {\n    await dbDeleteEmployee(employeeId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete employee.' };\n  }\n  revalidatePath('/employees');\n  revalidatePath('/');\n  return { message: 'Successfully deleted employee.' };\n}\n\nconst UpdateEmployeeSchema = z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters.'),\n    email: z.string().email('Please enter a valid email.'),\n    phone: z.string().min(10, 'Please enter a valid phone number.'),\n    role: z.string(),\n    department: z.string(),\n    address: z.string().min(10, 'Address is required.'),\n});\n\nexport async function updateEmployeeAction(id: string, formData: FormData) {\n    const validatedFields = UpdateEmployeeSchema.safeParse({\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        role: formData.get('role'),\n        department: formData.get('department'),\n        address: formData.get('address'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to update employee.',\n        };\n    }\n\n    try {\n        await dbUpdateEmployee(id, validatedFields.data as NewEmployee);\n    } catch (error) {\n        return { message: 'Database Error: Failed to update employee.' };\n    }\n\n    revalidatePath('/employees');\n    revalidatePath('/');\n    return { message: 'Successfully updated employee.' };\n}\n\n\nconst AddEmployeeRoleSchema = z.object({\n    name: z.string().min(2, 'Role name must be at least 2 characters'),\n});\n\nexport async function addEmployeeRoleAction(formData: FormData) {\n    const validatedFields = AddEmployeeRoleSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddEmployeeRole(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add role.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: `Successfully added role '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteEmployeeRoleAction(id: string) {\n    try {\n        await dbDeleteEmployeeRole(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete role.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: 'Successfully deleted role.' };\n}\n\nconst AddDepartmentSchema = z.object({\n    name: z.string().min(2, 'Department name must be at least 2 characters'),\n});\n\nexport async function addDepartmentAction(formData: FormData) {\n    const validatedFields = AddDepartmentSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddDepartment(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add department.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: `Successfully added department '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteDepartmentAction(id: string) {\n    try {\n        await dbDeleteDepartment(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete department.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: 'Successfully deleted department.' };\n}\n\n// CSV Import Actions\nconst ImportProductSchema = z.object({\n    name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n    price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n    gstRate: z.coerce.number().min(0).max(100),\n    skus: z.array(z.string()).optional(),\n    catalogueUrl: z.string().url('Please enter a valid URL.').optional().or(z.literal('')),\n});\n\nexport async function importProductsFromCSV(csvData: any[]) {\n    const results = {\n        success: 0,\n        failed: 0,\n        errors: [] as string[]\n    };\n\n// Get all existing product categories to match against\nconst allCategories = await getProductCategories();\n\n    for (let i = 0; i < csvData.length; i++) {\n        const row = csvData[i];\n        \n        try {\n            // Parse SKUs from comma-separated string\n            const skus = row.skus ? row.skus.split(',').map((sku: string) => sku.trim()).filter(Boolean) : [];\n            \n// Match category by exact name (single category)\nlet categoryId: string | undefined = undefined;\nconst categoryName = (row.category || row.categories || '').toString().trim();\nif (categoryName) {\n    const existingCategory = allCategories.find((c) => c.name === categoryName);\n    if (existingCategory) {\n        categoryId = existingCategory.id;\n    } else {\n        results.errors.push(`Row ${i + 1}: Category not found: ${categoryName}. Please create this category first.`);\n    }\n}\n            \n// Prepare data for validation, including optional fields\n            const dataForValidation = {\n                name: row.name,\n                price: row.price,\n                gstRate: row.gstRate,\n                ...(skus.length > 0 && { skus }),\n                ...(row.catalogueUrl && row.catalogueUrl.trim() && { catalogueUrl: row.catalogueUrl }),\n            };\n\n            const validatedData = ImportProductSchema.parse(dataForValidation);\n\n            // Prepare data for database - only include defined fields\nconst productData = {\n    name: validatedData.name,\n    price: validatedData.price,\n    gstRate: validatedData.gstRate,\n    ...(validatedData.skus && { skus: validatedData.skus }),\n    ...(validatedData.catalogueUrl && { catalogueUrl: validatedData.catalogueUrl }),\n    ...(categoryId && { categoryId }),\n};\n\n            await dbAddProduct(productData);\n            \n            results.success++;\n        } catch (error) {\n            results.failed++;\n            if (error instanceof z.ZodError) {\n                const errorMessages = error.errors.map(e => `Row ${i + 1}: ${e.path.join('.')} - ${e.message}`);\n                results.errors.push(...errorMessages);\n            } else {\n                results.errors.push(`Row ${i + 1}: Failed to import product - ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        }\n    }\n\n    // Revalidate pages after import\n    revalidatePath('/products');\n    revalidatePath('/leads');\n\n    return {\n        success: results.failed === 0,\n        message: `Import completed. ${results.success} products imported successfully${results.failed > 0 ? `, ${results.failed} failed` : ''}.`,\n        errors: results.errors.length > 0 ? results.errors : undefined\n    };\n}\n\n// Count Actions\nexport async function getLeadsCountAction(): Promise<number> {\n    try {\n        return await getLeadsCount();\n    } catch (error) {\n        console.error('Error getting leads count:', error);\n        return 0;\n    }\n}\n\nexport async function getQuotationsCountAction(): Promise<number> {\n    try {\n        return await getQuotationsCount();\n    } catch (error) {\n        console.error('Error getting quotations count:', error);\n        return 0;\n    }\n}\n\nexport async function getProductsCountAction(): Promise<number> {\n    try {\n        return await getProductsCount();\n    } catch (error) {\n        console.error('Error getting products count:', error);\n        return 0;\n    }\n}\n\nexport async function getEmployeesCountAction(): Promise<number> {\n    try {\n        return await getEmployeesCount();\n    } catch (error) {\n        console.error('Error getting employees count:', error);\n        return 0;\n    }\n}\n\nexport async function getLeadsCountByStatusAction(status: LeadStatus): Promise<number> {\n    try {\n        return await getLeadsCountByStatus(status);\n    } catch (error) {\n        console.error(`Error getting leads count for status ${status}:`, error);\n        return 0;\n    }\n}\n\nexport async function getQuotationsCountByStatusAction(status: 'Draft' | 'Sent' | 'Accepted' | 'Rejected'): Promise<number> {\n    try {\n        return await getQuotationsCountByStatus(status);\n    } catch (error) {\n        console.error(`Error getting quotations count for status ${status}:`, error);\n        return 0;\n    }\n}\n\nexport async function getActiveProductsCountAction(): Promise<number> {\n    try {\n        return await getActiveProductsCount();\n    } catch (error) {\n        console.error('Error getting active products count:', error);\n        return 0;\n    }\n}\n\nexport async function getActiveEmployeesCountAction(): Promise<number> {\n    try {\n        return await getActiveEmployeesCount();\n    } catch (error) {\n        console.error('Error getting active employees count:', error);\n        return 0;\n    }\n}\n\n// Communication Activity Actions\nconst CommunicationActivitySchema = z.object({\n  leadId: z.string().min(1, 'Lead ID is required'),\n  type: z.enum(['WhatsApp', 'Email']),\n  message: z.string().min(1, 'Message is required'),\n  contact: z.string().min(1, 'Contact is required'),\n  sentBy: z.string().min(1, 'Sent by is required'),\n});\n\nexport async function logCommunicationActivityAction(formData: FormData) {\n  const validatedFields = CommunicationActivitySchema.safeParse({\n    leadId: formData.get('leadId'),\n    type: formData.get('type'),\n    message: formData.get('message'),\n    contact: formData.get('contact'),\n    sentBy: formData.get('sentBy'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Missing Fields. Failed to log communication activity.',\n    };\n  }\n\n  const { leadId, type, message, contact, sentBy } = validatedFields.data;\n\n  try {\n    const activityNotes = `${type} message sent to ${contact} by ${sentBy}:\\n\\n\"${message}\"`;\n    \n    await addActivityToLead(leadId, {\n      type: type as 'WhatsApp' | 'Email',\n      notes: activityNotes\n    });\n  } catch (error) {\n    const errMsg = error instanceof Error ? error.message : String(error);\n    console.error('LogCommunicationActivity Error:', errMsg);\n    if (errMsg.includes('Lead not found')) {\n      return { message: 'Lead not found. Please refresh the page and try again.' };\n    }\n    return { message: 'Database Error: Failed to log communication activity.' };\n  }\n\n  return { message: `Successfully logged ${type} communication.` };\n}\n\nexport async function getCurrentUserEmployeeAction(email: string): Promise<Employee | null> {\n    try {\n        return await getEmployeeByEmail(email);\n    } catch (error) {\n        console.error('Error getting current user employee:', error);\n        return null;\n    }\n}\n\n// ==================== Currency Actions ====================\nimport { addCurrency as dbAddCurrency, updateCurrency as dbUpdateCurrency, deleteCurrency as dbDeleteCurrency } from './firestore-service';\n\nconst CurrencySchema = z.object({\n  code: z.string().min(2, 'Currency code must be at least 2 characters').max(5, 'Currency code must be at most 5 characters'),\n  name: z.string().min(2, 'Currency name is required'),\n  symbol: z.string().min(1, 'Currency symbol is required'),\n  conversionRate: z.coerce.number().positive('Conversion rate must be positive'),\n});\n\nexport async function addCurrencyAction(formData: FormData) {\n  const validatedFields = CurrencySchema.safeParse({\n    code: formData.get('code'),\n    name: formData.get('name'),\n    symbol: formData.get('symbol'),\n    conversionRate: formData.get('conversionRate'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Validation Error: Failed to add currency.',\n    };\n  }\n\n  try {\n    await dbAddCurrency(validatedFields.data);\n  } catch (error) {\n    return { message: 'Database Error: Failed to add currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully added currency.' };\n}\n\nexport async function updateCurrencyAction(id: string, formData: FormData) {\n  const validatedFields = CurrencySchema.safeParse({\n    code: formData.get('code'),\n    name: formData.get('name'),\n    symbol: formData.get('symbol'),\n    conversionRate: formData.get('conversionRate'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Validation Error: Failed to update currency.',\n    };\n  }\n\n  try {\n    await dbUpdateCurrency(id, validatedFields.data);\n  } catch (error) {\n    return { message: 'Database Error: Failed to update currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully updated currency.' };\n}\n\nexport async function deleteCurrencyAction(id: string) {\n  try {\n    await dbDeleteCurrency(id);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully deleted currency.' };\n}\n\n"],"names":[],"mappings":";;;;;;IAmQsB,aAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/badge.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n"],"names":[],"mappings":";;;;;AACA;AAEA;;;;AAEA,MAAM,gBAAgB,CAAA,GAAA,gKAAA,CAAA,MAAG,AAAD,EACtB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SAAS;QACX;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAOF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBACE,8OAAC;QAAI,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAExE","debugId":null}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/progress.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }\n"],"names":[],"mappings":";;;;AAEA;AACA;AAEA;AALA;;;;;AAOA,MAAM,yBAAW,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG9B,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,OAAO,EAAE,oBACjC,8OAAC,oKAAA,CAAA,OAAsB;QACrB,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,iEACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,oKAAA,CAAA,YAA2B;YAC1B,WAAU;YACV,OAAO;gBAAE,WAAW,CAAC,YAAY,EAAE,MAAM,CAAC,SAAS,CAAC,EAAE,EAAE,CAAC;YAAC;;;;;;;;;;;AAIhE,SAAS,WAAW,GAAG,oKAAA,CAAA,OAAsB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/storage-utils.ts"],"sourcesContent":["// Firebase Storage utilities for PDF file management\n// Generate UUID without external dependency\nfunction generateUUID(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nexport interface UploadResult {\n  url: string; // Firebase Storage download URL\n  path: string; // Storage path\n  fileName: string;\n}\n\n/**\n * Legacy function - now redirects to Firebase Storage upload\n * @deprecated Use uploadPDFToStorage instead\n */\nexport async function uploadPDF(file: File, folder: string = 'catalogs'): Promise<UploadResult> {\n  console.warn('uploadPDF is deprecated, use uploadPDFToStorage instead');\n  return uploadPDFToStorage(file, folder);\n}\n\n// Firebase Storage upload (preferred to avoid large Server Actions bodies)\nimport { ref, uploadBytesResumable, getDownloadURL, deleteObject } from 'firebase/storage';\nimport { storage } from '@/lib/firebase';\n\nexport async function uploadPDFToStorage(\n  file: File,\n  folder: string = 'catalogs',\n  onProgress?: (percent: number) => void\n): Promise<UploadResult> {\n  if (!isPdfFile(file)) {\n    throw new Error('Only PDF files are allowed');\n  }\n  // Allow up to 10MB for Storage uploads\n  const maxSize = 10 * 1024 * 1024;\n  if (file.size > maxSize) {\n    throw new Error('File size must be less than 10MB');\n  }\n\n  const uniqueId = generateUUID();\n  const filePath = `${folder}/${uniqueId}-${encodeURIComponent(file.name)}`;\n  const storageRef = ref(storage, filePath);\n  const task = uploadBytesResumable(storageRef, file, { contentType: 'application/pdf' });\n\n  const url = await new Promise<string>((resolve, reject) => {\n    task.on('state_changed', (snapshot) => {\n      if (onProgress) {\n        const percent = Math.round((snapshot.bytesTransferred / snapshot.totalBytes) * 100);\n        onProgress(percent);\n      }\n    }, (error) => reject(error), async () => {\n      const downloadUrl = await getDownloadURL(task.snapshot.ref);\n      resolve(downloadUrl);\n    });\n  });\n\n  return {\n    url,\n    path: filePath,\n    fileName: file.name,\n  };\n}\n\n/**\n * Delete a PDF file from Firebase Storage\n * @param filePath - The storage path of the file to delete\n */\nexport async function deletePDFFromStorage(filePath: string): Promise<void> {\n  try {\n    const storageRef = ref(storage, filePath);\n    await deleteObject(storageRef);\n    console.log(`Successfully deleted file: ${filePath}`);\n  } catch (error) {\n    console.error('Error deleting file from storage:', error);\n    throw new Error(`Failed to delete file: ${filePath}`);\n  }\n}\n\n/**\n * Legacy function - now redirects to Firebase Storage delete\n * @deprecated Use deletePDFFromStorage instead\n */\nexport async function deletePDF(filePath: string): Promise<void> {\n  console.warn('deletePDF is deprecated, use deletePDFFromStorage instead');\n  return deletePDFFromStorage(filePath);\n}\n\n/**\n * Validate PDF file before upload\n * @param file - The file to validate\n * @returns boolean indicating if file is valid\n */\nexport function validatePDFFile(file: File): { isValid: boolean; error?: string } {\n  // Check file type (support cases where MIME may be generic but name ends with .pdf)\n  if (!isPdfFile(file)) {\n    return { isValid: false, error: 'Only PDF files are allowed' };\n  }\n\n  // Check file size (10MB limit for Firebase Storage)\n  const maxSize = 10 * 1024 * 1024; // 10MB in bytes\n  if (file.size > maxSize) {\n    return { isValid: false, error: 'File size must be less than 10MB' };\n  }\n\n  // Check file name length\n  if (file.name.length > 100) {\n    return { isValid: false, error: 'File name is too long' };\n  }\n\n  return { isValid: true };\n}\n\n// Heuristic to identify PDFs when the MIME type can be unreliable\nfunction isPdfFile(file: File): boolean {\n  const type = (file.type || '').toLowerCase();\n  const name = (file.name || '').toLowerCase();\n  if (type === 'application/pdf' || type === 'application/x-pdf') return true;\n  // Some environments provide a generic type for downloads/uploads\n  if ((type === '' || type === 'application/octet-stream') && name.endsWith('.pdf')) return true;\n  return false;\n}\n\n/**\n * Format file size for display\n * @param bytes - File size in bytes\n * @returns Formatted file size string\n */\nexport function formatFileSize(bytes: number): string {\n  if (bytes === 0) return '0 Bytes';\n\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n\n/**\n * Upload an image to Firebase Storage\n * @param file - The image file to upload\n * @param folder - The folder in Firebase Storage (default: 'products')\n * @param onProgress - Optional callback for upload progress\n * @returns Upload result with URL and metadata\n */\nexport async function uploadImageToStorage(\n  file: File,\n  folder: string = 'products',\n  onProgress?: (percent: number) => void\n): Promise<UploadResult> {\n  if (!isImageFile(file)) {\n    throw new Error('Only image files are allowed');\n  }\n  // Allow up to 10MB for image uploads\n  const maxSize = 10 * 1024 * 1024;\n  if (file.size > maxSize) {\n    throw new Error('Image size must be less than 10MB');\n  }\n\n  const uniqueId = generateUUID();\n  const filePath = `${folder}/${uniqueId}-${encodeURIComponent(file.name)}`;\n  const storageRef = ref(storage, filePath);\n  const task = uploadBytesResumable(storageRef, file, { contentType: file.type });\n\n  const url = await new Promise<string>((resolve, reject) => {\n    task.on('state_changed', (snapshot) => {\n      if (onProgress) {\n        const percent = Math.round((snapshot.bytesTransferred / snapshot.totalBytes) * 100);\n        onProgress(percent);\n      }\n    }, (error) => reject(error), async () => {\n      const downloadUrl = await getDownloadURL(task.snapshot.ref);\n      resolve(downloadUrl);\n    });\n  });\n\n  return {\n    url,\n    path: filePath,\n    fileName: file.name,\n  };\n}\n\n/**\n * Delete an image file from Firebase Storage\n * @param filePath - The storage path of the file to delete\n */\nexport async function deleteImageFromStorage(filePath: string): Promise<void> {\n  try {\n    const storageRef = ref(storage, filePath);\n    await deleteObject(storageRef);\n    console.log(`Successfully deleted image: ${filePath}`);\n  } catch (error) {\n    console.error('Error deleting image from storage:', error);\n    throw new Error(`Failed to delete image: ${filePath}`);\n  }\n}\n\n/**\n * Validate image file before upload\n * @param file - The file to validate\n * @returns validation result\n */\nexport function validateImageFile(file: File): { isValid: boolean; error?: string } {\n  if (!isImageFile(file)) {\n    return { isValid: false, error: 'Only image files (JPG, PNG, GIF, WebP) are allowed' };\n  }\n\n  // Check file size (10MB limit)\n  const maxSize = 10 * 1024 * 1024;\n  if (file.size > maxSize) {\n    return { isValid: false, error: 'Image size must be less than 10MB' };\n  }\n\n  // Check file name length\n  if (file.name.length > 100) {\n    return { isValid: false, error: 'File name is too long' };\n  }\n\n  return { isValid: true };\n}\n\n// Helper to identify image files\nfunction isImageFile(file: File): boolean {\n  const type = (file.type || '').toLowerCase();\n  const name = (file.name || '').toLowerCase();\n  \n  const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];\n  if (validTypes.includes(type)) return true;\n  \n  // Fallback to extension check\n  const validExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];\n  if ((type === '' || type === 'application/octet-stream') && \n      validExtensions.some(ext => name.endsWith(ext))) {\n    return true;\n  }\n  \n  return false;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/pdf-upload.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useRef } from 'react';\n\nfunction PdfPreviewModal({ pdfUrl, onClose }: { pdfUrl: string; onClose: () => void }) {\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-2\">\n      <div className=\"bg-white rounded-lg shadow-2xl w-full h-full max-w-[98vw] max-h-[98vh] flex flex-col overflow-hidden\">\n        <div className=\"flex justify-between items-center p-4 border-b\">\n          <h3 className=\"text-lg font-semibold\">PDF Preview</h3>\n          <Button variant=\"ghost\" size=\"sm\" onClick={onClose}>            <X className=\"h-5 w-5\" />\n          </Button>\n        </div>\n        <div className=\"flex-grow\">\n          <iframe src={pdfUrl} className=\"w-full h-full\" title=\"PDF Preview\" />\n        </div>\n      </div>\n    </div>\n  );\n}\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Progress } from '@/components/ui/progress';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Upload, File, X, CheckCircle, AlertCircle } from 'lucide-react';\nimport { uploadPDFToStorage, validatePDFFile, formatFileSize, UploadResult } from '@/lib/storage-utils';\n\ninterface PDFUploadProps {\n  onUploadComplete: (result: UploadResult) => void;\n  onUploadError: (error: string) => void;\n  currentPdf?: {\n    url: string;\n    fileName: string;\n    filePath?: string;\n    path?: string;\n  } | null;\n  onRemove?: () => void;\n  disabled?: boolean;\n  label?: string;\n  description?: string;\n}\n\nexport function PDFUpload({\n  onUploadComplete,\n  onUploadError,\n  currentPdf,\n  onRemove,\n  disabled = false,\n  label = \"Catalog PDF\",\n  description = \"Upload a PDF file (max 5MB)\"\n}: PDFUploadProps) {\n  const [isUploading, setIsUploading] = useState(false);\n  const [uploadProgress, setUploadProgress] = useState(0);\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  const [dragActive, setDragActive] = useState(false);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  const handleFileSelect = async (file: File) => {\n    // Validate file\n    const validation = validatePDFFile(file);\n    if (!validation.isValid) {\n      onUploadError(validation.error || 'Invalid file');\n      return;\n    }\n\n    setIsUploading(true);\n    setUploadProgress(0);\n\n    try {\n      const result = await uploadPDFToStorage(file, 'catalogs', (percent) => {\n        setUploadProgress(percent);\n      });\n      \n      setUploadProgress(100);\n      \n      setTimeout(() => {\n        onUploadComplete(result);\n        setIsUploading(false);\n        setUploadProgress(0);\n      }, 500);\n\n    } catch (error) {\n      setIsUploading(false);\n      setUploadProgress(0);\n      onUploadError(error instanceof Error ? error.message : 'Upload failed');\n    }\n  };\n\n  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (file) {\n      handleFileSelect(file);\n    }\n  };\n\n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault();\n    setDragActive(false);\n    \n    const file = e.dataTransfer.files?.[0];\n    if (file) {\n      handleFileSelect(file);\n    }\n  };\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault();\n    setDragActive(true);\n  };\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault();\n    setDragActive(false);\n  };\n\n  const openFileDialog = () => {\n    fileInputRef.current?.click();\n  };\n\n  const handleRemove = () => {\n    if (onRemove) {\n      onRemove();\n    }\n  };\n\n  return (\n    <div className=\"space-y-2\">\n      {isModalOpen && currentPdf && (\n        <PdfPreviewModal pdfUrl={currentPdf.url} onClose={() => setIsModalOpen(false)} />\n      )}\n      <Label>{label}</Label>\n      \n      {currentPdf ? (\n        // Show current PDF\n        <div className=\"flex items-center justify-between p-3 border rounded-lg bg-green-50 border-green-200\">\n          <div className=\"flex items-center gap-2\">\n            <CheckCircle className=\"h-4 w-4 text-green-600\" />\n            <File className=\"h-4 w-4 text-gray-600\" />\n            <div>\n              <p className=\"text-sm font-medium text-gray-900\">{currentPdf.fileName}</p>\n              <p className=\"text-xs text-gray-500\">PDF uploaded successfully</p>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={() => setIsModalOpen(true)}\n              disabled={disabled}\n            >\n              View\n            </Button>\n            {onRemove && (\n              <Button\n                type=\"button\"\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={handleRemove}\n                disabled={disabled}\n              >\n                <X className=\"h-4 w-4\" />\n              </Button>\n            )}\n          </div>\n        </div>\n      ) : (\n        // Show upload area\n        <>\n          <div\n            className={`\n              relative border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors\n              ${dragActive ? 'border-primary bg-primary/5' : 'border-gray-300 hover:border-gray-400'}\n              ${disabled ? 'opacity-50 cursor-not-allowed' : ''}\n            `}\n            onDrop={handleDrop}\n            onDragOver={handleDragOver}\n            onDragLeave={handleDragLeave}\n            onClick={!disabled ? openFileDialog : undefined}\n          >\n            <input\n              ref={fileInputRef}\n              type=\"file\"\n              accept=\".pdf\"\n              onChange={handleFileInputChange}\n              className=\"hidden\"\n              disabled={disabled}\n            />\n            \n            {isUploading ? (\n              <div className=\"space-y-2\">\n                <Upload className=\"h-8 w-8 mx-auto text-primary animate-pulse\" />\n                <p className=\"text-sm font-medium\">Uploading PDF...</p>\n                <Progress value={uploadProgress} className=\"w-full max-w-xs mx-auto\" />\n                <p className=\"text-xs text-gray-500\">{uploadProgress}% complete</p>\n              </div>\n            ) : (\n              <div className=\"space-y-2\">\n                <Upload className=\"h-8 w-8 mx-auto text-gray-400\" />\n                <div>\n                  <p className=\"text-sm font-medium\">Click to upload or drag and drop</p>\n                  <p className=\"text-xs text-gray-500\">{description}</p>\n                </div>\n              </div>\n            )}\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 805, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/image-upload.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useRef } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Label } from '@/components/ui/label';\nimport { Progress } from '@/components/ui/progress';\nimport { Upload, X, CheckCircle, Image as ImageIcon } from 'lucide-react';\nimport { uploadImageToStorage, validateImageFile, UploadResult } from '@/lib/storage-utils';\nimport Image from 'next/image';\n\ninterface ImageUploadProps {\n  onUploadComplete: (result: UploadResult) => void;\n  onUploadError: (error: string) => void;\n  onFileSelect?: (file: File) => void;\n  currentImage?: {\n    url: string;\n    fileName: string;\n    filePath?: string;\n    path?: string;\n  } | null;\n  onRemove?: () => void;\n  disabled?: boolean;\n  label?: string;\n  description?: string;\n}\n\nexport function ImageUpload({\n  onUploadComplete,\n  onUploadError,\n  onFileSelect,\n  currentImage,\n  onRemove,\n  disabled = false,\n  label = \"Product Image\",\n  description = \"Upload an image (max 5MB, JPG/PNG/GIF/WebP)\"\n}: ImageUploadProps) {\n  const [isUploading, setIsUploading] = useState(false);\n  const [uploadProgress, setUploadProgress] = useState(0);\n  const [dragActive, setDragActive] = useState(false);\n  const [previewUrl, setPreviewUrl] = useState<string | null>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  const handleFileSelect = async (file: File) => {\n    // Validate file\n    const validation = validateImageFile(file);\n    if (!validation.isValid) {\n      onUploadError(validation.error || 'Invalid file');\n      return;\n    }\n\n    // Call onFileSelect callback to store original file\n    if (onFileSelect) {\n      onFileSelect(file);\n    }\n\n    // Create local preview\n    const localPreview = URL.createObjectURL(file);\n    setPreviewUrl(localPreview);\n\n    setIsUploading(true);\n    setUploadProgress(0);\n\n    try {\n      const result = await uploadImageToStorage(file, 'products', (percent) => {\n        setUploadProgress(percent);\n      });\n      \n      setUploadProgress(100);\n      \n      console.log('Image upload successful, result:', result);\n      \n      setTimeout(() => {\n        console.log('Calling onUploadComplete with result:', result);\n        onUploadComplete(result);\n        setIsUploading(false);\n        setUploadProgress(0);\n        URL.revokeObjectURL(localPreview);\n      }, 500);\n\n    } catch (error) {\n      setIsUploading(false);\n      setUploadProgress(0);\n      setPreviewUrl(null);\n      URL.revokeObjectURL(localPreview);\n      onUploadError(error instanceof Error ? error.message : 'Upload failed');\n    }\n  };\n\n  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (file) {\n      handleFileSelect(file);\n    }\n  };\n\n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault();\n    setDragActive(false);\n    \n    const file = e.dataTransfer.files?.[0];\n    if (file) {\n      handleFileSelect(file);\n    }\n  };\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault();\n    setDragActive(true);\n  };\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault();\n    setDragActive(false);\n  };\n\n  const openFileDialog = () => {\n    fileInputRef.current?.click();\n  };\n\n  const handleRemove = () => {\n    if (previewUrl) {\n      URL.revokeObjectURL(previewUrl);\n      setPreviewUrl(null);\n    }\n    if (onRemove) {\n      onRemove();\n    }\n  };\n\n  const displayUrl = previewUrl || currentImage?.url;\n\n  return (\n    <div className=\"space-y-2\">\n      <Label>{label}</Label>\n      \n      {currentImage || previewUrl ? (\n        // Show current/preview image\n        <div className=\"space-y-2\">\n          <div className=\"relative w-full aspect-video rounded-lg overflow-hidden border bg-gray-50\">\n            {displayUrl && (\n              <Image\n                src={displayUrl}\n                alt={currentImage?.fileName || 'Product image'}\n                fill\n                className=\"object-contain\"\n                sizes=\"(max-width: 768px) 100vw, 600px\"\n              />\n            )}\n          </div>\n          <div className=\"flex items-center justify-between p-3 border rounded-lg bg-green-50 border-green-200\">\n            <div className=\"flex items-center gap-2\">\n              <CheckCircle className=\"h-4 w-4 text-green-600\" />\n              <ImageIcon className=\"h-4 w-4 text-gray-600\" />\n              <div>\n                <p className=\"text-sm font-medium text-gray-900\">\n                  {currentImage?.fileName || 'Image uploaded'}\n                </p>\n                <p className=\"text-xs text-gray-500\">Image uploaded successfully</p>\n              </div>\n            </div>\n            <div className=\"flex items-center gap-2\">\n              {onRemove && (\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={handleRemove}\n                  disabled={disabled}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          </div>\n        </div>\n      ) : (\n        // Show upload area\n        <>\n          <div\n            className={`\n              relative border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors\n              ${dragActive ? 'border-primary bg-primary/5' : 'border-gray-300 hover:border-gray-400'}\n              ${disabled ? 'opacity-50 cursor-not-allowed' : ''}\n            `}\n            onDrop={handleDrop}\n            onDragOver={handleDragOver}\n            onDragLeave={handleDragLeave}\n            onClick={!disabled ? openFileDialog : undefined}\n          >\n            <input\n              ref={fileInputRef}\n              type=\"file\"\n              accept=\"image/jpeg,image/jpg,image/png,image/gif,image/webp\"\n              onChange={handleFileInputChange}\n              className=\"hidden\"\n              disabled={disabled}\n            />\n            \n            {isUploading ? (\n              <div className=\"space-y-2\">\n                <Upload className=\"h-8 w-8 mx-auto text-primary animate-pulse\" />\n                <p className=\"text-sm font-medium\">Uploading image...</p>\n                <Progress value={uploadProgress} className=\"w-full max-w-xs mx-auto\" />\n                <p className=\"text-xs text-gray-500\">{uploadProgress}% complete</p>\n              </div>\n            ) : (\n              <div className=\"space-y-2\">\n                <ImageIcon className=\"h-8 w-8 mx-auto text-gray-400\" />\n                <div>\n                  <p className=\"text-sm font-medium\">Click to upload or drag and drop</p>\n                  <p className=\"text-xs text-gray-500\">{description}</p>\n                </div>\n              </div>\n            )}\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1151, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/select.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1343, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { getAuth } from 'firebase-admin/auth';\nimport { initializeApp, getApps, cert } from 'firebase-admin/app';\nimport { summarizeMeetingNotes } from '@/ai/flows/summarize-meeting-notes';\nimport { addLead as dbAddLead, addActivityToLead, updateLeadStatus as updateStatus, addProduct as dbAddProduct, addLeadSource as dbAddLeadSource, deleteLeadSource as dbDeleteLeadSource, addProductCategory as dbAddProductCategory, deleteProductCategory as dbDeleteProductCategory, getProductCategories, updateLead as dbUpdateLead, getLeadById as dbGetLeadById, deleteLead as dbDeleteLead, addQuotation as dbAddQuotation, updateQuotation as dbUpdateQuotation, deleteQuotation as dbDeleteQuotation, addQuotationTemplate as dbAddQuotationTemplate, updateProduct as dbUpdateProduct, deleteProduct as dbDeleteProduct, addEmployee as dbAddEmployee, deleteEmployee as dbDeleteEmployee, updateEmployee as dbUpdateEmployee, getEmployeeByEmail, getEmployeeRoles, addEmployeeRole as dbAddEmployeeRole, deleteEmployeeRole as dbDeleteEmployeeRole, getDepartments, addDepartment as dbAddDepartment, deleteDepartment as dbDeleteDepartment, updateQuotationTemplate as dbUpdateQuotationTemplate, deleteQuotationTemplate as dbDeleteQuotationTemplate, getLeadsCount, getQuotationsCount, getProductsCount, getEmployeesCount, getLeadsCountByStatus, getQuotationsCountByStatus, getActiveProductsCount, getActiveEmployeesCount, updateProductCategory as dbUpdateProductCategory } from './data';\nimport { deletePDFFromStorage, deleteImageFromStorage, uploadImageToStorage } from './storage-utils';\nimport type { Lead, LeadStatus, LeadProduct, UpdatableLeadData, Product, NewQuotationTemplate, Quotation, NewEmployee, QuotationTemplate } from './types';\nimport type { Employee } from './business-types';\nimport { getProducts } from './data';\n\n// Initialize Firebase Admin SDK\nfunction initializeFirebaseAdmin() {\n  if (getApps().length === 0) {\n    // Check if all required environment variables are present\n    const requiredEnvVars = [\n      'FIREBASE_PROJECT_ID',\n      'FIREBASE_PRIVATE_KEY',\n      'FIREBASE_CLIENT_EMAIL'\n    ];\n    \n    const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n    \n    if (missingVars.length > 0) {\n      throw new Error(`Missing required Firebase environment variables: ${missingVars.join(', ')}`);\n    }\n\n    const serviceAccount = {\n      type: \"service_account\",\n      project_id: process.env.FIREBASE_PROJECT_ID!,\n      private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,\n      private_key: process.env.FIREBASE_PRIVATE_KEY!.replace(/\\\\n/g, '\\n'),\n      client_email: process.env.FIREBASE_CLIENT_EMAIL!,\n      client_id: process.env.FIREBASE_CLIENT_ID,\n      auth_uri: \"https://accounts.google.com/o/oauth2/auth\",\n      token_uri: \"https://oauth2.googleapis.com/token\",\n      auth_provider_x509_cert_url: \"https://www.googleapis.com/oauth2/v1/certs\",\n      client_x509_cert_url: `https://www.googleapis.com/robot/v1/metadata/x509/${process.env.FIREBASE_CLIENT_EMAIL}`\n    };\n\n    initializeApp({\n      credential: cert(serviceAccount as any),\n      projectId: process.env.FIREBASE_PROJECT_ID,\n    });\n  }\n}\n\nconst LeadProductSchema = z.object({\n    productId: z.string().min(1, 'Product must be selected'),\n    quantity: z.coerce.number().min(1),\n    rate: z.coerce.number().min(0),\n    selectedSku: z.string().optional(),\n});\n\nconst CreateLeadSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  company: z.string().min(2, 'Company must be at least 2 characters'),\n  email: z.string().email('Invalid email address'),\n  phone: z.string().min(10, 'Phone number seems too short'),\n  whatsappNumber: z.string().optional().or(z.literal('')),\n  client_address: z.string().optional().or(z.literal('')),\n  client_gst_no: z.string().optional().or(z.literal('')),\n  status: z.enum(['New', 'In Discussion', 'Negotiation', 'Closed - Won', 'Closed - Lost']),\n  source: z.string().min(1, 'Please select a lead source'),\n  notes: z.string().optional(),\n  products: z.array(LeadProductSchema).optional(),\n  createdBy: z.string().min(1, 'Created by field is required'),\n});\n\nexport async function createLead(formData: FormData) {\n  const productsJSON = formData.get('products');\n  const products = productsJSON ? JSON.parse(productsJSON as string) : [];\n\n  const validatedFields = CreateLeadSchema.safeParse({\n    name: formData.get('name'),\n    company: formData.get('company'),\n    email: formData.get('email'),\n    phone: formData.get('phone'),\n    whatsappNumber: formData.get('whatsappNumber'),\n    client_address: formData.get('client_address'),\n    client_gst_no: formData.get('client_gst_no'),\n    status: formData.get('status'),\n    source: formData.get('source'),\n    notes: formData.get('notes'),\n    products: products,\n    createdBy: formData.get('createdBy'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Failed to create lead.',\n    };\n  }\n  \n  let newLeadId: string | undefined;\n  try {\n    const leadData = {\n      ...validatedFields.data,\n      products: validatedFields.data.products || []\n    };\n    const newLead = await dbAddLead(leadData);\n    newLeadId = newLead.id;\n  } catch (error) {\n    return { message: 'Database Error: Failed to Create Lead.' };\n  }\n\n  revalidatePath('/leads');\n  revalidatePath('/');\n  if (newLeadId) {\n    revalidatePath(`/leads/${newLeadId}`);\n  }\n  return { message: 'Successfully created lead.' };\n}\n\nconst UpdateLeadSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  company: z.string().min(2, 'Company must be at least 2 characters'),\n  email: z.string().email('Invalid email address'),\n  phone: z.string().min(10, 'Phone number seems too short'),\n  whatsappNumber: z.string().optional().or(z.literal('')),\n  client_address: z.string().optional().or(z.literal('')),\n  client_gst_no: z.string().optional().or(z.literal('')),\n  status: z.enum(['New', 'In Discussion', 'Negotiation', 'Closed - Won', 'Closed - Lost']),\n  source: z.string().min(1, 'Please select a lead source'),\n  products: z.array(LeadProductSchema).optional(),\n});\n\nfunction generateChangeNotes(oldLead: Lead, newLeadData: UpdatableLeadData, allProducts: Product[]): string {\n    const changes: string[] = [];\n\n    if (oldLead.name !== newLeadData.name) {\n        changes.push(`Name changed from \"${oldLead.name}\" to \"${newLeadData.name}\".`);\n    }\n    if (oldLead.company !== newLeadData.company) {\n        changes.push(`Company changed from \"${oldLead.company}\" to \"${newLeadData.company}\".`);\n    }\n    if (oldLead.email !== newLeadData.email) {\n        changes.push(`Email changed from \"${oldLead.email}\" to \"${newLeadData.email}\".`);\n    }\n    if (oldLead.phone !== newLeadData.phone) {\n        changes.push(`Phone changed from \"${oldLead.phone}\" to \"${newLeadData.phone}\".`);\n    }\n    if (oldLead.whatsappNumber !== newLeadData.whatsappNumber) {\n        changes.push(`WhatsApp Number changed from \"${oldLead.whatsappNumber || 'N/A'}\" to \"${newLeadData.whatsappNumber || 'N/A'}\".`);\n    }\n    if (oldLead.client_address !== newLeadData.client_address) {\n        changes.push(`Client Address changed from \"${oldLead.client_address || 'N/A'}\" to \"${newLeadData.client_address || 'N/A'}\".`);\n    }\n    if (oldLead.client_gst_no !== newLeadData.client_gst_no) {\n        changes.push(`Client GST Number changed from \"${oldLead.client_gst_no || 'N/A'}\" to \"${newLeadData.client_gst_no || 'N/A'}\".`);\n    }\n    if (oldLead.status !== newLeadData.status) {\n        changes.push(`Status changed from \"${oldLead.status}\" to \"${newLeadData.status}\".`);\n    }\n    if (oldLead.source !== newLeadData.source) {\n        changes.push(`Source changed from \"${oldLead.source}\" to \"${newLeadData.source}\".`);\n    }\n\n    const oldProducts = oldLead.products || [];\n    const newProducts = newLeadData.products || [];\n    if (JSON.stringify(oldProducts) !== JSON.stringify(newProducts)) {\n        const getProductName = (productId: string) => allProducts.find(p => p.id === productId)?.name || productId;\n        \n        const formatProduct = (p: LeadProduct) => `${getProductName(p.productId)} (Qty: ${p.quantity}, Rate: ${p.rate}, SKU: ${p.selectedSku || 'N/A'})`;\n\n        const oldProductStr = oldProducts.map(formatProduct).join(', ') || 'None';\n        const newProductStr = newProducts.map(formatProduct).join(', ') || 'None';\n\n        changes.push(`Interested products updated.\\n- Old: ${oldProductStr}\\n- New: ${newProductStr}`);\n    }\n\n    if (changes.length === 0) {\n        return 'No changes were made to the lead details.';\n    }\n\n    return 'Lead details were updated:\\n' + changes.map(c => `- ${c}`).join('\\n');\n}\n\nexport async function updateLead(leadId: string, formData: FormData) {\n    const [oldLead, allProducts] = await Promise.all([\n        dbGetLeadById(leadId),\n        getProducts()\n    ]);\n\n    if (!oldLead) {\n        return { message: 'Error: Lead not found.' };\n    }\n\n    const productsJSON = formData.get('products');\n    const products = productsJSON ? JSON.parse(productsJSON as string) : [];\n  \n    const validatedFields = UpdateLeadSchema.safeParse({\n      name: formData.get('name'),\n      company: formData.get('company'),\n      email: formData.get('email'),\n      phone: formData.get('phone'),\n      whatsappNumber: formData.get('whatsappNumber'),\n      client_address: formData.get('client_address'),\n      client_gst_no: formData.get('client_gst_no'),\n      status: formData.get('status'),\n      source: formData.get('source'),\n      products: products,\n    });\n  \n    if (!validatedFields.success) {\n      return {\n        errors: validatedFields.error.flatten().fieldErrors,\n        message: 'Failed to update lead.',\n      };\n    }\n\n    const newLeadData = validatedFields.data as UpdatableLeadData;\n    const changeNotes = generateChangeNotes(oldLead, newLeadData, allProducts);\n  \n    try {\n        await dbUpdateLead(leadId, newLeadData);\n        if (changeNotes !== 'No changes were made to the lead details.') {\n            await addActivityToLead(leadId, {\n                type: 'Revision Request',\n                notes: changeNotes\n            });\n        }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'An unknown error occurred';\n      return { message: `Database Error: Failed to Update Lead. ${message}` };\n    }\n  \n    revalidatePath('/leads');\n    revalidatePath('/');\n    revalidatePath(`/leads/${leadId}`);\n    return { message: 'Successfully updated lead.' };\n}\n\nconst ProductSchema = z.object({\n    name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n    price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n    gstRate: z.coerce.number().min(0).max(100),\n    categoryId: z.string().optional(),\n    description: z.string().optional(),\n    skus: z.array(z.string()).optional(),\n    catalogueUrl: z.string().url('Please enter a valid URL.').optional().or(z.literal('')),\n    cataloguePdf: z.object({\n        url: z.string(),\n        fileName: z.string(),\n        filePath: z.string(),\n        uploadedAt: z.string(),\n    }).optional(),\n    productImage: z.object({\n        url: z.string(),\n        fileName: z.string(),\n        filePath: z.string(),\n        uploadedAt: z.string(),\n    }).optional(),\n});\n\nexport async function addProduct(formData: FormData) {\n  const skusJSON = formData.get('skus');\n  const skus = skusJSON ? JSON.parse(skusJSON as string) : [];\n  \n  const catalogPdfJSON = formData.get('catalogPdf');\n  const catalogPdf = catalogPdfJSON ? JSON.parse(catalogPdfJSON as string) : undefined;\n  \n  const productImageJSON = formData.get('productImage');\n  console.log('Product Image JSON received:', productImageJSON);\n  const productImage = productImageJSON ? JSON.parse(productImageJSON as string) : undefined;\n  console.log('Product Image parsed:', productImage);\n  \n  const validatedFields = ProductSchema.safeParse({\n    name: formData.get('name'),\n    price: formData.get('price'),\n    gstRate: formData.get('gstRate'),\n    categoryId: formData.get('categoryId'),\n    description: formData.get('description') || undefined,\n    skus: skus,\n    catalogueUrl: formData.get('catalogueUrl') || '',\n    cataloguePdf: catalogPdf,\n    productImage: productImage,\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Failed to add product.',\n    };\n  }\n\n  try {\n    const data = validatedFields.data;\n    // Remove undefined values before sending to Firestore\n    const cleanData = Object.fromEntries(\n      Object.entries(data).filter(([_, v]) => v !== undefined)\n    );\n    \n    console.log('Clean data being sent to database:', JSON.stringify(cleanData, null, 2));\n    \n    // Create the product\n    const newProduct = await dbAddProduct(cleanData as any);\n    \n  } catch (error) {\n    return { message: 'Database Error: Failed to add product.' };\n  }\n\n  revalidatePath('/products');\n  revalidatePath('/leads'); // Revalidate leads in case product info is needed\n  return { message: 'Successfully added product.' };\n}\n\nexport async function updateProduct(id: string, formData: FormData) {\n    const skusJSON = formData.get('skus');\n    const skus = skusJSON ? JSON.parse(skusJSON as string) : [];\n\n    const catalogPdfJSON = formData.get('catalogPdf');\n    const catalogPdf = catalogPdfJSON ? JSON.parse(catalogPdfJSON as string) : undefined;\n    const removeCatalogPdf = String(formData.get('removeCatalogPdf') || '').toLowerCase() === 'true';\n\n    // Handle product image - can be File object (new upload) or JSON string (existing metadata)\n    const productImageData = formData.get('productImage');\n    const existingProductImageJSON = formData.get('existingProductImage');\n    const removeProductImage = String(formData.get('removeProductImage') || '').toLowerCase() === 'true';\n    \n    let productImage: any = undefined;\n    \n    // If there's a new file upload, handle it\n    if (productImageData instanceof File) {\n      try {\n        const uploadResult = await uploadImageToStorage(productImageData, 'products');\n        productImage = {\n          url: uploadResult.url,\n          fileName: uploadResult.fileName,\n          filePath: uploadResult.path,\n          uploadedAt: new Date().toISOString(),\n        };\n      } catch (error) {\n        console.error('Failed to upload product image:', error);\n        return { message: 'Failed to upload product image.' };\n      }\n    } else if (existingProductImageJSON && !removeProductImage) {\n      // Keep existing image metadata\n      productImage = JSON.parse(existingProductImageJSON as string);\n    }\n\n    // Debug logs removed\n    \n    const validatedFields = ProductSchema.safeParse({\n      name: formData.get('name'),\n      price: formData.get('price'),\n      gstRate: formData.get('gstRate'),\n      categoryId: formData.get('categoryId'),\n      description: formData.get('description') || undefined,\n      skus: skus,\n      catalogueUrl: formData.get('catalogueUrl') || '',\n      cataloguePdf: catalogPdf,\n      productImage: productImage,\n    });\n\n    if (!validatedFields.success) {\n      return {\n        errors: validatedFields.error.flatten().fieldErrors,\n        message: 'Failed to update product.',\n      };\n    }\n\n    try {\n      // Get the current product to check for existing PDF\n      const currentProduct = await getProducts().then(products => \n        products.find(p => p.id === id)\n      );\n      \n      const data = validatedFields.data as any;\n      const updateData: any = { ...data };\n      \n      // If user explicitly removed the existing PDF and didn't upload a new one, clear the field\n      if (removeCatalogPdf && !catalogPdf) {\n        // Delete the old PDF from Firebase Storage if it exists\n        if (currentProduct?.cataloguePdf?.filePath) {\n          try {\n            await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n          } catch (error) {\n            console.error('Failed to delete PDF from storage:', error);\n            // Continue with the update even if PDF deletion fails\n          }\n        }\n        updateData.cataloguePdf = null; // This will clear the field in Firestore\n      } else if (catalogPdf && currentProduct?.cataloguePdf?.filePath && \n                 currentProduct.cataloguePdf.filePath !== catalogPdf.filePath) {\n        // If a new PDF was uploaded, delete the old one from storage\n        try {\n          await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n        } catch (error) {\n          console.error('Failed to delete old PDF from storage:', error);\n          // Continue with the update even if old PDF deletion fails\n        }\n      }\n      \n      // Handle product image storage cleanup if new image was uploaded\n      if (productImageData instanceof File && currentProduct?.productImage?.filePath) {\n        // Delete the old image from storage since we have a new one\n        try {\n          await deleteImageFromStorage(currentProduct.productImage.filePath);\n        } catch (error) {\n          console.error('Failed to delete old product image from storage:', error);\n          // Continue with the update even if old image deletion fails\n        }\n      }\n      \n      // Handle product image removal\n      if (removeProductImage && !productImageData) {\n        // Delete the existing image from storage\n        if (currentProduct?.productImage?.filePath) {\n          try {\n            await deleteImageFromStorage(currentProduct.productImage.filePath);\n          } catch (error) {\n            console.error('Failed to delete product image from storage:', error);\n          }\n        }\n        updateData.productImage = null; // This will clear the field in Firestore\n      }\n      \n      // Ensure new uploads are persisted\n      if (catalogPdf) {\n        updateData.cataloguePdf = catalogPdf;\n      }\n      if (productImage) {\n        updateData.productImage = productImage;\n      }\n      \n      // Remove undefined values from updateData as Firestore doesn't accept them\n      const cleanedUpdateData: any = {};\n      for (const [key, value] of Object.entries(updateData)) {\n        if (value !== undefined) {\n          cleanedUpdateData[key] = value;\n        }\n      }\n      \n      console.log('[updateProduct] cleanedUpdateData keys:', Object.keys(cleanedUpdateData));\n      console.log('[updateProduct] cleanedUpdateData.productImage:', cleanedUpdateData.productImage);\n      \n      await dbUpdateProduct(id, cleanedUpdateData);\n    } catch (error) {\n      return { message: 'Database Error: Failed to update product.' };\n    }\n\n    revalidatePath('/products');\n    revalidatePath('/leads');\n    return { message: 'Successfully updated product.' };\n  }\n  \n  export async function deleteProduct(id: string) {\n    try {\n      // Get the current product to check for PDF before deletion\n      const currentProduct = await getProducts().then(products => \n        products.find(p => p.id === id)\n      );\n      \n      // Delete the PDF from Firebase Storage if it exists\n      if (currentProduct?.cataloguePdf?.filePath) {\n        try {\n          await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n        } catch (error) {\n          console.error('Failed to delete PDF from storage:', error);\n          // Continue with product deletion even if PDF deletion fails\n        }\n      }\n      \n      await dbDeleteProduct(id);\n    } catch (error) {\n      return { message: 'Database Error: Failed to delete product.' };\n    }\n\n    revalidatePath('/products');\n    revalidatePath('/leads');\n    return { message: 'Successfully deleted product.' };\n  }\n\n\nconst LogActivitySchema = z.object({\n    leadId: z.string(),\n    type: z.enum(['Meeting', 'Call', 'Email', 'Revision Request', 'Proposal Sent']),\n    notes: z.string().optional(),\n    summary: z.string().optional(),\n});\n\nexport async function logActivity(formData: FormData) {\n    const validatedFields = LogActivitySchema.safeParse({\n        leadId: formData.get('leadId'),\n        type: formData.get('type'),\n        notes: formData.get('notes'),\n        summary: formData.get('summary') || undefined,\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to log activity.',\n        };\n    }\n\n    try {\n        const { leadId, ...activityData } = validatedFields.data;\n        await addActivityToLead(leadId, activityData);\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        console.error('LogActivity Error:', message);\n        if (message.includes('Lead not found')) {\n            return { message: 'Lead not found. Please refresh the page and try again.' };\n        }\n        return { message: 'Database Error: Failed to log activity.' };\n    }\n\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    revalidatePath('/');\n    return { message: 'Successfully logged activity.' };\n}\n\nexport async function getSummaryForNotes(notes: string): Promise<{ summary?: string; error?: string }> {\n  if (!notes || notes.trim().length < 50) {\n    return { error: 'Please provide at least 50 characters of notes to summarize.' };\n  }\n  try {\n    const result = await summarizeMeetingNotes({ notes });\n    return result;\n  } catch (e) {\n    console.error('AI Summarization Error:', e);\n    return { error: 'Failed to generate summary due to an internal error.' };\n  }\n}\n\n\nexport async function updateLeadStatusAction(leadId: string, status: LeadStatus, userId?: string, userName?: string) {\n  try {\n    // Get the current lead to capture the previous status\n    const currentLead = await dbGetLeadById(leadId);\n    if (!currentLead) {\n      return { message: 'Lead not found.' };\n    }\n    \n    const previousStatus = currentLead.status;\n    \n    // Only update if status is actually changing\n    if (previousStatus === status) {\n      return { message: 'Status is already set to this value.' };\n    }\n    \n    // Update the status\n    await updateStatus(leadId, status);\n    \n    // Add a status change activity\n    const changedBy = userName || userId || 'Unknown User';\n    const statusChangeNotes = `Status changed from \"${previousStatus}\" to \"${status}\" by ${changedBy}`;\n    \n    await addActivityToLead(leadId, {\n      type: 'Status Change',\n      notes: statusChangeNotes\n    });\n    \n  } catch (error) {\n    return { message: 'Database Error: Failed to update status.' };\n  }\n  revalidatePath(`/leads/${leadId}`);\n  revalidatePath('/leads');\n  revalidatePath('/');\n  return { message: 'Status updated successfully.' };\n}\n\nexport async function deleteLeadAction(leadId: string) {\n  try {\n    await dbDeleteLead(leadId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete lead.' };\n  }\n  revalidatePath('/leads');\n  revalidatePath('/');\n  return { message: 'Successfully deleted lead.' };\n}\n\nconst AddLeadSourceSchema = z.object({\n    name: z.string().min(2, 'Source name must be at least 2 characters'),\n});\n\nexport async function addLeadSourceAction(formData: FormData) {\n    const validatedFields = AddLeadSourceSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddLeadSource(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add lead source.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/leads');\n    return { message: `Successfully added '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteLeadSourceAction(id: string) {\n    try {\n        await dbDeleteLeadSource(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete lead source.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/leads');\n    return { message: 'Successfully deleted lead source.' };\n}\n\nconst AddProductCategorySchema = z.object({\n    name: z.string().min(2, 'Category name must be at least 2 characters'),\n    description: z.string().optional().nullable(),\n});\n\nexport async function addProductCategoryAction(formData: FormData) {\n    const validatedFields = AddProductCategorySchema.safeParse({\n        name: formData.get('name'),\n        description: formData.get('description'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        // Convert null to undefined for optional description\n        const description = validatedFields.data.description || '';\n        await dbAddProductCategory(validatedFields.data.name, description);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add product category.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: `Successfully added '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteProductCategoryAction(id: string) {\n    try {\n        await dbDeleteProductCategory(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete product category.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: 'Successfully deleted product category.' };\n}\n\n// Update an existing product category's name/description\nexport async function updateProductCategoryAction(id: string, name: string, description?: string) {\n    try {\n        await dbUpdateProductCategory(id, name, description || '');\n    } catch (error) {\n        const message = error instanceof Error ? error.message : 'Unknown error';\n        return { message: `Database Error: Failed to update product category. ${message}` };\n    }\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: 'Successfully updated product category.' };\n}\n\nexport async function getProductCategoriesAction() {\n    try {\n        const categories = await getProductCategories();\n        return categories;\n    } catch (error) {\n        console.error('Error fetching product categories:', error);\n        return [];\n    }\n}\n\n\nconst CreateQuotationSchema = z.object({\n  leadId: z.string().min(1),\n  templateId: z.string().min(1),\n  date: z.string(),\n  validUntil: z.string(),\n  status: z.enum(['Draft', 'Sent', 'Accepted', 'Rejected']),\n  products: z.string(), // JSON string\n  subTotal: z.coerce.number(),\n  totalGst: z.coerce.number(),\n  grandTotal: z.coerce.number(),\n  quotationPrefix: z.string().optional(),\n  // Overridable template fields\n  companyName: z.string().min(1),\n  companyAddress: z.string().min(1),\n  companyGst: z.string().optional().or(z.literal('')).nullable(),\n  // Client billing fields\n  client_address: z.string().optional().or(z.literal('')).nullable(),\n  client_gst_no: z.string().optional().or(z.literal('')).nullable(),\n  termsAndConditions: z.string(),\n  logoUrl: z.string().optional().nullable(),\n  // Additional charges (numeric or empty/null)\n  freightCharges: z.coerce.number().min(0).optional().or(z.literal('')).nullable(),\n  courierCharges: z.coerce.number().min(0).optional().or(z.literal('')).nullable(),\n  // Flags to show/hide charges in PDF\n  showFreight: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return false; // default to false\n  }, z.boolean()).optional(),\n  showCourier: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return false; // default to false\n  }, z.boolean()).optional(),\n  // GST visibility control\n  showGst: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return true; // default to true for backward compatibility\n  }, z.boolean()).optional(),\n  // Currency fields\n  currencyCode: z.string().optional(),\n  currencySymbol: z.string().optional(),\n  conversionRate: z.coerce.number().optional(),\n});\n\n\nexport async function addQuotation(formData: FormData) {\n    console.log('Server received quotationPrefix:', formData.get('quotationPrefix'));\n    const validatedFields = CreateQuotationSchema.safeParse({\n        leadId: formData.get('leadId'),\n        templateId: formData.get('templateId'),\n        date: formData.get('date'),\n        validUntil: formData.get('validUntil'),\n        status: formData.get('status'),\n        products: formData.get('products'),\n        subTotal: formData.get('subTotal'),\n        totalGst: formData.get('totalGst'),\n        grandTotal: formData.get('grandTotal'),\n        quotationPrefix: formData.get('quotationPrefix') || '',\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        client_address: formData.get('client_address'),\n        client_gst_no: formData.get('client_gst_no'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n        freightCharges: formData.get('freightCharges'),\n        courierCharges: formData.get('courierCharges'),\n        showFreight: formData.get('showFreight'),\n        showCourier: formData.get('showCourier'),\n        showGst: formData.get('showGst'),\n        currencyCode: formData.get('currencyCode'),\n        currencySymbol: formData.get('currencySymbol'),\n        conversionRate: formData.get('conversionRate'),\n      });\n    \n      if (!validatedFields.success) {\n        console.error(validatedFields.error.flatten().fieldErrors);\n        return {\n          errors: validatedFields.error.flatten().fieldErrors,\n          message: 'Validation Error: Failed to create quotation.',\n        };\n      }\n      \n      let newQuotation: Quotation | undefined;\n      try {\n        const data = validatedFields.data;\n        const parsedProducts = JSON.parse(data.products);\n        const prefix = (data.quotationPrefix?.trim() || 'QUO');\n        console.log('Using prefix:', prefix);\n        const { quotationPrefix: _omitPrefix, logoUrl, ...rest } = data as any;\n        \n        // Clean up null values - convert to undefined for Firestore\n        const payload: any = {\n          ...rest,\n          products: parsedProducts,\n          companyGst: rest.companyGst || undefined,\n          client_address: rest.client_address || undefined,\n          client_gst_no: rest.client_gst_no || undefined,\n          freightCharges: rest.freightCharges || undefined,\n          courierCharges: rest.courierCharges || undefined,\n          showFreight: rest.showFreight === true || rest.showFreight === 'true',\n          showCourier: rest.showCourier === true || rest.showCourier === 'true',\n        };\n        if (logoUrl) payload.logoUrl = logoUrl;\n        newQuotation = await dbAddQuotation(payload, prefix);\n\n        // Log activity on the lead\n        await addActivityToLead(data.leadId, {\n            type: 'Proposal Sent',\n            notes: `Quotation ${newQuotation.quotationNumber} was created and sent.`\n        });\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return { message: `Database Error: Failed to Create Quotation. ${message}` };\n      }\n\n    revalidatePath('/quotations');\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    return { message: 'Successfully created quotation.' };\n}\n\nexport async function updateQuotation(id: string, formData: FormData) {\n    const validatedFields = CreateQuotationSchema.safeParse({\n        leadId: formData.get('leadId'),\n        templateId: formData.get('templateId'),\n        date: formData.get('date'),\n        validUntil: formData.get('validUntil'),\n        status: formData.get('status'),\n        products: formData.get('products'),\n        subTotal: formData.get('subTotal'),\n        totalGst: formData.get('totalGst'),\n        grandTotal: formData.get('grandTotal'),\n        quotationPrefix: formData.get('quotationPrefix') || '',\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        client_address: formData.get('client_address'),\n        client_gst_no: formData.get('client_gst_no'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n        freightCharges: formData.get('freightCharges'),\n        courierCharges: formData.get('courierCharges'),\n        showFreight: formData.get('showFreight'),\n        showCourier: formData.get('showCourier'),\n        showGst: formData.get('showGst'),\n        currencyCode: formData.get('currencyCode'),\n        currencySymbol: formData.get('currencySymbol'),\n        conversionRate: formData.get('conversionRate'),\n      });\n    \n      if (!validatedFields.success) {\n        console.error(validatedFields.error.flatten().fieldErrors);\n        return {\n          errors: validatedFields.error.flatten().fieldErrors,\n          message: 'Validation Error: Failed to update quotation.',\n        };\n      }\n      \n      try {\n        const data = validatedFields.data;\n        const parsedProducts = JSON.parse(data.products);\n        \n        // Clean up null values - convert to undefined for Firestore\n        await dbUpdateQuotation(id, {\n            ...data,\n            logoUrl: data.logoUrl || undefined,\n            companyGst: data.companyGst || undefined,\n            client_address: data.client_address || undefined,\n            client_gst_no: data.client_gst_no || undefined,\n            freightCharges: data.freightCharges || undefined,\n            courierCharges: data.courierCharges || undefined,\n            showFreight: data.showFreight === true || data.showFreight === 'true',\n            showCourier: data.showCourier === true || data.showCourier === 'true',\n            products: parsedProducts,\n        });\n\n        // Log activity on the lead\n        await addActivityToLead(data.leadId, {\n            type: 'Revision Request',\n            notes: `Quotation was updated.`\n        });\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return { message: `Database Error: Failed to Update Quotation. ${message}` };\n      }\n\n    revalidatePath('/quotations');\n    revalidatePath(`/quotations/${id}`);\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    return { message: 'Successfully updated quotation.' };\n}\n\nexport async function deleteQuotationAction(quotationId: string) {\n  try {\n    await dbDeleteQuotation(quotationId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete quotation.' };\n  }\n  revalidatePath('/quotations');\n  revalidatePath('/');\n  return { message: 'Successfully deleted quotation.' };\n}\n\n\nconst QuotationTemplateSchema = z.object({\n    name: z.string().min(3, 'Template name must be at least 3 characters.'),\n    prefix: z.string().min(1, 'Prefix is required.'),\n    companyName: z.string().min(3, 'Company name is required.'),\n    companyAddress: z.string().min(10, 'Full company address is required.'),\n    companyGst: z.string().min(15, 'A valid GSTIN is required.').max(15),\n    termsAndConditions: z.string().min(20, 'Terms and conditions are required.'),\n    logoUrl: z.string().url('Please enter a valid URL for the logo.').optional().or(z.literal('')),\n});\n\nexport async function addQuotationTemplateAction(formData: FormData) {\n    const validatedFields = QuotationTemplateSchema.safeParse({\n        name: formData.get('name'),\n        prefix: formData.get('prefix'),\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to create template. Please check the fields.',\n        };\n    }\n\n    try {\n        await dbAddQuotationTemplate(validatedFields.data as NewQuotationTemplate);\n    } catch (error) {\n        return { message: 'Database Error: Failed to create template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully created quotation template.' };\n}\n\nexport async function updateQuotationTemplateAction(id: string, formData: FormData) {\n    const validatedFields = QuotationTemplateSchema.safeParse({\n        name: formData.get('name'),\n        prefix: formData.get('prefix'),\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to update template. Please check the fields.',\n        };\n    }\n\n    try {\n        await dbUpdateQuotationTemplate(id, validatedFields.data as QuotationTemplate);\n    } catch (error) {\n        return { message: 'Database Error: Failed to update template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully updated quotation template.' };\n}\n\nexport async function deleteQuotationTemplateAction(id: string) {\n    try {\n        await dbDeleteQuotationTemplate(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully deleted quotation template.' };\n}\n\n\nconst AddEmployeeSchema = z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters.'),\n    email: z.string().email('Please enter a valid email.'),\n    phone: z.string().min(10, 'Please enter a valid phone number.'),\n    role: z.string({\n      required_error: \"You need to select a role.\",\n    }),\n    department: z.string({\n        required_error: \"You need to select a department.\",\n    }),\n    address: z.string().min(10, 'Address is required.'),\n});\n\nexport async function addEmployeeAction(formData: FormData) {\n    const validatedFields = AddEmployeeSchema.safeParse({\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        role: formData.get('role'),\n        department: formData.get('department'),\n        address: formData.get('address'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to add employee.',\n        };\n    }\n\n    const [employeeRoles, departments] = await Promise.all([\n        getEmployeeRoles(),\n        getDepartments(),\n    ]);\n\n    const roleExists = employeeRoles.some(r => r.name === validatedFields.data.role);\n    if (!roleExists) {\n        return { message: 'Invalid role selected.' };\n    }\n    const departmentExists = departments.some(d => d.name === validatedFields.data.department);\n    if (!departmentExists) {\n        return { message: 'Invalid department selected.' };\n    }\n\n    try {\n        // Check if Firebase Admin environment variables are configured\n        const requiredEnvVars = ['FIREBASE_PROJECT_ID', 'FIREBASE_PRIVATE_KEY', 'FIREBASE_CLIENT_EMAIL'];\n        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n        \n        if (missingVars.length > 0) {\n            console.warn(`Firebase Admin not configured. Missing: ${missingVars.join(', ')}`);\n            // Just add to database without Firebase Auth integration\n            await dbAddEmployee(validatedFields.data as NewEmployee);\n            revalidatePath('/employees');\n            return { \n                message: 'Employee added to database. Note: Firebase Auth integration requires environment variables to be configured for automatic account creation and email sending.'\n            };\n        }\n\n        // Initialize Firebase Admin\n        initializeFirebaseAdmin();\n        const auth = getAuth();\n\n        // Create user in Firebase Auth\n        const userRecord = await auth.createUser({\n            email: validatedFields.data.email,\n            displayName: validatedFields.data.name,\n            emailVerified: false,\n        });\n\n        // Add employee to database first\n        await dbAddEmployee(validatedFields.data as NewEmployee);\n\n        // Set a temporary password for the user\n        const tempPassword = Math.random().toString(36).slice(-12) + 'A1!'; // Ensure it meets Firebase requirements\n        \n        // Update the user with the temporary password\n        await auth.updateUser(userRecord.uid, {\n            password: tempPassword,\n        });\n\n        // Send password reset email using Firebase Auth's REST API\n        try {\n            const webApiKey = process.env.FIREBASE_WEB_API_KEY;\n            \n            if (!webApiKey) {\n                throw new Error('FIREBASE_WEB_API_KEY not configured');\n            }\n\n            // Use Firebase Auth REST API to send password reset email\n            const response = await fetch(`https://identitytoolkit.googleapis.com/v1/accounts:sendOobCode?key=${webApiKey}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    requestType: 'PASSWORD_RESET',\n                    email: validatedFields.data.email,\n                    continueUrl: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/login`,\n                }),\n            });\n\n            if (response.ok) {\n                const responseData = await response.json();\n                console.log('='.repeat(80));\n                console.log(`‚úÖ EMPLOYEE CREATED: ${validatedFields.data.name}`);\n                console.log(`üìß Email: ${validatedFields.data.email}`);\n                console.log(`üì® Password reset email sent successfully!`);\n                console.log(`üì¨ Email will be delivered by Firebase Auth`);\n                console.log('='.repeat(80));\n\n                revalidatePath('/employees');\n                return { \n                    message: `Successfully added employee ${validatedFields.data.name}. Password reset email has been sent to ${validatedFields.data.email}.`,\n                };\n            } else {\n                const errorData = await response.json();\n                console.error('Failed to send password reset email:', errorData);\n                throw new Error(`Email sending failed: ${errorData.error?.message || 'Unknown error'}`);\n            }\n        } catch (emailError) {\n            console.error('Error sending password reset email:', emailError);\n            \n            // Fallback: generate link for manual sharing\n            const resetLink = await auth.generatePasswordResetLink(validatedFields.data.email, {\n                url: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/login`,\n                handleCodeInApp: false,\n            });\n\n            console.log('='.repeat(80));\n            console.log(`‚úÖ EMPLOYEE CREATED: ${validatedFields.data.name}`);\n            console.log(`üìß Email: ${validatedFields.data.email}`);\n            console.log(`‚ùå Email sending failed: ${emailError.message}`);\n            console.log(`üîó Manual Reset Link: ${resetLink}`);\n            console.log(`üìù Please share this link with the employee`);\n            console.log('='.repeat(80));\n\n            revalidatePath('/employees');\n            return { \n                message: `Successfully added employee ${validatedFields.data.name}. Email sending failed - please share the reset link manually (check console).`,\n                resetLink: resetLink\n            };\n        }\n    } catch (error: any) {\n        console.error('Error adding employee:', error);\n        \n        // Handle specific Firebase errors\n        if (error.code === 'auth/email-already-exists') {\n            return { message: 'An account with this email already exists.' };\n        }\n        \n        if (error.message?.includes('Missing required Firebase environment variables')) {\n            // Fallback: add to database only\n            try {\n                await dbAddEmployee(validatedFields.data as NewEmployee);\n                revalidatePath('/employees');\n                return { \n                    message: 'Employee added to database. Firebase Auth integration requires proper environment configuration for automatic account creation.'\n                };\n            } catch (dbError) {\n                return { message: 'Failed to add employee to database.' };\n            }\n        }\n        \n        return { message: 'Failed to add employee. Please check Firebase configuration and try again.' };\n    }\n}\n\nexport async function deleteEmployeeAction(employeeId: string) {\n  try {\n    await dbDeleteEmployee(employeeId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete employee.' };\n  }\n  revalidatePath('/employees');\n  revalidatePath('/');\n  return { message: 'Successfully deleted employee.' };\n}\n\nconst UpdateEmployeeSchema = z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters.'),\n    email: z.string().email('Please enter a valid email.'),\n    phone: z.string().min(10, 'Please enter a valid phone number.'),\n    role: z.string(),\n    department: z.string(),\n    address: z.string().min(10, 'Address is required.'),\n});\n\nexport async function updateEmployeeAction(id: string, formData: FormData) {\n    const validatedFields = UpdateEmployeeSchema.safeParse({\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        role: formData.get('role'),\n        department: formData.get('department'),\n        address: formData.get('address'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to update employee.',\n        };\n    }\n\n    try {\n        await dbUpdateEmployee(id, validatedFields.data as NewEmployee);\n    } catch (error) {\n        return { message: 'Database Error: Failed to update employee.' };\n    }\n\n    revalidatePath('/employees');\n    revalidatePath('/');\n    return { message: 'Successfully updated employee.' };\n}\n\n\nconst AddEmployeeRoleSchema = z.object({\n    name: z.string().min(2, 'Role name must be at least 2 characters'),\n});\n\nexport async function addEmployeeRoleAction(formData: FormData) {\n    const validatedFields = AddEmployeeRoleSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddEmployeeRole(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add role.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: `Successfully added role '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteEmployeeRoleAction(id: string) {\n    try {\n        await dbDeleteEmployeeRole(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete role.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: 'Successfully deleted role.' };\n}\n\nconst AddDepartmentSchema = z.object({\n    name: z.string().min(2, 'Department name must be at least 2 characters'),\n});\n\nexport async function addDepartmentAction(formData: FormData) {\n    const validatedFields = AddDepartmentSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddDepartment(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add department.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: `Successfully added department '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteDepartmentAction(id: string) {\n    try {\n        await dbDeleteDepartment(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete department.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: 'Successfully deleted department.' };\n}\n\n// CSV Import Actions\nconst ImportProductSchema = z.object({\n    name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n    price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n    gstRate: z.coerce.number().min(0).max(100),\n    skus: z.array(z.string()).optional(),\n    catalogueUrl: z.string().url('Please enter a valid URL.').optional().or(z.literal('')),\n});\n\nexport async function importProductsFromCSV(csvData: any[]) {\n    const results = {\n        success: 0,\n        failed: 0,\n        errors: [] as string[]\n    };\n\n// Get all existing product categories to match against\nconst allCategories = await getProductCategories();\n\n    for (let i = 0; i < csvData.length; i++) {\n        const row = csvData[i];\n        \n        try {\n            // Parse SKUs from comma-separated string\n            const skus = row.skus ? row.skus.split(',').map((sku: string) => sku.trim()).filter(Boolean) : [];\n            \n// Match category by exact name (single category)\nlet categoryId: string | undefined = undefined;\nconst categoryName = (row.category || row.categories || '').toString().trim();\nif (categoryName) {\n    const existingCategory = allCategories.find((c) => c.name === categoryName);\n    if (existingCategory) {\n        categoryId = existingCategory.id;\n    } else {\n        results.errors.push(`Row ${i + 1}: Category not found: ${categoryName}. Please create this category first.`);\n    }\n}\n            \n// Prepare data for validation, including optional fields\n            const dataForValidation = {\n                name: row.name,\n                price: row.price,\n                gstRate: row.gstRate,\n                ...(skus.length > 0 && { skus }),\n                ...(row.catalogueUrl && row.catalogueUrl.trim() && { catalogueUrl: row.catalogueUrl }),\n            };\n\n            const validatedData = ImportProductSchema.parse(dataForValidation);\n\n            // Prepare data for database - only include defined fields\nconst productData = {\n    name: validatedData.name,\n    price: validatedData.price,\n    gstRate: validatedData.gstRate,\n    ...(validatedData.skus && { skus: validatedData.skus }),\n    ...(validatedData.catalogueUrl && { catalogueUrl: validatedData.catalogueUrl }),\n    ...(categoryId && { categoryId }),\n};\n\n            await dbAddProduct(productData);\n            \n            results.success++;\n        } catch (error) {\n            results.failed++;\n            if (error instanceof z.ZodError) {\n                const errorMessages = error.errors.map(e => `Row ${i + 1}: ${e.path.join('.')} - ${e.message}`);\n                results.errors.push(...errorMessages);\n            } else {\n                results.errors.push(`Row ${i + 1}: Failed to import product - ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        }\n    }\n\n    // Revalidate pages after import\n    revalidatePath('/products');\n    revalidatePath('/leads');\n\n    return {\n        success: results.failed === 0,\n        message: `Import completed. ${results.success} products imported successfully${results.failed > 0 ? `, ${results.failed} failed` : ''}.`,\n        errors: results.errors.length > 0 ? results.errors : undefined\n    };\n}\n\n// Count Actions\nexport async function getLeadsCountAction(): Promise<number> {\n    try {\n        return await getLeadsCount();\n    } catch (error) {\n        console.error('Error getting leads count:', error);\n        return 0;\n    }\n}\n\nexport async function getQuotationsCountAction(): Promise<number> {\n    try {\n        return await getQuotationsCount();\n    } catch (error) {\n        console.error('Error getting quotations count:', error);\n        return 0;\n    }\n}\n\nexport async function getProductsCountAction(): Promise<number> {\n    try {\n        return await getProductsCount();\n    } catch (error) {\n        console.error('Error getting products count:', error);\n        return 0;\n    }\n}\n\nexport async function getEmployeesCountAction(): Promise<number> {\n    try {\n        return await getEmployeesCount();\n    } catch (error) {\n        console.error('Error getting employees count:', error);\n        return 0;\n    }\n}\n\nexport async function getLeadsCountByStatusAction(status: LeadStatus): Promise<number> {\n    try {\n        return await getLeadsCountByStatus(status);\n    } catch (error) {\n        console.error(`Error getting leads count for status ${status}:`, error);\n        return 0;\n    }\n}\n\nexport async function getQuotationsCountByStatusAction(status: 'Draft' | 'Sent' | 'Accepted' | 'Rejected'): Promise<number> {\n    try {\n        return await getQuotationsCountByStatus(status);\n    } catch (error) {\n        console.error(`Error getting quotations count for status ${status}:`, error);\n        return 0;\n    }\n}\n\nexport async function getActiveProductsCountAction(): Promise<number> {\n    try {\n        return await getActiveProductsCount();\n    } catch (error) {\n        console.error('Error getting active products count:', error);\n        return 0;\n    }\n}\n\nexport async function getActiveEmployeesCountAction(): Promise<number> {\n    try {\n        return await getActiveEmployeesCount();\n    } catch (error) {\n        console.error('Error getting active employees count:', error);\n        return 0;\n    }\n}\n\n// Communication Activity Actions\nconst CommunicationActivitySchema = z.object({\n  leadId: z.string().min(1, 'Lead ID is required'),\n  type: z.enum(['WhatsApp', 'Email']),\n  message: z.string().min(1, 'Message is required'),\n  contact: z.string().min(1, 'Contact is required'),\n  sentBy: z.string().min(1, 'Sent by is required'),\n});\n\nexport async function logCommunicationActivityAction(formData: FormData) {\n  const validatedFields = CommunicationActivitySchema.safeParse({\n    leadId: formData.get('leadId'),\n    type: formData.get('type'),\n    message: formData.get('message'),\n    contact: formData.get('contact'),\n    sentBy: formData.get('sentBy'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Missing Fields. Failed to log communication activity.',\n    };\n  }\n\n  const { leadId, type, message, contact, sentBy } = validatedFields.data;\n\n  try {\n    const activityNotes = `${type} message sent to ${contact} by ${sentBy}:\\n\\n\"${message}\"`;\n    \n    await addActivityToLead(leadId, {\n      type: type as 'WhatsApp' | 'Email',\n      notes: activityNotes\n    });\n  } catch (error) {\n    const errMsg = error instanceof Error ? error.message : String(error);\n    console.error('LogCommunicationActivity Error:', errMsg);\n    if (errMsg.includes('Lead not found')) {\n      return { message: 'Lead not found. Please refresh the page and try again.' };\n    }\n    return { message: 'Database Error: Failed to log communication activity.' };\n  }\n\n  return { message: `Successfully logged ${type} communication.` };\n}\n\nexport async function getCurrentUserEmployeeAction(email: string): Promise<Employee | null> {\n    try {\n        return await getEmployeeByEmail(email);\n    } catch (error) {\n        console.error('Error getting current user employee:', error);\n        return null;\n    }\n}\n\n// ==================== Currency Actions ====================\nimport { addCurrency as dbAddCurrency, updateCurrency as dbUpdateCurrency, deleteCurrency as dbDeleteCurrency } from './firestore-service';\n\nconst CurrencySchema = z.object({\n  code: z.string().min(2, 'Currency code must be at least 2 characters').max(5, 'Currency code must be at most 5 characters'),\n  name: z.string().min(2, 'Currency name is required'),\n  symbol: z.string().min(1, 'Currency symbol is required'),\n  conversionRate: z.coerce.number().positive('Conversion rate must be positive'),\n});\n\nexport async function addCurrencyAction(formData: FormData) {\n  const validatedFields = CurrencySchema.safeParse({\n    code: formData.get('code'),\n    name: formData.get('name'),\n    symbol: formData.get('symbol'),\n    conversionRate: formData.get('conversionRate'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Validation Error: Failed to add currency.',\n    };\n  }\n\n  try {\n    await dbAddCurrency(validatedFields.data);\n  } catch (error) {\n    return { message: 'Database Error: Failed to add currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully added currency.' };\n}\n\nexport async function updateCurrencyAction(id: string, formData: FormData) {\n  const validatedFields = CurrencySchema.safeParse({\n    code: formData.get('code'),\n    name: formData.get('name'),\n    symbol: formData.get('symbol'),\n    conversionRate: formData.get('conversionRate'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Validation Error: Failed to update currency.',\n    };\n  }\n\n  try {\n    await dbUpdateCurrency(id, validatedFields.data);\n  } catch (error) {\n    return { message: 'Database Error: Failed to update currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully updated currency.' };\n}\n\nexport async function deleteCurrencyAction(id: string) {\n  try {\n    await dbDeleteCurrency(id);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully deleted currency.' };\n}\n\n"],"names":[],"mappings":";;;;;;IAgqBsB,6BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 1356, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/products/add-product-sheet.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useEffect } from 'react';\nimport { useForm, useFieldArray, Controller } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { PlusCircle, Trash2, X } from 'lucide-react';\n\nimport { Button } from '@/components/ui/button';\nimport {\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetFooter,\n  SheetHeader,\n  SheetTitle,\n  SheetTrigger,\n} from '@/components/ui/sheet';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Textarea } from '@/components/ui/textarea';\nimport { addProduct } from '@/lib/actions';\nimport { useToast } from '@/hooks/use-toast';\nimport { Badge } from '@/components/ui/badge';\nimport { PDFUpload } from '@/components/pdf-upload';\nimport { ImageUpload } from '@/components/image-upload';\nimport { UploadResult, deletePDF, deleteImageFromStorage } from '@/lib/storage-utils';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { getProductCategoriesAction } from '@/lib/actions';\nimport { ProductCategory } from '@/lib/types';\n\nconst productSchema = z.object({\n  name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n  price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n  gstRate: z.coerce.number().min(0, { message: 'GST rate must be a positive number.' }).max(100, { message: 'GST rate cannot exceed 100.' }),\n  categoryId: z.string().optional(),\n  description: z.string().optional(),\n  skus: z.array(z.object({ value: z.string().min(1, \"SKU cannot be empty.\") })).optional(),\n});\n\ntype ProductFormData = z.infer<typeof productSchema>;\n\nexport function AddProductSheet() {\n  const [open, setOpen] = useState(false);\n  const [currentSku, setCurrentSku] = useState('');\n  const [availableCategories, setAvailableCategories] = useState<ProductCategory[]>([]);\n  const [selectedCategoryId, setSelectedCategoryId] = useState<string | undefined>(undefined);\n  const [catalogPdf, setCatalogPdf] = useState<UploadResult | null>(null);\n  const [pdfError, setPdfError] = useState<string>('');\n  const [productImage, setProductImage] = useState<UploadResult | null>(null);\n  const [imageError, setImageError] = useState<string>('');\n  const [isImageUploading, setIsImageUploading] = useState(false);\n  const { toast } = useToast();\n  const { register, handleSubmit, reset, control, setValue, formState: { errors, isSubmitting } } = useForm<ProductFormData>({\n    resolver: zodResolver(productSchema),\n    defaultValues: {\n      skus: [],\n      categoryId: undefined,\n      description: '',\n    },\n  });\n  \n  const { fields: skuFields, append: appendSku, remove: removeSku } = useFieldArray({\n    control,\n    name: \"skus\"\n  });\n\n// Fetch available categories when component opens\nuseEffect(() => {\n  if (open) {\n    const fetchCategories = async () => {\n      try {\n        const categories = await getProductCategoriesAction();\n        setAvailableCategories(categories);\n      } catch (error) {\n        console.error('Error fetching categories:', error);\n      }\n    };\n    fetchCategories();\n  }\n}, [open]);\n\n\n  const handleAddSku = () => {\n    if (currentSku.trim() !== '') {\n      appendSku({ value: currentSku.trim() });\n      setCurrentSku('');\n    }\n  };\n\n\n  const onSubmit = async (data: ProductFormData) => {\n    console.log('Form submission - productImage state:', productImage);\n    console.log('Form submission - catalogPdf state:', catalogPdf);\n    \n    const formData = new FormData();\n    Object.entries(data).forEach(([key, value]) => {\n      if (key === 'skus') {\n        formData.append(key, JSON.stringify((value as {value: string}[]).map(s => s.value)));\n      } else if (key === 'categoryId') {\n        if (selectedCategoryId) formData.append('categoryId', selectedCategoryId);\n      } else if (value) {\n        formData.append(key, String(value));\n      }\n    });\n\n    // Add catalog PDF data if available (only send URL + metadata)\n    if (catalogPdf) {\n      console.log('Adding catalogPdf to formData');\n      formData.append('catalogPdf', JSON.stringify({\n        url: catalogPdf.url,\n        fileName: catalogPdf.fileName,\n        filePath: catalogPdf.path,\n        uploadedAt: new Date().toISOString()\n      }));\n    }\n\n    // Add product image data if available\n    if (productImage) {\n      console.log('Adding productImage to formData');\n      formData.append('productImage', JSON.stringify({\n        url: productImage.url,\n        fileName: productImage.fileName,\n        filePath: productImage.path,\n        uploadedAt: new Date().toISOString()\n      }));\n    } else {\n      console.log('productImage is null/undefined, not adding to formData');\n    }\n\n    const result = await addProduct(formData);\n\n    if (result.message === 'Successfully added product.') {\n      toast({\n        title: 'Product Added',\n        description: `\"${data.name}\" has been successfully added.`,\n      });\n      reset();\n      setCurrentSku('');\n      setSelectedCategoryId(undefined);\n      setCatalogPdf(null);\n      setPdfError('');\n      setProductImage(null);\n      setImageError('');\n      setOpen(false);\n    } else {\n        // If product creation failed and we uploaded files, clean them up\n        if (catalogPdf) {\n          try {\n            await deletePDF(catalogPdf.path);\n          } catch (error) {\n            console.error('Failed to cleanup uploaded PDF:', error);\n          }\n        }\n        if (productImage) {\n          try {\n            await deleteImageFromStorage(productImage.path);\n          } catch (error) {\n            console.error('Failed to cleanup uploaded image:', error);\n          }\n        }\n        toast({\n            variant: 'destructive',\n            title: 'Error',\n            description: result.message,\n        });\n    }\n  };\n\n  return (\n    <Sheet open={open} onOpenChange={setOpen}>\n      <SheetTrigger asChild>\n        <Button>\n          <PlusCircle className=\"mr-2 h-4 w-4\" />\n          Add Product\n        </Button>\n      </SheetTrigger>\n      <SheetContent className=\"sm:max-w-xl\">\n        <SheetHeader>\n          <SheetTitle>Add a New Product</SheetTitle>\n          <SheetDescription>\n            Fill in the details below to add a new product or service.\n          </SheetDescription>\n        </SheetHeader>\n        <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-4 py-6 max-h-[90vh] overflow-y-auto pr-6\">\n          <div>\n            <Label htmlFor=\"name\">Product Name</Label>\n            <Input id=\"name\" {...register('name')} className={errors.name ? 'border-destructive' : ''} />\n            {errors.name && <p className=\"text-xs text-destructive mt-1\">{errors.name.message}</p>}\n          </div>\n          <div>\n            <Label htmlFor=\"description\">Description</Label>\n            <Textarea id=\"description\" rows={3} placeholder=\"Optional product description\" {...register('description')} />\n          </div>\n          <div className=\"space-y-2\">\n            <Label>Product Category</Label>\n            <Controller\n              control={control}\n              name=\"categoryId\"\n              render={({ field }) => (\n                <Select onValueChange={(val) => { field.onChange(val); setSelectedCategoryId(val); }} value={field.value}>\n                  <SelectTrigger>\n                    <SelectValue placeholder=\"Select a category...\" />\n                  </SelectTrigger>\n                  <SelectContent>\n                    {availableCategories.map(cat => (\n                      <SelectItem key={cat.id} value={cat.id}>{cat.name}</SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              )}\n            />\n            {errors.categoryId && <p className=\"text-xs text-destructive mt-1\">{errors.categoryId.message}</p>}\n          </div>\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div>\n                <Label htmlFor=\"price\">Price (‚Çπ)</Label>\n                <Input id=\"price\" type=\"number\" step=\"0.01\" {...register('price')} className={errors.price ? 'border-destructive' : ''} />\n                {errors.price && <p className=\"text-xs text-destructive mt-1\">{errors.price.message}</p>}\n            </div>\n            <div>\n                <Label htmlFor=\"gstRate\">GST Rate (%)</Label>\n                <Input id=\"gstRate\" type=\"number\" step=\"0.01\" {...register('gstRate')} className={errors.gstRate ? 'border-destructive' : ''} />\n                {errors.gstRate && <p className=\"text-xs text-destructive mt-1\">{errors.gstRate.message}</p>}\n            </div>\n          </div>\n          <div>\n            <PDFUpload\n              onUploadComplete={(result) => {\n                setCatalogPdf(result);\n                setPdfError('');\n              }}\n              onUploadError={(error) => {\n                setPdfError(error);\n                setCatalogPdf(null);\n              }}\n              currentPdf={catalogPdf ? {\n                url: catalogPdf.url,\n                fileName: catalogPdf.fileName,\n                filePath: catalogPdf.path\n              } : null}\n              onRemove={async () => {\n                if (catalogPdf) {\n                  try {\n                    await deletePDF(catalogPdf.path);\n                    setCatalogPdf(null);\n                    setPdfError('');\n                  } catch (error) {\n                    setPdfError('Failed to remove PDF');\n                  }\n                }\n              }}\n              label=\"Catalog PDF\"\n              description=\"Upload product catalog (max 10MB)\"\n            />\n            {pdfError && <p className=\"text-xs text-destructive mt-1\">{pdfError}</p>}\n          </div>\n          <div>\n            <ImageUpload\n              onUploadComplete={(result) => {\n                console.log('ImageUpload onUploadComplete called with:', result);\n                setProductImage(result);\n                setIsImageUploading(false);\n                console.log('productImage state should now be:', result);\n                setImageError('');\n              }}\n              onUploadError={(error) => {\n                console.log('ImageUpload onUploadError called with:', error);\n                setImageError(error);\n                setProductImage(null);\n                setIsImageUploading(false);\n              }}\n              onFileSelect={() => {\n                console.log('Image upload started');\n                setIsImageUploading(true);\n              }}\n              currentImage={productImage ? {\n                url: productImage.url,\n                fileName: productImage.fileName,\n                filePath: productImage.path\n              } : null}\n              onRemove={async () => {\n                if (productImage) {\n                  try {\n                    await deleteImageFromStorage(productImage.path);\n                    setProductImage(null);\n                    setImageError('');\n                  } catch (error) {\n                    setImageError('Failed to remove image');\n                  }\n                }\n              }}\n              label=\"Product Image\"\n              description=\"Upload product image (max 10MB)\"\n            />\n            {imageError && <p className=\"text-xs text-destructive mt-1\">{imageError}</p>}\n          </div>\n          <div className=\"space-y-2\">\n            <Label>SKUs</Label>\n            <div className=\"flex items-center gap-2\">\n              <Input\n                value={currentSku}\n                onChange={(e) => setCurrentSku(e.target.value)}\n                placeholder=\"Enter SKU and press Add\"\n              />\n              <Button type=\"button\" variant=\"outline\" onClick={handleAddSku}>\n                Add\n              </Button>\n            </div>\n            <div className=\"flex flex-wrap gap-2 pt-2\">\n              {skuFields.map((field, index) => (\n                <Badge key={field.id} variant=\"secondary\">\n                  {field.value}\n                  <button\n                    type=\"button\"\n                    className=\"ml-2 rounded-full outline-none ring-offset-background focus:ring-2 focus:ring-ring focus:ring-offset-2\"\n                    onClick={() => removeSku(index)}\n                  >\n                    <X className=\"h-3 w-3 text-muted-foreground hover:text-foreground\" />\n                  </button>\n                </Badge>\n              ))}\n            </div>\n            {errors.skus && <p className=\"text-xs text-destructive mt-1\">{errors.skus.message}</p>}\n          </div>\n          <SheetFooter className=\"pt-4 sticky bottom-0 bg-background\">\n            <Button type=\"submit\" disabled={isSubmitting || isImageUploading} className=\"w-full\">\n              {isImageUploading ? 'Uploading Image...' : isSubmitting ? 'Adding Product...' : 'Add Product'}\n            </Button>\n          </SheetFooter>\n        </form>\n      </SheetContent>\n    </Sheet>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2034, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,SAAS,kKAAA,CAAA,OAAoB;AAEnC,MAAM,gBAAgB,kKAAA,CAAA,UAAuB;AAE7C,MAAM,eAAe,kKAAA,CAAA,SAAsB;AAE3C,MAAM,cAAc,kKAAA,CAAA,QAAqB;AAEzC,MAAM,8BAAgB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGnC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,kKAAA,CAAA,UAAuB;QACtB,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,0JACA;QAED,GAAG,KAAK;;;;;;AAGb,cAAc,WAAW,GAAG,kKAAA,CAAA,UAAuB,CAAC,WAAW;AAE/D,MAAM,8BAAgB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGnC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,8OAAC;;0BACC,8OAAC;;;;;0BACD,8OAAC,kKAAA,CAAA,UAAuB;gBACtB,KAAK;gBACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,+fACA;gBAED,GAAG,KAAK;;oBAER;kCACD,8OAAC,kKAAA,CAAA,QAAqB;wBAAC,WAAU;;0CAC/B,8OAAC,4LAAA,CAAA,IAAC;gCAAC,WAAU;;;;;;0CACb,8OAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAKlC,cAAc,WAAW,GAAG,kKAAA,CAAA,UAAuB,CAAC,WAAW;AAE/D,MAAM,eAAe,CAAC,EACpB,SAAS,EACT,GAAG,OACkC,iBACrC,8OAAC;QACC,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,sDACA;QAED,GAAG,KAAK;;;;;;AAGb,aAAa,WAAW,GAAG;AAE3B,MAAM,eAAe,CAAC,EACpB,SAAS,EACT,GAAG,OACkC,iBACrC,8OAAC;QACC,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,iEACA;QAED,GAAG,KAAK;;;;;;AAGb,aAAa,WAAW,GAAG;AAE3B,MAAM,4BAAc,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,kKAAA,CAAA,QAAqB;QACpB,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,qDACA;QAED,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG,kKAAA,CAAA,QAAqB,CAAC,WAAW;AAE3D,MAAM,kCAAoB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGvC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,kKAAA,CAAA,cAA2B;QAC1B,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,kBAAkB,WAAW,GAAG,kKAAA,CAAA,cAA2B,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 2166, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/table.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG3B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC;YACC,KAAK;YACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;YAC9C,GAAG,KAAK;;;;;;;;;;;AAIf,MAAM,WAAW,GAAG;AAEpB,MAAM,4BAAc,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QAAM,KAAK;QAAK,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,mBAAmB;QAAa,GAAG,KAAK;;;;;;AAEzE,YAAY,WAAW,GAAG;AAE1B,MAAM,0BAAY,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,4BAAc,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,2DACA;QAED,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG;AAE1B,MAAM,yBAAW,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG9B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,+EACA;QAED,GAAG,KAAK;;;;;;AAGb,SAAS,WAAW,GAAG;AAEvB,MAAM,0BAAY,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,oGACA;QAED,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,0BAAY,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,kDAAkD;QAC/D,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,6BAAe,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGb,aAAa,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 2276, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/csv-utils.ts"],"sourcesContent":["export function generateSampleCSV(headers: string[], sampleData: Record<string, string>): string {\n  const headerRow = headers.join(',');\n  const dataRow = headers.map(header => {\n    const value = sampleData[header] || '';\n    // Escape commas and quotes in CSV values\n    if (value.includes(',') || value.includes('\"') || value.includes('\\n')) {\n      return `\"${value.replace(/\"/g, '\"\"')}\"`;\n    }\n    return value;\n  }).join(',');\n  \n  return `${headerRow}\\n${dataRow}`;\n}\n\nexport function parseCSVLine(line: string): string[] {\n  const result: string[] = [];\n  let current = '';\n  let inQuotes = false;\n  let i = 0;\n\n  while (i < line.length) {\n    const char = line[i];\n    \n    if (char === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        // Escaped quote\n        current += '\"';\n        i += 2;\n      } else {\n        // Toggle quote state\n        inQuotes = !inQuotes;\n        i++;\n      }\n    } else if (char === ',' && !inQuotes) {\n      // End of field\n      result.push(current.trim());\n      current = '';\n      i++;\n    } else {\n      current += char;\n      i++;\n    }\n  }\n  \n  // Add the last field\n  result.push(current.trim());\n  \n  return result;\n}\n\nexport function parseCSV(text: string): Record<string, string>[] {\n  const lines = text.split('\\n').filter(line => line.trim());\n  if (lines.length < 2) return [];\n\n  const headers = parseCSVLine(lines[0]);\n  const rows: Record<string, string>[] = [];\n\n  for (let i = 1; i < lines.length; i++) {\n    const values = parseCSVLine(lines[i]);\n    const row: Record<string, string> = {};\n    \n    headers.forEach((header, index) => {\n      row[header] = values[index] || '';\n    });\n    \n    rows.push(row);\n  }\n\n  return rows;\n}\n\nexport function downloadCSV(filename: string, content: string): void {\n  const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });\n  const link = document.createElement('a');\n  \n  if (link.download !== undefined) {\n    const url = URL.createObjectURL(blob);\n    link.setAttribute('href', url);\n    link.setAttribute('download', filename);\n    link.style.visibility = 'hidden';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  }\n}\n\nexport function validateCSVStructure(\n  data: Record<string, string>[], \n  requiredColumns: string[]\n): { isValid: boolean; missingColumns: string[]; errors: string[] } {\n  const errors: string[] = [];\n  const missingColumns: string[] = [];\n  \n  if (data.length === 0) {\n    errors.push('CSV file is empty or has no data rows');\n    return { isValid: false, missingColumns, errors };\n  }\n  \n  // Check for required columns\n  const firstRow = data[0];\n  const availableColumns = Object.keys(firstRow);\n  \n  requiredColumns.forEach(column => {\n    if (!availableColumns.includes(column)) {\n      missingColumns.push(column);\n    }\n  });\n  \n  if (missingColumns.length > 0) {\n    errors.push(`Missing required columns: ${missingColumns.join(', ')}`);\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    missingColumns,\n    errors\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2393, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/csv-import-dialog.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useRef } from 'react';\nimport { Button } from '@/components/ui/button';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from '@/components/ui/dialog';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Progress } from '@/components/ui/progress';\nimport { \n  Table, \n  TableBody, \n  TableCell, \n  TableHead, \n  TableHeader, \n  TableRow \n} from '@/components/ui/table';\nimport { \n  Upload, \n  FileText, \n  CheckCircle, \n  AlertCircle, \n  Download,\n  Loader2 \n} from 'lucide-react';\nimport { Badge } from '@/components/ui/badge';\nimport { parseCSV, generateSampleCSV, downloadCSV } from '@/lib/csv-utils';\n\ninterface CSVRow {\n  [key: string]: string;\n}\n\ninterface ValidationError {\n  row: number;\n  field: string;\n  message: string;\n}\n\ninterface CSVImportDialogProps {\n  title: string;\n  description: string;\n  expectedColumns: string[];\n  requiredColumns?: string[];\n  sampleData: Record<string, string>;\n  onImport: (data: CSVRow[]) => Promise<{ success: boolean; message: string; errors?: string[] }>;\n  children: React.ReactNode;\n}\n\nexport function CSVImportDialog({\n  title,\n  description,\n  expectedColumns,\n  requiredColumns = expectedColumns,\n  sampleData,\n  onImport,\n  children\n}: CSVImportDialogProps) {\n  const [open, setOpen] = useState(false);\n  const [file, setFile] = useState<File | null>(null);\n  const [csvData, setCsvData] = useState<CSVRow[]>([]);\n  const [validationErrors, setValidationErrors] = useState<ValidationError[]>([]);\n  const [importing, setImporting] = useState(false);\n  const [importProgress, setImportProgress] = useState(0);\n  const [importResult, setImportResult] = useState<{ success: boolean; message: string; errors?: string[] } | null>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  // Use the improved CSV parsing from utils\n\n  const validateData = (data: CSVRow[]): ValidationError[] => {\n    const errors: ValidationError[] = [];\n\n    data.forEach((row, index) => {\n      requiredColumns.forEach(column => {\n        if (!row[column] || row[column].trim() === '') {\n          errors.push({\n            row: index + 1,\n            field: column,\n            message: `${column} is required`\n          });\n        }\n      });\n\n      // Additional validation for specific fields\n      if (row.price && isNaN(Number(row.price))) {\n        errors.push({\n          row: index + 1,\n          field: 'price',\n          message: 'Price must be a valid number'\n        });\n      }\n\n      if (row.gstRate && (isNaN(Number(row.gstRate)) || Number(row.gstRate) < 0 || Number(row.gstRate) > 100)) {\n        errors.push({\n          row: index + 1,\n          field: 'gstRate',\n          message: 'GST Rate must be a number between 0 and 100'\n        });\n      }\n    });\n\n    return errors;\n  };\n\n  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const selectedFile = event.target.files?.[0];\n    if (!selectedFile) return;\n\n    if (!selectedFile.name.endsWith('.csv')) {\n      alert('Please select a CSV file');\n      return;\n    }\n\n    setFile(selectedFile);\n    setImportResult(null);\n\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      const text = e.target?.result as string;\n      const parsed = parseCSV(text);\n      setCsvData(parsed);\n      \n      const errors = validateData(parsed);\n      setValidationErrors(errors);\n    };\n    reader.readAsText(selectedFile);\n  };\n\n  const handleImport = async () => {\n    if (validationErrors.length > 0) {\n      alert('Please fix validation errors before importing');\n      return;\n    }\n\n    setImporting(true);\n    setImportProgress(0);\n\n    try {\n      // Simulate progress\n      const progressInterval = setInterval(() => {\n        setImportProgress(prev => Math.min(prev + 10, 90));\n      }, 100);\n\n      const result = await onImport(csvData);\n      \n      clearInterval(progressInterval);\n      setImportProgress(100);\n      setImportResult(result);\n\n      if (result.success) {\n        setTimeout(() => {\n          setOpen(false);\n          resetState();\n        }, 2000);\n      }\n    } catch (error) {\n      setImportResult({\n        success: false,\n        message: 'Import failed due to an unexpected error'\n      });\n    } finally {\n      setImporting(false);\n    }\n  };\n\n  const resetState = () => {\n    setFile(null);\n    setCsvData([]);\n    setValidationErrors([]);\n    setImporting(false);\n    setImportProgress(0);\n    setImportResult(null);\n    if (fileInputRef.current) {\n      fileInputRef.current.value = '';\n    }\n  };\n\n  const downloadSample = () => {\n    const csvContent = generateSampleCSV(expectedColumns, sampleData);\n    downloadCSV('sample_products_import.csv', csvContent);\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={setOpen}>\n      <DialogTrigger asChild>\n        {children}\n      </DialogTrigger>\n      <DialogContent className=\"max-w-4xl max-h-[80vh] overflow-y-auto\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center gap-2\">\n            <Upload className=\"h-5 w-5\" />\n            {title}\n          </DialogTitle>\n          <DialogDescription>{description}</DialogDescription>\n        </DialogHeader>\n\n        <div className=\"space-y-6\">\n          {/* File Upload Section */}\n          <div className=\"space-y-4\">\n            <div className=\"flex items-center justify-between\">\n              <Label htmlFor=\"csv-file\">Select CSV File</Label>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={downloadSample}\n                className=\"flex items-center gap-2\"\n              >\n                <Download className=\"h-4 w-4\" />\n                Download Sample\n              </Button>\n            </div>\n            \n            <Input\n              id=\"csv-file\"\n              type=\"file\"\n              accept=\".csv\"\n              onChange={handleFileChange}\n              ref={fileInputRef}\n              disabled={importing}\n            />\n\n            {file && (\n              <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                <FileText className=\"h-4 w-4\" />\n                {file.name} ({csvData.length} rows)\n              </div>\n            )}\n          </div>\n\n          {/* Expected Format */}\n          <div className=\"space-y-2\">\n            <Label>Expected CSV Format</Label>\n            <div className=\"text-sm text-muted-foreground space-y-1\">\n              <div>\n                <strong>Required columns:</strong> {requiredColumns.join(', ')}\n              </div>\n              {expectedColumns.filter(col => !requiredColumns.includes(col)).length > 0 && (\n                <div>\n                  <strong>Optional columns:</strong> {expectedColumns.filter(col => !requiredColumns.includes(col)).join(', ')}\n                </div>\n              )}\n            </div>\n          </div>\n\n          {/* Validation Errors */}\n          {validationErrors.length > 0 && (\n            <Alert variant=\"destructive\">\n              <AlertCircle className=\"h-4 w-4\" />\n              <AlertDescription>\n                <div className=\"space-y-1\">\n                  <div className=\"font-medium\">Validation Errors ({validationErrors.length}):</div>\n                  <div className=\"max-h-32 overflow-y-auto space-y-1\">\n                    {validationErrors.slice(0, 10).map((error, index) => (\n                      <div key={index} className=\"text-xs\">\n                        Row {error.row}: {error.field} - {error.message}\n                      </div>\n                    ))}\n                    {validationErrors.length > 10 && (\n                      <div className=\"text-xs\">... and {validationErrors.length - 10} more errors</div>\n                    )}\n                  </div>\n                </div>\n              </AlertDescription>\n            </Alert>\n          )}\n\n          {/* Import Progress */}\n          {importing && (\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center gap-2\">\n                <Loader2 className=\"h-4 w-4 animate-spin\" />\n                <span className=\"text-sm\">Importing data...</span>\n              </div>\n              <Progress value={importProgress} className=\"w-full\" />\n            </div>\n          )}\n\n          {/* Import Result */}\n          {importResult && (\n            <Alert variant={importResult.success ? \"default\" : \"destructive\"}>\n              {importResult.success ? (\n                <CheckCircle className=\"h-4 w-4\" />\n              ) : (\n                <AlertCircle className=\"h-4 w-4\" />\n              )}\n              <AlertDescription>\n                <div className=\"space-y-1\">\n                  <div>{importResult.message}</div>\n                  {importResult.errors && importResult.errors.length > 0 && (\n                    <div className=\"text-xs space-y-1\">\n                      {importResult.errors.map((error, index) => (\n                        <div key={index}>‚Ä¢ {error}</div>\n                      ))}\n                    </div>\n                  )}\n                </div>\n              </AlertDescription>\n            </Alert>\n          )}\n\n          {/* Data Preview */}\n          {csvData.length > 0 && (\n            <div className=\"space-y-2\">\n              <Label>Data Preview ({csvData.length} rows)</Label>\n              <div className=\"border rounded-md max-h-64 overflow-auto\">\n                <Table>\n                  <TableHeader>\n                    <TableRow>\n                      {expectedColumns.map(column => (\n                        <TableHead key={column}>{column}</TableHead>\n                      ))}\n                      <TableHead>Status</TableHead>\n                    </TableRow>\n                  </TableHeader>\n                  <TableBody>\n                    {csvData.slice(0, 10).map((row, index) => {\n                      const rowErrors = validationErrors.filter(e => e.row === index + 1);\n                      return (\n                        <TableRow key={index}>\n                          {expectedColumns.map(column => (\n                            <TableCell key={column} className=\"max-w-32 truncate\">\n                              {row[column]}\n                            </TableCell>\n                          ))}\n                          <TableCell>\n                            {rowErrors.length > 0 ? (\n                              <Badge variant=\"destructive\">\n                                {rowErrors.length} error{rowErrors.length > 1 ? 's' : ''}\n                              </Badge>\n                            ) : (\n                              <Badge variant=\"secondary\">Valid</Badge>\n                            )}\n                          </TableCell>\n                        </TableRow>\n                      );\n                    })}\n                  </TableBody>\n                </Table>\n                {csvData.length > 10 && (\n                  <div className=\"p-2 text-center text-sm text-muted-foreground border-t\">\n                    ... and {csvData.length - 10} more rows\n                  </div>\n                )}\n              </div>\n            </div>\n          )}\n        </div>\n\n        <DialogFooter>\n          <Button variant=\"outline\" onClick={() => setOpen(false)} disabled={importing}>\n            Cancel\n          </Button>\n          <Button \n            onClick={handleImport} \n            disabled={!file || csvData.length === 0 || validationErrors.length > 0 || importing}\n          >\n            {importing ? (\n              <>\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                Importing...\n              </>\n            ) : (\n              `Import ${csvData.length} Products`\n            )}\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3089, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { getAuth } from 'firebase-admin/auth';\nimport { initializeApp, getApps, cert } from 'firebase-admin/app';\nimport { summarizeMeetingNotes } from '@/ai/flows/summarize-meeting-notes';\nimport { addLead as dbAddLead, addActivityToLead, updateLeadStatus as updateStatus, addProduct as dbAddProduct, addLeadSource as dbAddLeadSource, deleteLeadSource as dbDeleteLeadSource, addProductCategory as dbAddProductCategory, deleteProductCategory as dbDeleteProductCategory, getProductCategories, updateLead as dbUpdateLead, getLeadById as dbGetLeadById, deleteLead as dbDeleteLead, addQuotation as dbAddQuotation, updateQuotation as dbUpdateQuotation, deleteQuotation as dbDeleteQuotation, addQuotationTemplate as dbAddQuotationTemplate, updateProduct as dbUpdateProduct, deleteProduct as dbDeleteProduct, addEmployee as dbAddEmployee, deleteEmployee as dbDeleteEmployee, updateEmployee as dbUpdateEmployee, getEmployeeByEmail, getEmployeeRoles, addEmployeeRole as dbAddEmployeeRole, deleteEmployeeRole as dbDeleteEmployeeRole, getDepartments, addDepartment as dbAddDepartment, deleteDepartment as dbDeleteDepartment, updateQuotationTemplate as dbUpdateQuotationTemplate, deleteQuotationTemplate as dbDeleteQuotationTemplate, getLeadsCount, getQuotationsCount, getProductsCount, getEmployeesCount, getLeadsCountByStatus, getQuotationsCountByStatus, getActiveProductsCount, getActiveEmployeesCount, updateProductCategory as dbUpdateProductCategory } from './data';\nimport { deletePDFFromStorage, deleteImageFromStorage, uploadImageToStorage } from './storage-utils';\nimport type { Lead, LeadStatus, LeadProduct, UpdatableLeadData, Product, NewQuotationTemplate, Quotation, NewEmployee, QuotationTemplate } from './types';\nimport type { Employee } from './business-types';\nimport { getProducts } from './data';\n\n// Initialize Firebase Admin SDK\nfunction initializeFirebaseAdmin() {\n  if (getApps().length === 0) {\n    // Check if all required environment variables are present\n    const requiredEnvVars = [\n      'FIREBASE_PROJECT_ID',\n      'FIREBASE_PRIVATE_KEY',\n      'FIREBASE_CLIENT_EMAIL'\n    ];\n    \n    const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n    \n    if (missingVars.length > 0) {\n      throw new Error(`Missing required Firebase environment variables: ${missingVars.join(', ')}`);\n    }\n\n    const serviceAccount = {\n      type: \"service_account\",\n      project_id: process.env.FIREBASE_PROJECT_ID!,\n      private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,\n      private_key: process.env.FIREBASE_PRIVATE_KEY!.replace(/\\\\n/g, '\\n'),\n      client_email: process.env.FIREBASE_CLIENT_EMAIL!,\n      client_id: process.env.FIREBASE_CLIENT_ID,\n      auth_uri: \"https://accounts.google.com/o/oauth2/auth\",\n      token_uri: \"https://oauth2.googleapis.com/token\",\n      auth_provider_x509_cert_url: \"https://www.googleapis.com/oauth2/v1/certs\",\n      client_x509_cert_url: `https://www.googleapis.com/robot/v1/metadata/x509/${process.env.FIREBASE_CLIENT_EMAIL}`\n    };\n\n    initializeApp({\n      credential: cert(serviceAccount as any),\n      projectId: process.env.FIREBASE_PROJECT_ID,\n    });\n  }\n}\n\nconst LeadProductSchema = z.object({\n    productId: z.string().min(1, 'Product must be selected'),\n    quantity: z.coerce.number().min(1),\n    rate: z.coerce.number().min(0),\n    selectedSku: z.string().optional(),\n});\n\nconst CreateLeadSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  company: z.string().min(2, 'Company must be at least 2 characters'),\n  email: z.string().email('Invalid email address'),\n  phone: z.string().min(10, 'Phone number seems too short'),\n  whatsappNumber: z.string().optional().or(z.literal('')),\n  client_address: z.string().optional().or(z.literal('')),\n  client_gst_no: z.string().optional().or(z.literal('')),\n  status: z.enum(['New', 'In Discussion', 'Negotiation', 'Closed - Won', 'Closed - Lost']),\n  source: z.string().min(1, 'Please select a lead source'),\n  notes: z.string().optional(),\n  products: z.array(LeadProductSchema).optional(),\n  createdBy: z.string().min(1, 'Created by field is required'),\n});\n\nexport async function createLead(formData: FormData) {\n  const productsJSON = formData.get('products');\n  const products = productsJSON ? JSON.parse(productsJSON as string) : [];\n\n  const validatedFields = CreateLeadSchema.safeParse({\n    name: formData.get('name'),\n    company: formData.get('company'),\n    email: formData.get('email'),\n    phone: formData.get('phone'),\n    whatsappNumber: formData.get('whatsappNumber'),\n    client_address: formData.get('client_address'),\n    client_gst_no: formData.get('client_gst_no'),\n    status: formData.get('status'),\n    source: formData.get('source'),\n    notes: formData.get('notes'),\n    products: products,\n    createdBy: formData.get('createdBy'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Failed to create lead.',\n    };\n  }\n  \n  let newLeadId: string | undefined;\n  try {\n    const leadData = {\n      ...validatedFields.data,\n      products: validatedFields.data.products || []\n    };\n    const newLead = await dbAddLead(leadData);\n    newLeadId = newLead.id;\n  } catch (error) {\n    return { message: 'Database Error: Failed to Create Lead.' };\n  }\n\n  revalidatePath('/leads');\n  revalidatePath('/');\n  if (newLeadId) {\n    revalidatePath(`/leads/${newLeadId}`);\n  }\n  return { message: 'Successfully created lead.' };\n}\n\nconst UpdateLeadSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  company: z.string().min(2, 'Company must be at least 2 characters'),\n  email: z.string().email('Invalid email address'),\n  phone: z.string().min(10, 'Phone number seems too short'),\n  whatsappNumber: z.string().optional().or(z.literal('')),\n  client_address: z.string().optional().or(z.literal('')),\n  client_gst_no: z.string().optional().or(z.literal('')),\n  status: z.enum(['New', 'In Discussion', 'Negotiation', 'Closed - Won', 'Closed - Lost']),\n  source: z.string().min(1, 'Please select a lead source'),\n  products: z.array(LeadProductSchema).optional(),\n});\n\nfunction generateChangeNotes(oldLead: Lead, newLeadData: UpdatableLeadData, allProducts: Product[]): string {\n    const changes: string[] = [];\n\n    if (oldLead.name !== newLeadData.name) {\n        changes.push(`Name changed from \"${oldLead.name}\" to \"${newLeadData.name}\".`);\n    }\n    if (oldLead.company !== newLeadData.company) {\n        changes.push(`Company changed from \"${oldLead.company}\" to \"${newLeadData.company}\".`);\n    }\n    if (oldLead.email !== newLeadData.email) {\n        changes.push(`Email changed from \"${oldLead.email}\" to \"${newLeadData.email}\".`);\n    }\n    if (oldLead.phone !== newLeadData.phone) {\n        changes.push(`Phone changed from \"${oldLead.phone}\" to \"${newLeadData.phone}\".`);\n    }\n    if (oldLead.whatsappNumber !== newLeadData.whatsappNumber) {\n        changes.push(`WhatsApp Number changed from \"${oldLead.whatsappNumber || 'N/A'}\" to \"${newLeadData.whatsappNumber || 'N/A'}\".`);\n    }\n    if (oldLead.client_address !== newLeadData.client_address) {\n        changes.push(`Client Address changed from \"${oldLead.client_address || 'N/A'}\" to \"${newLeadData.client_address || 'N/A'}\".`);\n    }\n    if (oldLead.client_gst_no !== newLeadData.client_gst_no) {\n        changes.push(`Client GST Number changed from \"${oldLead.client_gst_no || 'N/A'}\" to \"${newLeadData.client_gst_no || 'N/A'}\".`);\n    }\n    if (oldLead.status !== newLeadData.status) {\n        changes.push(`Status changed from \"${oldLead.status}\" to \"${newLeadData.status}\".`);\n    }\n    if (oldLead.source !== newLeadData.source) {\n        changes.push(`Source changed from \"${oldLead.source}\" to \"${newLeadData.source}\".`);\n    }\n\n    const oldProducts = oldLead.products || [];\n    const newProducts = newLeadData.products || [];\n    if (JSON.stringify(oldProducts) !== JSON.stringify(newProducts)) {\n        const getProductName = (productId: string) => allProducts.find(p => p.id === productId)?.name || productId;\n        \n        const formatProduct = (p: LeadProduct) => `${getProductName(p.productId)} (Qty: ${p.quantity}, Rate: ${p.rate}, SKU: ${p.selectedSku || 'N/A'})`;\n\n        const oldProductStr = oldProducts.map(formatProduct).join(', ') || 'None';\n        const newProductStr = newProducts.map(formatProduct).join(', ') || 'None';\n\n        changes.push(`Interested products updated.\\n- Old: ${oldProductStr}\\n- New: ${newProductStr}`);\n    }\n\n    if (changes.length === 0) {\n        return 'No changes were made to the lead details.';\n    }\n\n    return 'Lead details were updated:\\n' + changes.map(c => `- ${c}`).join('\\n');\n}\n\nexport async function updateLead(leadId: string, formData: FormData) {\n    const [oldLead, allProducts] = await Promise.all([\n        dbGetLeadById(leadId),\n        getProducts()\n    ]);\n\n    if (!oldLead) {\n        return { message: 'Error: Lead not found.' };\n    }\n\n    const productsJSON = formData.get('products');\n    const products = productsJSON ? JSON.parse(productsJSON as string) : [];\n  \n    const validatedFields = UpdateLeadSchema.safeParse({\n      name: formData.get('name'),\n      company: formData.get('company'),\n      email: formData.get('email'),\n      phone: formData.get('phone'),\n      whatsappNumber: formData.get('whatsappNumber'),\n      client_address: formData.get('client_address'),\n      client_gst_no: formData.get('client_gst_no'),\n      status: formData.get('status'),\n      source: formData.get('source'),\n      products: products,\n    });\n  \n    if (!validatedFields.success) {\n      return {\n        errors: validatedFields.error.flatten().fieldErrors,\n        message: 'Failed to update lead.',\n      };\n    }\n\n    const newLeadData = validatedFields.data as UpdatableLeadData;\n    const changeNotes = generateChangeNotes(oldLead, newLeadData, allProducts);\n  \n    try {\n        await dbUpdateLead(leadId, newLeadData);\n        if (changeNotes !== 'No changes were made to the lead details.') {\n            await addActivityToLead(leadId, {\n                type: 'Revision Request',\n                notes: changeNotes\n            });\n        }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'An unknown error occurred';\n      return { message: `Database Error: Failed to Update Lead. ${message}` };\n    }\n  \n    revalidatePath('/leads');\n    revalidatePath('/');\n    revalidatePath(`/leads/${leadId}`);\n    return { message: 'Successfully updated lead.' };\n}\n\nconst ProductSchema = z.object({\n    name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n    price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n    gstRate: z.coerce.number().min(0).max(100),\n    categoryId: z.string().optional(),\n    description: z.string().optional(),\n    skus: z.array(z.string()).optional(),\n    catalogueUrl: z.string().url('Please enter a valid URL.').optional().or(z.literal('')),\n    cataloguePdf: z.object({\n        url: z.string(),\n        fileName: z.string(),\n        filePath: z.string(),\n        uploadedAt: z.string(),\n    }).optional(),\n    productImage: z.object({\n        url: z.string(),\n        fileName: z.string(),\n        filePath: z.string(),\n        uploadedAt: z.string(),\n    }).optional(),\n});\n\nexport async function addProduct(formData: FormData) {\n  const skusJSON = formData.get('skus');\n  const skus = skusJSON ? JSON.parse(skusJSON as string) : [];\n  \n  const catalogPdfJSON = formData.get('catalogPdf');\n  const catalogPdf = catalogPdfJSON ? JSON.parse(catalogPdfJSON as string) : undefined;\n  \n  const productImageJSON = formData.get('productImage');\n  console.log('Product Image JSON received:', productImageJSON);\n  const productImage = productImageJSON ? JSON.parse(productImageJSON as string) : undefined;\n  console.log('Product Image parsed:', productImage);\n  \n  const validatedFields = ProductSchema.safeParse({\n    name: formData.get('name'),\n    price: formData.get('price'),\n    gstRate: formData.get('gstRate'),\n    categoryId: formData.get('categoryId'),\n    description: formData.get('description') || undefined,\n    skus: skus,\n    catalogueUrl: formData.get('catalogueUrl') || '',\n    cataloguePdf: catalogPdf,\n    productImage: productImage,\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Failed to add product.',\n    };\n  }\n\n  try {\n    const data = validatedFields.data;\n    // Remove undefined values before sending to Firestore\n    const cleanData = Object.fromEntries(\n      Object.entries(data).filter(([_, v]) => v !== undefined)\n    );\n    \n    console.log('Clean data being sent to database:', JSON.stringify(cleanData, null, 2));\n    \n    // Create the product\n    const newProduct = await dbAddProduct(cleanData as any);\n    \n  } catch (error) {\n    return { message: 'Database Error: Failed to add product.' };\n  }\n\n  revalidatePath('/products');\n  revalidatePath('/leads'); // Revalidate leads in case product info is needed\n  return { message: 'Successfully added product.' };\n}\n\nexport async function updateProduct(id: string, formData: FormData) {\n    const skusJSON = formData.get('skus');\n    const skus = skusJSON ? JSON.parse(skusJSON as string) : [];\n\n    const catalogPdfJSON = formData.get('catalogPdf');\n    const catalogPdf = catalogPdfJSON ? JSON.parse(catalogPdfJSON as string) : undefined;\n    const removeCatalogPdf = String(formData.get('removeCatalogPdf') || '').toLowerCase() === 'true';\n\n    // Handle product image - can be File object (new upload) or JSON string (existing metadata)\n    const productImageData = formData.get('productImage');\n    const existingProductImageJSON = formData.get('existingProductImage');\n    const removeProductImage = String(formData.get('removeProductImage') || '').toLowerCase() === 'true';\n    \n    let productImage: any = undefined;\n    \n    // If there's a new file upload, handle it\n    if (productImageData instanceof File) {\n      try {\n        const uploadResult = await uploadImageToStorage(productImageData, 'products');\n        productImage = {\n          url: uploadResult.url,\n          fileName: uploadResult.fileName,\n          filePath: uploadResult.path,\n          uploadedAt: new Date().toISOString(),\n        };\n      } catch (error) {\n        console.error('Failed to upload product image:', error);\n        return { message: 'Failed to upload product image.' };\n      }\n    } else if (existingProductImageJSON && !removeProductImage) {\n      // Keep existing image metadata\n      productImage = JSON.parse(existingProductImageJSON as string);\n    }\n\n    // Debug logs removed\n    \n    const validatedFields = ProductSchema.safeParse({\n      name: formData.get('name'),\n      price: formData.get('price'),\n      gstRate: formData.get('gstRate'),\n      categoryId: formData.get('categoryId'),\n      description: formData.get('description') || undefined,\n      skus: skus,\n      catalogueUrl: formData.get('catalogueUrl') || '',\n      cataloguePdf: catalogPdf,\n      productImage: productImage,\n    });\n\n    if (!validatedFields.success) {\n      return {\n        errors: validatedFields.error.flatten().fieldErrors,\n        message: 'Failed to update product.',\n      };\n    }\n\n    try {\n      // Get the current product to check for existing PDF\n      const currentProduct = await getProducts().then(products => \n        products.find(p => p.id === id)\n      );\n      \n      const data = validatedFields.data as any;\n      const updateData: any = { ...data };\n      \n      // If user explicitly removed the existing PDF and didn't upload a new one, clear the field\n      if (removeCatalogPdf && !catalogPdf) {\n        // Delete the old PDF from Firebase Storage if it exists\n        if (currentProduct?.cataloguePdf?.filePath) {\n          try {\n            await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n          } catch (error) {\n            console.error('Failed to delete PDF from storage:', error);\n            // Continue with the update even if PDF deletion fails\n          }\n        }\n        updateData.cataloguePdf = null; // This will clear the field in Firestore\n      } else if (catalogPdf && currentProduct?.cataloguePdf?.filePath && \n                 currentProduct.cataloguePdf.filePath !== catalogPdf.filePath) {\n        // If a new PDF was uploaded, delete the old one from storage\n        try {\n          await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n        } catch (error) {\n          console.error('Failed to delete old PDF from storage:', error);\n          // Continue with the update even if old PDF deletion fails\n        }\n      }\n      \n      // Handle product image storage cleanup if new image was uploaded\n      if (productImageData instanceof File && currentProduct?.productImage?.filePath) {\n        // Delete the old image from storage since we have a new one\n        try {\n          await deleteImageFromStorage(currentProduct.productImage.filePath);\n        } catch (error) {\n          console.error('Failed to delete old product image from storage:', error);\n          // Continue with the update even if old image deletion fails\n        }\n      }\n      \n      // Handle product image removal\n      if (removeProductImage && !productImageData) {\n        // Delete the existing image from storage\n        if (currentProduct?.productImage?.filePath) {\n          try {\n            await deleteImageFromStorage(currentProduct.productImage.filePath);\n          } catch (error) {\n            console.error('Failed to delete product image from storage:', error);\n          }\n        }\n        updateData.productImage = null; // This will clear the field in Firestore\n      }\n      \n      // Ensure new uploads are persisted\n      if (catalogPdf) {\n        updateData.cataloguePdf = catalogPdf;\n      }\n      if (productImage) {\n        updateData.productImage = productImage;\n      }\n      \n      // Remove undefined values from updateData as Firestore doesn't accept them\n      const cleanedUpdateData: any = {};\n      for (const [key, value] of Object.entries(updateData)) {\n        if (value !== undefined) {\n          cleanedUpdateData[key] = value;\n        }\n      }\n      \n      console.log('[updateProduct] cleanedUpdateData keys:', Object.keys(cleanedUpdateData));\n      console.log('[updateProduct] cleanedUpdateData.productImage:', cleanedUpdateData.productImage);\n      \n      await dbUpdateProduct(id, cleanedUpdateData);\n    } catch (error) {\n      return { message: 'Database Error: Failed to update product.' };\n    }\n\n    revalidatePath('/products');\n    revalidatePath('/leads');\n    return { message: 'Successfully updated product.' };\n  }\n  \n  export async function deleteProduct(id: string) {\n    try {\n      // Get the current product to check for PDF before deletion\n      const currentProduct = await getProducts().then(products => \n        products.find(p => p.id === id)\n      );\n      \n      // Delete the PDF from Firebase Storage if it exists\n      if (currentProduct?.cataloguePdf?.filePath) {\n        try {\n          await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n        } catch (error) {\n          console.error('Failed to delete PDF from storage:', error);\n          // Continue with product deletion even if PDF deletion fails\n        }\n      }\n      \n      await dbDeleteProduct(id);\n    } catch (error) {\n      return { message: 'Database Error: Failed to delete product.' };\n    }\n\n    revalidatePath('/products');\n    revalidatePath('/leads');\n    return { message: 'Successfully deleted product.' };\n  }\n\n\nconst LogActivitySchema = z.object({\n    leadId: z.string(),\n    type: z.enum(['Meeting', 'Call', 'Email', 'Revision Request', 'Proposal Sent']),\n    notes: z.string().optional(),\n    summary: z.string().optional(),\n});\n\nexport async function logActivity(formData: FormData) {\n    const validatedFields = LogActivitySchema.safeParse({\n        leadId: formData.get('leadId'),\n        type: formData.get('type'),\n        notes: formData.get('notes'),\n        summary: formData.get('summary') || undefined,\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to log activity.',\n        };\n    }\n\n    try {\n        const { leadId, ...activityData } = validatedFields.data;\n        await addActivityToLead(leadId, activityData);\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        console.error('LogActivity Error:', message);\n        if (message.includes('Lead not found')) {\n            return { message: 'Lead not found. Please refresh the page and try again.' };\n        }\n        return { message: 'Database Error: Failed to log activity.' };\n    }\n\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    revalidatePath('/');\n    return { message: 'Successfully logged activity.' };\n}\n\nexport async function getSummaryForNotes(notes: string): Promise<{ summary?: string; error?: string }> {\n  if (!notes || notes.trim().length < 50) {\n    return { error: 'Please provide at least 50 characters of notes to summarize.' };\n  }\n  try {\n    const result = await summarizeMeetingNotes({ notes });\n    return result;\n  } catch (e) {\n    console.error('AI Summarization Error:', e);\n    return { error: 'Failed to generate summary due to an internal error.' };\n  }\n}\n\n\nexport async function updateLeadStatusAction(leadId: string, status: LeadStatus, userId?: string, userName?: string) {\n  try {\n    // Get the current lead to capture the previous status\n    const currentLead = await dbGetLeadById(leadId);\n    if (!currentLead) {\n      return { message: 'Lead not found.' };\n    }\n    \n    const previousStatus = currentLead.status;\n    \n    // Only update if status is actually changing\n    if (previousStatus === status) {\n      return { message: 'Status is already set to this value.' };\n    }\n    \n    // Update the status\n    await updateStatus(leadId, status);\n    \n    // Add a status change activity\n    const changedBy = userName || userId || 'Unknown User';\n    const statusChangeNotes = `Status changed from \"${previousStatus}\" to \"${status}\" by ${changedBy}`;\n    \n    await addActivityToLead(leadId, {\n      type: 'Status Change',\n      notes: statusChangeNotes\n    });\n    \n  } catch (error) {\n    return { message: 'Database Error: Failed to update status.' };\n  }\n  revalidatePath(`/leads/${leadId}`);\n  revalidatePath('/leads');\n  revalidatePath('/');\n  return { message: 'Status updated successfully.' };\n}\n\nexport async function deleteLeadAction(leadId: string) {\n  try {\n    await dbDeleteLead(leadId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete lead.' };\n  }\n  revalidatePath('/leads');\n  revalidatePath('/');\n  return { message: 'Successfully deleted lead.' };\n}\n\nconst AddLeadSourceSchema = z.object({\n    name: z.string().min(2, 'Source name must be at least 2 characters'),\n});\n\nexport async function addLeadSourceAction(formData: FormData) {\n    const validatedFields = AddLeadSourceSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddLeadSource(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add lead source.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/leads');\n    return { message: `Successfully added '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteLeadSourceAction(id: string) {\n    try {\n        await dbDeleteLeadSource(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete lead source.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/leads');\n    return { message: 'Successfully deleted lead source.' };\n}\n\nconst AddProductCategorySchema = z.object({\n    name: z.string().min(2, 'Category name must be at least 2 characters'),\n    description: z.string().optional().nullable(),\n});\n\nexport async function addProductCategoryAction(formData: FormData) {\n    const validatedFields = AddProductCategorySchema.safeParse({\n        name: formData.get('name'),\n        description: formData.get('description'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        // Convert null to undefined for optional description\n        const description = validatedFields.data.description || '';\n        await dbAddProductCategory(validatedFields.data.name, description);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add product category.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: `Successfully added '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteProductCategoryAction(id: string) {\n    try {\n        await dbDeleteProductCategory(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete product category.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: 'Successfully deleted product category.' };\n}\n\n// Update an existing product category's name/description\nexport async function updateProductCategoryAction(id: string, name: string, description?: string) {\n    try {\n        await dbUpdateProductCategory(id, name, description || '');\n    } catch (error) {\n        const message = error instanceof Error ? error.message : 'Unknown error';\n        return { message: `Database Error: Failed to update product category. ${message}` };\n    }\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: 'Successfully updated product category.' };\n}\n\nexport async function getProductCategoriesAction() {\n    try {\n        const categories = await getProductCategories();\n        return categories;\n    } catch (error) {\n        console.error('Error fetching product categories:', error);\n        return [];\n    }\n}\n\n\nconst CreateQuotationSchema = z.object({\n  leadId: z.string().min(1),\n  templateId: z.string().min(1),\n  date: z.string(),\n  validUntil: z.string(),\n  status: z.enum(['Draft', 'Sent', 'Accepted', 'Rejected']),\n  products: z.string(), // JSON string\n  subTotal: z.coerce.number(),\n  totalGst: z.coerce.number(),\n  grandTotal: z.coerce.number(),\n  quotationPrefix: z.string().optional(),\n  // Overridable template fields\n  companyName: z.string().min(1),\n  companyAddress: z.string().min(1),\n  companyGst: z.string().optional().or(z.literal('')).nullable(),\n  // Client billing fields\n  client_address: z.string().optional().or(z.literal('')).nullable(),\n  client_gst_no: z.string().optional().or(z.literal('')).nullable(),\n  termsAndConditions: z.string(),\n  logoUrl: z.string().optional().nullable(),\n  // Additional charges (numeric or empty/null)\n  freightCharges: z.coerce.number().min(0).optional().or(z.literal('')).nullable(),\n  courierCharges: z.coerce.number().min(0).optional().or(z.literal('')).nullable(),\n  // Flags to show/hide charges in PDF\n  showFreight: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return false; // default to false\n  }, z.boolean()).optional(),\n  showCourier: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return false; // default to false\n  }, z.boolean()).optional(),\n  // GST visibility control\n  showGst: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return true; // default to true for backward compatibility\n  }, z.boolean()).optional(),\n  // Currency fields\n  currencyCode: z.string().optional(),\n  currencySymbol: z.string().optional(),\n  conversionRate: z.coerce.number().optional(),\n});\n\n\nexport async function addQuotation(formData: FormData) {\n    console.log('Server received quotationPrefix:', formData.get('quotationPrefix'));\n    const validatedFields = CreateQuotationSchema.safeParse({\n        leadId: formData.get('leadId'),\n        templateId: formData.get('templateId'),\n        date: formData.get('date'),\n        validUntil: formData.get('validUntil'),\n        status: formData.get('status'),\n        products: formData.get('products'),\n        subTotal: formData.get('subTotal'),\n        totalGst: formData.get('totalGst'),\n        grandTotal: formData.get('grandTotal'),\n        quotationPrefix: formData.get('quotationPrefix') || '',\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        client_address: formData.get('client_address'),\n        client_gst_no: formData.get('client_gst_no'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n        freightCharges: formData.get('freightCharges'),\n        courierCharges: formData.get('courierCharges'),\n        showFreight: formData.get('showFreight'),\n        showCourier: formData.get('showCourier'),\n        showGst: formData.get('showGst'),\n        currencyCode: formData.get('currencyCode'),\n        currencySymbol: formData.get('currencySymbol'),\n        conversionRate: formData.get('conversionRate'),\n      });\n    \n      if (!validatedFields.success) {\n        console.error(validatedFields.error.flatten().fieldErrors);\n        return {\n          errors: validatedFields.error.flatten().fieldErrors,\n          message: 'Validation Error: Failed to create quotation.',\n        };\n      }\n      \n      let newQuotation: Quotation | undefined;\n      try {\n        const data = validatedFields.data;\n        const parsedProducts = JSON.parse(data.products);\n        const prefix = (data.quotationPrefix?.trim() || 'QUO');\n        console.log('Using prefix:', prefix);\n        const { quotationPrefix: _omitPrefix, logoUrl, ...rest } = data as any;\n        \n        // Clean up null values - convert to undefined for Firestore\n        const payload: any = {\n          ...rest,\n          products: parsedProducts,\n          companyGst: rest.companyGst || undefined,\n          client_address: rest.client_address || undefined,\n          client_gst_no: rest.client_gst_no || undefined,\n          freightCharges: rest.freightCharges || undefined,\n          courierCharges: rest.courierCharges || undefined,\n          showFreight: rest.showFreight === true || rest.showFreight === 'true',\n          showCourier: rest.showCourier === true || rest.showCourier === 'true',\n        };\n        if (logoUrl) payload.logoUrl = logoUrl;\n        newQuotation = await dbAddQuotation(payload, prefix);\n\n        // Log activity on the lead\n        await addActivityToLead(data.leadId, {\n            type: 'Proposal Sent',\n            notes: `Quotation ${newQuotation.quotationNumber} was created and sent.`\n        });\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return { message: `Database Error: Failed to Create Quotation. ${message}` };\n      }\n\n    revalidatePath('/quotations');\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    return { message: 'Successfully created quotation.' };\n}\n\nexport async function updateQuotation(id: string, formData: FormData) {\n    const validatedFields = CreateQuotationSchema.safeParse({\n        leadId: formData.get('leadId'),\n        templateId: formData.get('templateId'),\n        date: formData.get('date'),\n        validUntil: formData.get('validUntil'),\n        status: formData.get('status'),\n        products: formData.get('products'),\n        subTotal: formData.get('subTotal'),\n        totalGst: formData.get('totalGst'),\n        grandTotal: formData.get('grandTotal'),\n        quotationPrefix: formData.get('quotationPrefix') || '',\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        client_address: formData.get('client_address'),\n        client_gst_no: formData.get('client_gst_no'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n        freightCharges: formData.get('freightCharges'),\n        courierCharges: formData.get('courierCharges'),\n        showFreight: formData.get('showFreight'),\n        showCourier: formData.get('showCourier'),\n        showGst: formData.get('showGst'),\n        currencyCode: formData.get('currencyCode'),\n        currencySymbol: formData.get('currencySymbol'),\n        conversionRate: formData.get('conversionRate'),\n      });\n    \n      if (!validatedFields.success) {\n        console.error(validatedFields.error.flatten().fieldErrors);\n        return {\n          errors: validatedFields.error.flatten().fieldErrors,\n          message: 'Validation Error: Failed to update quotation.',\n        };\n      }\n      \n      try {\n        const data = validatedFields.data;\n        const parsedProducts = JSON.parse(data.products);\n        \n        // Clean up null values - convert to undefined for Firestore\n        await dbUpdateQuotation(id, {\n            ...data,\n            logoUrl: data.logoUrl || undefined,\n            companyGst: data.companyGst || undefined,\n            client_address: data.client_address || undefined,\n            client_gst_no: data.client_gst_no || undefined,\n            freightCharges: data.freightCharges || undefined,\n            courierCharges: data.courierCharges || undefined,\n            showFreight: data.showFreight === true || data.showFreight === 'true',\n            showCourier: data.showCourier === true || data.showCourier === 'true',\n            products: parsedProducts,\n        });\n\n        // Log activity on the lead\n        await addActivityToLead(data.leadId, {\n            type: 'Revision Request',\n            notes: `Quotation was updated.`\n        });\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return { message: `Database Error: Failed to Update Quotation. ${message}` };\n      }\n\n    revalidatePath('/quotations');\n    revalidatePath(`/quotations/${id}`);\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    return { message: 'Successfully updated quotation.' };\n}\n\nexport async function deleteQuotationAction(quotationId: string) {\n  try {\n    await dbDeleteQuotation(quotationId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete quotation.' };\n  }\n  revalidatePath('/quotations');\n  revalidatePath('/');\n  return { message: 'Successfully deleted quotation.' };\n}\n\n\nconst QuotationTemplateSchema = z.object({\n    name: z.string().min(3, 'Template name must be at least 3 characters.'),\n    prefix: z.string().min(1, 'Prefix is required.'),\n    companyName: z.string().min(3, 'Company name is required.'),\n    companyAddress: z.string().min(10, 'Full company address is required.'),\n    companyGst: z.string().min(15, 'A valid GSTIN is required.').max(15),\n    termsAndConditions: z.string().min(20, 'Terms and conditions are required.'),\n    logoUrl: z.string().url('Please enter a valid URL for the logo.').optional().or(z.literal('')),\n});\n\nexport async function addQuotationTemplateAction(formData: FormData) {\n    const validatedFields = QuotationTemplateSchema.safeParse({\n        name: formData.get('name'),\n        prefix: formData.get('prefix'),\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to create template. Please check the fields.',\n        };\n    }\n\n    try {\n        await dbAddQuotationTemplate(validatedFields.data as NewQuotationTemplate);\n    } catch (error) {\n        return { message: 'Database Error: Failed to create template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully created quotation template.' };\n}\n\nexport async function updateQuotationTemplateAction(id: string, formData: FormData) {\n    const validatedFields = QuotationTemplateSchema.safeParse({\n        name: formData.get('name'),\n        prefix: formData.get('prefix'),\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to update template. Please check the fields.',\n        };\n    }\n\n    try {\n        await dbUpdateQuotationTemplate(id, validatedFields.data as QuotationTemplate);\n    } catch (error) {\n        return { message: 'Database Error: Failed to update template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully updated quotation template.' };\n}\n\nexport async function deleteQuotationTemplateAction(id: string) {\n    try {\n        await dbDeleteQuotationTemplate(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully deleted quotation template.' };\n}\n\n\nconst AddEmployeeSchema = z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters.'),\n    email: z.string().email('Please enter a valid email.'),\n    phone: z.string().min(10, 'Please enter a valid phone number.'),\n    role: z.string({\n      required_error: \"You need to select a role.\",\n    }),\n    department: z.string({\n        required_error: \"You need to select a department.\",\n    }),\n    address: z.string().min(10, 'Address is required.'),\n});\n\nexport async function addEmployeeAction(formData: FormData) {\n    const validatedFields = AddEmployeeSchema.safeParse({\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        role: formData.get('role'),\n        department: formData.get('department'),\n        address: formData.get('address'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to add employee.',\n        };\n    }\n\n    const [employeeRoles, departments] = await Promise.all([\n        getEmployeeRoles(),\n        getDepartments(),\n    ]);\n\n    const roleExists = employeeRoles.some(r => r.name === validatedFields.data.role);\n    if (!roleExists) {\n        return { message: 'Invalid role selected.' };\n    }\n    const departmentExists = departments.some(d => d.name === validatedFields.data.department);\n    if (!departmentExists) {\n        return { message: 'Invalid department selected.' };\n    }\n\n    try {\n        // Check if Firebase Admin environment variables are configured\n        const requiredEnvVars = ['FIREBASE_PROJECT_ID', 'FIREBASE_PRIVATE_KEY', 'FIREBASE_CLIENT_EMAIL'];\n        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n        \n        if (missingVars.length > 0) {\n            console.warn(`Firebase Admin not configured. Missing: ${missingVars.join(', ')}`);\n            // Just add to database without Firebase Auth integration\n            await dbAddEmployee(validatedFields.data as NewEmployee);\n            revalidatePath('/employees');\n            return { \n                message: 'Employee added to database. Note: Firebase Auth integration requires environment variables to be configured for automatic account creation and email sending.'\n            };\n        }\n\n        // Initialize Firebase Admin\n        initializeFirebaseAdmin();\n        const auth = getAuth();\n\n        // Create user in Firebase Auth\n        const userRecord = await auth.createUser({\n            email: validatedFields.data.email,\n            displayName: validatedFields.data.name,\n            emailVerified: false,\n        });\n\n        // Add employee to database first\n        await dbAddEmployee(validatedFields.data as NewEmployee);\n\n        // Set a temporary password for the user\n        const tempPassword = Math.random().toString(36).slice(-12) + 'A1!'; // Ensure it meets Firebase requirements\n        \n        // Update the user with the temporary password\n        await auth.updateUser(userRecord.uid, {\n            password: tempPassword,\n        });\n\n        // Send password reset email using Firebase Auth's REST API\n        try {\n            const webApiKey = process.env.FIREBASE_WEB_API_KEY;\n            \n            if (!webApiKey) {\n                throw new Error('FIREBASE_WEB_API_KEY not configured');\n            }\n\n            // Use Firebase Auth REST API to send password reset email\n            const response = await fetch(`https://identitytoolkit.googleapis.com/v1/accounts:sendOobCode?key=${webApiKey}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    requestType: 'PASSWORD_RESET',\n                    email: validatedFields.data.email,\n                    continueUrl: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/login`,\n                }),\n            });\n\n            if (response.ok) {\n                const responseData = await response.json();\n                console.log('='.repeat(80));\n                console.log(`‚úÖ EMPLOYEE CREATED: ${validatedFields.data.name}`);\n                console.log(`üìß Email: ${validatedFields.data.email}`);\n                console.log(`üì® Password reset email sent successfully!`);\n                console.log(`üì¨ Email will be delivered by Firebase Auth`);\n                console.log('='.repeat(80));\n\n                revalidatePath('/employees');\n                return { \n                    message: `Successfully added employee ${validatedFields.data.name}. Password reset email has been sent to ${validatedFields.data.email}.`,\n                };\n            } else {\n                const errorData = await response.json();\n                console.error('Failed to send password reset email:', errorData);\n                throw new Error(`Email sending failed: ${errorData.error?.message || 'Unknown error'}`);\n            }\n        } catch (emailError) {\n            console.error('Error sending password reset email:', emailError);\n            \n            // Fallback: generate link for manual sharing\n            const resetLink = await auth.generatePasswordResetLink(validatedFields.data.email, {\n                url: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/login`,\n                handleCodeInApp: false,\n            });\n\n            console.log('='.repeat(80));\n            console.log(`‚úÖ EMPLOYEE CREATED: ${validatedFields.data.name}`);\n            console.log(`üìß Email: ${validatedFields.data.email}`);\n            console.log(`‚ùå Email sending failed: ${emailError.message}`);\n            console.log(`üîó Manual Reset Link: ${resetLink}`);\n            console.log(`üìù Please share this link with the employee`);\n            console.log('='.repeat(80));\n\n            revalidatePath('/employees');\n            return { \n                message: `Successfully added employee ${validatedFields.data.name}. Email sending failed - please share the reset link manually (check console).`,\n                resetLink: resetLink\n            };\n        }\n    } catch (error: any) {\n        console.error('Error adding employee:', error);\n        \n        // Handle specific Firebase errors\n        if (error.code === 'auth/email-already-exists') {\n            return { message: 'An account with this email already exists.' };\n        }\n        \n        if (error.message?.includes('Missing required Firebase environment variables')) {\n            // Fallback: add to database only\n            try {\n                await dbAddEmployee(validatedFields.data as NewEmployee);\n                revalidatePath('/employees');\n                return { \n                    message: 'Employee added to database. Firebase Auth integration requires proper environment configuration for automatic account creation.'\n                };\n            } catch (dbError) {\n                return { message: 'Failed to add employee to database.' };\n            }\n        }\n        \n        return { message: 'Failed to add employee. Please check Firebase configuration and try again.' };\n    }\n}\n\nexport async function deleteEmployeeAction(employeeId: string) {\n  try {\n    await dbDeleteEmployee(employeeId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete employee.' };\n  }\n  revalidatePath('/employees');\n  revalidatePath('/');\n  return { message: 'Successfully deleted employee.' };\n}\n\nconst UpdateEmployeeSchema = z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters.'),\n    email: z.string().email('Please enter a valid email.'),\n    phone: z.string().min(10, 'Please enter a valid phone number.'),\n    role: z.string(),\n    department: z.string(),\n    address: z.string().min(10, 'Address is required.'),\n});\n\nexport async function updateEmployeeAction(id: string, formData: FormData) {\n    const validatedFields = UpdateEmployeeSchema.safeParse({\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        role: formData.get('role'),\n        department: formData.get('department'),\n        address: formData.get('address'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to update employee.',\n        };\n    }\n\n    try {\n        await dbUpdateEmployee(id, validatedFields.data as NewEmployee);\n    } catch (error) {\n        return { message: 'Database Error: Failed to update employee.' };\n    }\n\n    revalidatePath('/employees');\n    revalidatePath('/');\n    return { message: 'Successfully updated employee.' };\n}\n\n\nconst AddEmployeeRoleSchema = z.object({\n    name: z.string().min(2, 'Role name must be at least 2 characters'),\n});\n\nexport async function addEmployeeRoleAction(formData: FormData) {\n    const validatedFields = AddEmployeeRoleSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddEmployeeRole(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add role.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: `Successfully added role '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteEmployeeRoleAction(id: string) {\n    try {\n        await dbDeleteEmployeeRole(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete role.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: 'Successfully deleted role.' };\n}\n\nconst AddDepartmentSchema = z.object({\n    name: z.string().min(2, 'Department name must be at least 2 characters'),\n});\n\nexport async function addDepartmentAction(formData: FormData) {\n    const validatedFields = AddDepartmentSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddDepartment(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add department.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: `Successfully added department '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteDepartmentAction(id: string) {\n    try {\n        await dbDeleteDepartment(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete department.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: 'Successfully deleted department.' };\n}\n\n// CSV Import Actions\nconst ImportProductSchema = z.object({\n    name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n    price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n    gstRate: z.coerce.number().min(0).max(100),\n    skus: z.array(z.string()).optional(),\n    catalogueUrl: z.string().url('Please enter a valid URL.').optional().or(z.literal('')),\n});\n\nexport async function importProductsFromCSV(csvData: any[]) {\n    const results = {\n        success: 0,\n        failed: 0,\n        errors: [] as string[]\n    };\n\n// Get all existing product categories to match against\nconst allCategories = await getProductCategories();\n\n    for (let i = 0; i < csvData.length; i++) {\n        const row = csvData[i];\n        \n        try {\n            // Parse SKUs from comma-separated string\n            const skus = row.skus ? row.skus.split(',').map((sku: string) => sku.trim()).filter(Boolean) : [];\n            \n// Match category by exact name (single category)\nlet categoryId: string | undefined = undefined;\nconst categoryName = (row.category || row.categories || '').toString().trim();\nif (categoryName) {\n    const existingCategory = allCategories.find((c) => c.name === categoryName);\n    if (existingCategory) {\n        categoryId = existingCategory.id;\n    } else {\n        results.errors.push(`Row ${i + 1}: Category not found: ${categoryName}. Please create this category first.`);\n    }\n}\n            \n// Prepare data for validation, including optional fields\n            const dataForValidation = {\n                name: row.name,\n                price: row.price,\n                gstRate: row.gstRate,\n                ...(skus.length > 0 && { skus }),\n                ...(row.catalogueUrl && row.catalogueUrl.trim() && { catalogueUrl: row.catalogueUrl }),\n            };\n\n            const validatedData = ImportProductSchema.parse(dataForValidation);\n\n            // Prepare data for database - only include defined fields\nconst productData = {\n    name: validatedData.name,\n    price: validatedData.price,\n    gstRate: validatedData.gstRate,\n    ...(validatedData.skus && { skus: validatedData.skus }),\n    ...(validatedData.catalogueUrl && { catalogueUrl: validatedData.catalogueUrl }),\n    ...(categoryId && { categoryId }),\n};\n\n            await dbAddProduct(productData);\n            \n            results.success++;\n        } catch (error) {\n            results.failed++;\n            if (error instanceof z.ZodError) {\n                const errorMessages = error.errors.map(e => `Row ${i + 1}: ${e.path.join('.')} - ${e.message}`);\n                results.errors.push(...errorMessages);\n            } else {\n                results.errors.push(`Row ${i + 1}: Failed to import product - ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        }\n    }\n\n    // Revalidate pages after import\n    revalidatePath('/products');\n    revalidatePath('/leads');\n\n    return {\n        success: results.failed === 0,\n        message: `Import completed. ${results.success} products imported successfully${results.failed > 0 ? `, ${results.failed} failed` : ''}.`,\n        errors: results.errors.length > 0 ? results.errors : undefined\n    };\n}\n\n// Count Actions\nexport async function getLeadsCountAction(): Promise<number> {\n    try {\n        return await getLeadsCount();\n    } catch (error) {\n        console.error('Error getting leads count:', error);\n        return 0;\n    }\n}\n\nexport async function getQuotationsCountAction(): Promise<number> {\n    try {\n        return await getQuotationsCount();\n    } catch (error) {\n        console.error('Error getting quotations count:', error);\n        return 0;\n    }\n}\n\nexport async function getProductsCountAction(): Promise<number> {\n    try {\n        return await getProductsCount();\n    } catch (error) {\n        console.error('Error getting products count:', error);\n        return 0;\n    }\n}\n\nexport async function getEmployeesCountAction(): Promise<number> {\n    try {\n        return await getEmployeesCount();\n    } catch (error) {\n        console.error('Error getting employees count:', error);\n        return 0;\n    }\n}\n\nexport async function getLeadsCountByStatusAction(status: LeadStatus): Promise<number> {\n    try {\n        return await getLeadsCountByStatus(status);\n    } catch (error) {\n        console.error(`Error getting leads count for status ${status}:`, error);\n        return 0;\n    }\n}\n\nexport async function getQuotationsCountByStatusAction(status: 'Draft' | 'Sent' | 'Accepted' | 'Rejected'): Promise<number> {\n    try {\n        return await getQuotationsCountByStatus(status);\n    } catch (error) {\n        console.error(`Error getting quotations count for status ${status}:`, error);\n        return 0;\n    }\n}\n\nexport async function getActiveProductsCountAction(): Promise<number> {\n    try {\n        return await getActiveProductsCount();\n    } catch (error) {\n        console.error('Error getting active products count:', error);\n        return 0;\n    }\n}\n\nexport async function getActiveEmployeesCountAction(): Promise<number> {\n    try {\n        return await getActiveEmployeesCount();\n    } catch (error) {\n        console.error('Error getting active employees count:', error);\n        return 0;\n    }\n}\n\n// Communication Activity Actions\nconst CommunicationActivitySchema = z.object({\n  leadId: z.string().min(1, 'Lead ID is required'),\n  type: z.enum(['WhatsApp', 'Email']),\n  message: z.string().min(1, 'Message is required'),\n  contact: z.string().min(1, 'Contact is required'),\n  sentBy: z.string().min(1, 'Sent by is required'),\n});\n\nexport async function logCommunicationActivityAction(formData: FormData) {\n  const validatedFields = CommunicationActivitySchema.safeParse({\n    leadId: formData.get('leadId'),\n    type: formData.get('type'),\n    message: formData.get('message'),\n    contact: formData.get('contact'),\n    sentBy: formData.get('sentBy'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Missing Fields. Failed to log communication activity.',\n    };\n  }\n\n  const { leadId, type, message, contact, sentBy } = validatedFields.data;\n\n  try {\n    const activityNotes = `${type} message sent to ${contact} by ${sentBy}:\\n\\n\"${message}\"`;\n    \n    await addActivityToLead(leadId, {\n      type: type as 'WhatsApp' | 'Email',\n      notes: activityNotes\n    });\n  } catch (error) {\n    const errMsg = error instanceof Error ? error.message : String(error);\n    console.error('LogCommunicationActivity Error:', errMsg);\n    if (errMsg.includes('Lead not found')) {\n      return { message: 'Lead not found. Please refresh the page and try again.' };\n    }\n    return { message: 'Database Error: Failed to log communication activity.' };\n  }\n\n  return { message: `Successfully logged ${type} communication.` };\n}\n\nexport async function getCurrentUserEmployeeAction(email: string): Promise<Employee | null> {\n    try {\n        return await getEmployeeByEmail(email);\n    } catch (error) {\n        console.error('Error getting current user employee:', error);\n        return null;\n    }\n}\n\n// ==================== Currency Actions ====================\nimport { addCurrency as dbAddCurrency, updateCurrency as dbUpdateCurrency, deleteCurrency as dbDeleteCurrency } from './firestore-service';\n\nconst CurrencySchema = z.object({\n  code: z.string().min(2, 'Currency code must be at least 2 characters').max(5, 'Currency code must be at most 5 characters'),\n  name: z.string().min(2, 'Currency name is required'),\n  symbol: z.string().min(1, 'Currency symbol is required'),\n  conversionRate: z.coerce.number().positive('Conversion rate must be positive'),\n});\n\nexport async function addCurrencyAction(formData: FormData) {\n  const validatedFields = CurrencySchema.safeParse({\n    code: formData.get('code'),\n    name: formData.get('name'),\n    symbol: formData.get('symbol'),\n    conversionRate: formData.get('conversionRate'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Validation Error: Failed to add currency.',\n    };\n  }\n\n  try {\n    await dbAddCurrency(validatedFields.data);\n  } catch (error) {\n    return { message: 'Database Error: Failed to add currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully added currency.' };\n}\n\nexport async function updateCurrencyAction(id: string, formData: FormData) {\n  const validatedFields = CurrencySchema.safeParse({\n    code: formData.get('code'),\n    name: formData.get('name'),\n    symbol: formData.get('symbol'),\n    conversionRate: formData.get('conversionRate'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Validation Error: Failed to update currency.',\n    };\n  }\n\n  try {\n    await dbUpdateCurrency(id, validatedFields.data);\n  } catch (error) {\n    return { message: 'Database Error: Failed to update currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully updated currency.' };\n}\n\nexport async function deleteCurrencyAction(id: string) {\n  try {\n    await dbDeleteCurrency(id);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully deleted currency.' };\n}\n\n"],"names":[],"mappings":";;;;;;IAmvCsB,wBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 3102, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/products/import-products-dialog.tsx"],"sourcesContent":["'use client';\n\nimport { Button } from '@/components/ui/button';\nimport { CSVImportDialog } from '@/components/csv-import-dialog';\nimport { importProductsFromCSV } from '@/lib/actions';\nimport { Upload } from 'lucide-react';\n\nconst EXPECTED_COLUMNS = ['name', 'price', 'gstRate', 'skus', 'category'];\nconst REQUIRED_COLUMNS = ['name', 'price', 'gstRate'];\nconst OPTIONAL_COLUMNS = ['skus', 'category'];\n\nconst SAMPLE_DATA = {\n  name: 'Premium Widget',\n  price: '1500.00',\n  gstRate: '18',\n  skus: 'WID-001,WID-002,WID-003',\n  category: 'Widgets'\n};\n\nexport function ImportProductsDialog() {\n  const handleImport = async (csvData: any[]) => {\n    try {\n      const result = await importProductsFromCSV(csvData);\n      return result;\n    } catch (error) {\n      return {\n        success: false,\n        message: 'Import failed due to an unexpected error',\n        errors: [error instanceof Error ? error.message : 'Unknown error']\n      };\n    }\n  };\n\n  return (\n    <CSVImportDialog\n      title=\"Import Products from CSV\"\ndescription=\"Upload a CSV file to import multiple products at once. Make sure your CSV follows the expected format. Category should reference an existing category name.\"\n      expectedColumns={EXPECTED_COLUMNS}\n      requiredColumns={REQUIRED_COLUMNS}\n      sampleData={SAMPLE_DATA}\n      onImport={handleImport}\n    >\n      <Button variant=\"outline\" className=\"flex items-center gap-2\">\n        <Upload className=\"h-4 w-4\" />\n        Import CSV\n      </Button>\n    </CSVImportDialog>\n  );\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAOA,MAAM,mBAAmB;IAAC;IAAQ;IAAS;IAAW;IAAQ;CAAW;AACzE,MAAM,mBAAmB;IAAC;IAAQ;IAAS;CAAU;AACrD,MAAM,mBAAmB;IAAC;IAAQ;CAAW;AAE7C,MAAM,cAAc;IAClB,MAAM;IACN,OAAO;IACP,SAAS;IACT,MAAM;IACN,UAAU;AACZ;AAEO,SAAS;IACd,MAAM,eAAe,OAAO;QAC1B,IAAI;YACF,MAAM,SAAS,MAAM,CAAA,GAAA,kJAAA,CAAA,wBAAqB,AAAD,EAAE;YAC3C,OAAO;QACT,EAAE,OAAO,OAAO;YACd,OAAO;gBACL,SAAS;gBACT,SAAS;gBACT,QAAQ;oBAAC,iBAAiB,QAAQ,MAAM,OAAO,GAAG;iBAAgB;YACpE;QACF;IACF;IAEA,qBACE,8OAAC,6IAAA,CAAA,kBAAe;QACd,OAAM;QACZ,aAAY;QACN,iBAAiB;QACjB,iBAAiB;QACjB,YAAY;QACZ,UAAU;kBAEV,cAAA,8OAAC,kIAAA,CAAA,SAAM;YAAC,SAAQ;YAAU,WAAU;;8BAClC,8OAAC,sMAAA,CAAA,SAAM;oBAAC,WAAU;;;;;;gBAAY;;;;;;;;;;;;AAKtC","debugId":null}},
    {"offset": {"line": 3191, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { getAuth } from 'firebase-admin/auth';\nimport { initializeApp, getApps, cert } from 'firebase-admin/app';\nimport { summarizeMeetingNotes } from '@/ai/flows/summarize-meeting-notes';\nimport { addLead as dbAddLead, addActivityToLead, updateLeadStatus as updateStatus, addProduct as dbAddProduct, addLeadSource as dbAddLeadSource, deleteLeadSource as dbDeleteLeadSource, addProductCategory as dbAddProductCategory, deleteProductCategory as dbDeleteProductCategory, getProductCategories, updateLead as dbUpdateLead, getLeadById as dbGetLeadById, deleteLead as dbDeleteLead, addQuotation as dbAddQuotation, updateQuotation as dbUpdateQuotation, deleteQuotation as dbDeleteQuotation, addQuotationTemplate as dbAddQuotationTemplate, updateProduct as dbUpdateProduct, deleteProduct as dbDeleteProduct, addEmployee as dbAddEmployee, deleteEmployee as dbDeleteEmployee, updateEmployee as dbUpdateEmployee, getEmployeeByEmail, getEmployeeRoles, addEmployeeRole as dbAddEmployeeRole, deleteEmployeeRole as dbDeleteEmployeeRole, getDepartments, addDepartment as dbAddDepartment, deleteDepartment as dbDeleteDepartment, updateQuotationTemplate as dbUpdateQuotationTemplate, deleteQuotationTemplate as dbDeleteQuotationTemplate, getLeadsCount, getQuotationsCount, getProductsCount, getEmployeesCount, getLeadsCountByStatus, getQuotationsCountByStatus, getActiveProductsCount, getActiveEmployeesCount, updateProductCategory as dbUpdateProductCategory } from './data';\nimport { deletePDFFromStorage, deleteImageFromStorage, uploadImageToStorage } from './storage-utils';\nimport type { Lead, LeadStatus, LeadProduct, UpdatableLeadData, Product, NewQuotationTemplate, Quotation, NewEmployee, QuotationTemplate } from './types';\nimport type { Employee } from './business-types';\nimport { getProducts } from './data';\n\n// Initialize Firebase Admin SDK\nfunction initializeFirebaseAdmin() {\n  if (getApps().length === 0) {\n    // Check if all required environment variables are present\n    const requiredEnvVars = [\n      'FIREBASE_PROJECT_ID',\n      'FIREBASE_PRIVATE_KEY',\n      'FIREBASE_CLIENT_EMAIL'\n    ];\n    \n    const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n    \n    if (missingVars.length > 0) {\n      throw new Error(`Missing required Firebase environment variables: ${missingVars.join(', ')}`);\n    }\n\n    const serviceAccount = {\n      type: \"service_account\",\n      project_id: process.env.FIREBASE_PROJECT_ID!,\n      private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,\n      private_key: process.env.FIREBASE_PRIVATE_KEY!.replace(/\\\\n/g, '\\n'),\n      client_email: process.env.FIREBASE_CLIENT_EMAIL!,\n      client_id: process.env.FIREBASE_CLIENT_ID,\n      auth_uri: \"https://accounts.google.com/o/oauth2/auth\",\n      token_uri: \"https://oauth2.googleapis.com/token\",\n      auth_provider_x509_cert_url: \"https://www.googleapis.com/oauth2/v1/certs\",\n      client_x509_cert_url: `https://www.googleapis.com/robot/v1/metadata/x509/${process.env.FIREBASE_CLIENT_EMAIL}`\n    };\n\n    initializeApp({\n      credential: cert(serviceAccount as any),\n      projectId: process.env.FIREBASE_PROJECT_ID,\n    });\n  }\n}\n\nconst LeadProductSchema = z.object({\n    productId: z.string().min(1, 'Product must be selected'),\n    quantity: z.coerce.number().min(1),\n    rate: z.coerce.number().min(0),\n    selectedSku: z.string().optional(),\n});\n\nconst CreateLeadSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  company: z.string().min(2, 'Company must be at least 2 characters'),\n  email: z.string().email('Invalid email address'),\n  phone: z.string().min(10, 'Phone number seems too short'),\n  whatsappNumber: z.string().optional().or(z.literal('')),\n  client_address: z.string().optional().or(z.literal('')),\n  client_gst_no: z.string().optional().or(z.literal('')),\n  status: z.enum(['New', 'In Discussion', 'Negotiation', 'Closed - Won', 'Closed - Lost']),\n  source: z.string().min(1, 'Please select a lead source'),\n  notes: z.string().optional(),\n  products: z.array(LeadProductSchema).optional(),\n  createdBy: z.string().min(1, 'Created by field is required'),\n});\n\nexport async function createLead(formData: FormData) {\n  const productsJSON = formData.get('products');\n  const products = productsJSON ? JSON.parse(productsJSON as string) : [];\n\n  const validatedFields = CreateLeadSchema.safeParse({\n    name: formData.get('name'),\n    company: formData.get('company'),\n    email: formData.get('email'),\n    phone: formData.get('phone'),\n    whatsappNumber: formData.get('whatsappNumber'),\n    client_address: formData.get('client_address'),\n    client_gst_no: formData.get('client_gst_no'),\n    status: formData.get('status'),\n    source: formData.get('source'),\n    notes: formData.get('notes'),\n    products: products,\n    createdBy: formData.get('createdBy'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Failed to create lead.',\n    };\n  }\n  \n  let newLeadId: string | undefined;\n  try {\n    const leadData = {\n      ...validatedFields.data,\n      products: validatedFields.data.products || []\n    };\n    const newLead = await dbAddLead(leadData);\n    newLeadId = newLead.id;\n  } catch (error) {\n    return { message: 'Database Error: Failed to Create Lead.' };\n  }\n\n  revalidatePath('/leads');\n  revalidatePath('/');\n  if (newLeadId) {\n    revalidatePath(`/leads/${newLeadId}`);\n  }\n  return { message: 'Successfully created lead.' };\n}\n\nconst UpdateLeadSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  company: z.string().min(2, 'Company must be at least 2 characters'),\n  email: z.string().email('Invalid email address'),\n  phone: z.string().min(10, 'Phone number seems too short'),\n  whatsappNumber: z.string().optional().or(z.literal('')),\n  client_address: z.string().optional().or(z.literal('')),\n  client_gst_no: z.string().optional().or(z.literal('')),\n  status: z.enum(['New', 'In Discussion', 'Negotiation', 'Closed - Won', 'Closed - Lost']),\n  source: z.string().min(1, 'Please select a lead source'),\n  products: z.array(LeadProductSchema).optional(),\n});\n\nfunction generateChangeNotes(oldLead: Lead, newLeadData: UpdatableLeadData, allProducts: Product[]): string {\n    const changes: string[] = [];\n\n    if (oldLead.name !== newLeadData.name) {\n        changes.push(`Name changed from \"${oldLead.name}\" to \"${newLeadData.name}\".`);\n    }\n    if (oldLead.company !== newLeadData.company) {\n        changes.push(`Company changed from \"${oldLead.company}\" to \"${newLeadData.company}\".`);\n    }\n    if (oldLead.email !== newLeadData.email) {\n        changes.push(`Email changed from \"${oldLead.email}\" to \"${newLeadData.email}\".`);\n    }\n    if (oldLead.phone !== newLeadData.phone) {\n        changes.push(`Phone changed from \"${oldLead.phone}\" to \"${newLeadData.phone}\".`);\n    }\n    if (oldLead.whatsappNumber !== newLeadData.whatsappNumber) {\n        changes.push(`WhatsApp Number changed from \"${oldLead.whatsappNumber || 'N/A'}\" to \"${newLeadData.whatsappNumber || 'N/A'}\".`);\n    }\n    if (oldLead.client_address !== newLeadData.client_address) {\n        changes.push(`Client Address changed from \"${oldLead.client_address || 'N/A'}\" to \"${newLeadData.client_address || 'N/A'}\".`);\n    }\n    if (oldLead.client_gst_no !== newLeadData.client_gst_no) {\n        changes.push(`Client GST Number changed from \"${oldLead.client_gst_no || 'N/A'}\" to \"${newLeadData.client_gst_no || 'N/A'}\".`);\n    }\n    if (oldLead.status !== newLeadData.status) {\n        changes.push(`Status changed from \"${oldLead.status}\" to \"${newLeadData.status}\".`);\n    }\n    if (oldLead.source !== newLeadData.source) {\n        changes.push(`Source changed from \"${oldLead.source}\" to \"${newLeadData.source}\".`);\n    }\n\n    const oldProducts = oldLead.products || [];\n    const newProducts = newLeadData.products || [];\n    if (JSON.stringify(oldProducts) !== JSON.stringify(newProducts)) {\n        const getProductName = (productId: string) => allProducts.find(p => p.id === productId)?.name || productId;\n        \n        const formatProduct = (p: LeadProduct) => `${getProductName(p.productId)} (Qty: ${p.quantity}, Rate: ${p.rate}, SKU: ${p.selectedSku || 'N/A'})`;\n\n        const oldProductStr = oldProducts.map(formatProduct).join(', ') || 'None';\n        const newProductStr = newProducts.map(formatProduct).join(', ') || 'None';\n\n        changes.push(`Interested products updated.\\n- Old: ${oldProductStr}\\n- New: ${newProductStr}`);\n    }\n\n    if (changes.length === 0) {\n        return 'No changes were made to the lead details.';\n    }\n\n    return 'Lead details were updated:\\n' + changes.map(c => `- ${c}`).join('\\n');\n}\n\nexport async function updateLead(leadId: string, formData: FormData) {\n    const [oldLead, allProducts] = await Promise.all([\n        dbGetLeadById(leadId),\n        getProducts()\n    ]);\n\n    if (!oldLead) {\n        return { message: 'Error: Lead not found.' };\n    }\n\n    const productsJSON = formData.get('products');\n    const products = productsJSON ? JSON.parse(productsJSON as string) : [];\n  \n    const validatedFields = UpdateLeadSchema.safeParse({\n      name: formData.get('name'),\n      company: formData.get('company'),\n      email: formData.get('email'),\n      phone: formData.get('phone'),\n      whatsappNumber: formData.get('whatsappNumber'),\n      client_address: formData.get('client_address'),\n      client_gst_no: formData.get('client_gst_no'),\n      status: formData.get('status'),\n      source: formData.get('source'),\n      products: products,\n    });\n  \n    if (!validatedFields.success) {\n      return {\n        errors: validatedFields.error.flatten().fieldErrors,\n        message: 'Failed to update lead.',\n      };\n    }\n\n    const newLeadData = validatedFields.data as UpdatableLeadData;\n    const changeNotes = generateChangeNotes(oldLead, newLeadData, allProducts);\n  \n    try {\n        await dbUpdateLead(leadId, newLeadData);\n        if (changeNotes !== 'No changes were made to the lead details.') {\n            await addActivityToLead(leadId, {\n                type: 'Revision Request',\n                notes: changeNotes\n            });\n        }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'An unknown error occurred';\n      return { message: `Database Error: Failed to Update Lead. ${message}` };\n    }\n  \n    revalidatePath('/leads');\n    revalidatePath('/');\n    revalidatePath(`/leads/${leadId}`);\n    return { message: 'Successfully updated lead.' };\n}\n\nconst ProductSchema = z.object({\n    name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n    price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n    gstRate: z.coerce.number().min(0).max(100),\n    categoryId: z.string().optional(),\n    description: z.string().optional(),\n    skus: z.array(z.string()).optional(),\n    catalogueUrl: z.string().url('Please enter a valid URL.').optional().or(z.literal('')),\n    cataloguePdf: z.object({\n        url: z.string(),\n        fileName: z.string(),\n        filePath: z.string(),\n        uploadedAt: z.string(),\n    }).optional(),\n    productImage: z.object({\n        url: z.string(),\n        fileName: z.string(),\n        filePath: z.string(),\n        uploadedAt: z.string(),\n    }).optional(),\n});\n\nexport async function addProduct(formData: FormData) {\n  const skusJSON = formData.get('skus');\n  const skus = skusJSON ? JSON.parse(skusJSON as string) : [];\n  \n  const catalogPdfJSON = formData.get('catalogPdf');\n  const catalogPdf = catalogPdfJSON ? JSON.parse(catalogPdfJSON as string) : undefined;\n  \n  const productImageJSON = formData.get('productImage');\n  console.log('Product Image JSON received:', productImageJSON);\n  const productImage = productImageJSON ? JSON.parse(productImageJSON as string) : undefined;\n  console.log('Product Image parsed:', productImage);\n  \n  const validatedFields = ProductSchema.safeParse({\n    name: formData.get('name'),\n    price: formData.get('price'),\n    gstRate: formData.get('gstRate'),\n    categoryId: formData.get('categoryId'),\n    description: formData.get('description') || undefined,\n    skus: skus,\n    catalogueUrl: formData.get('catalogueUrl') || '',\n    cataloguePdf: catalogPdf,\n    productImage: productImage,\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Failed to add product.',\n    };\n  }\n\n  try {\n    const data = validatedFields.data;\n    // Remove undefined values before sending to Firestore\n    const cleanData = Object.fromEntries(\n      Object.entries(data).filter(([_, v]) => v !== undefined)\n    );\n    \n    console.log('Clean data being sent to database:', JSON.stringify(cleanData, null, 2));\n    \n    // Create the product\n    const newProduct = await dbAddProduct(cleanData as any);\n    \n  } catch (error) {\n    return { message: 'Database Error: Failed to add product.' };\n  }\n\n  revalidatePath('/products');\n  revalidatePath('/leads'); // Revalidate leads in case product info is needed\n  return { message: 'Successfully added product.' };\n}\n\nexport async function updateProduct(id: string, formData: FormData) {\n    const skusJSON = formData.get('skus');\n    const skus = skusJSON ? JSON.parse(skusJSON as string) : [];\n\n    const catalogPdfJSON = formData.get('catalogPdf');\n    const catalogPdf = catalogPdfJSON ? JSON.parse(catalogPdfJSON as string) : undefined;\n    const removeCatalogPdf = String(formData.get('removeCatalogPdf') || '').toLowerCase() === 'true';\n\n    // Handle product image - can be File object (new upload) or JSON string (existing metadata)\n    const productImageData = formData.get('productImage');\n    const existingProductImageJSON = formData.get('existingProductImage');\n    const removeProductImage = String(formData.get('removeProductImage') || '').toLowerCase() === 'true';\n    \n    let productImage: any = undefined;\n    \n    // If there's a new file upload, handle it\n    if (productImageData instanceof File) {\n      try {\n        const uploadResult = await uploadImageToStorage(productImageData, 'products');\n        productImage = {\n          url: uploadResult.url,\n          fileName: uploadResult.fileName,\n          filePath: uploadResult.path,\n          uploadedAt: new Date().toISOString(),\n        };\n      } catch (error) {\n        console.error('Failed to upload product image:', error);\n        return { message: 'Failed to upload product image.' };\n      }\n    } else if (existingProductImageJSON && !removeProductImage) {\n      // Keep existing image metadata\n      productImage = JSON.parse(existingProductImageJSON as string);\n    }\n\n    // Debug logs removed\n    \n    const validatedFields = ProductSchema.safeParse({\n      name: formData.get('name'),\n      price: formData.get('price'),\n      gstRate: formData.get('gstRate'),\n      categoryId: formData.get('categoryId'),\n      description: formData.get('description') || undefined,\n      skus: skus,\n      catalogueUrl: formData.get('catalogueUrl') || '',\n      cataloguePdf: catalogPdf,\n      productImage: productImage,\n    });\n\n    if (!validatedFields.success) {\n      return {\n        errors: validatedFields.error.flatten().fieldErrors,\n        message: 'Failed to update product.',\n      };\n    }\n\n    try {\n      // Get the current product to check for existing PDF\n      const currentProduct = await getProducts().then(products => \n        products.find(p => p.id === id)\n      );\n      \n      const data = validatedFields.data as any;\n      const updateData: any = { ...data };\n      \n      // If user explicitly removed the existing PDF and didn't upload a new one, clear the field\n      if (removeCatalogPdf && !catalogPdf) {\n        // Delete the old PDF from Firebase Storage if it exists\n        if (currentProduct?.cataloguePdf?.filePath) {\n          try {\n            await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n          } catch (error) {\n            console.error('Failed to delete PDF from storage:', error);\n            // Continue with the update even if PDF deletion fails\n          }\n        }\n        updateData.cataloguePdf = null; // This will clear the field in Firestore\n      } else if (catalogPdf && currentProduct?.cataloguePdf?.filePath && \n                 currentProduct.cataloguePdf.filePath !== catalogPdf.filePath) {\n        // If a new PDF was uploaded, delete the old one from storage\n        try {\n          await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n        } catch (error) {\n          console.error('Failed to delete old PDF from storage:', error);\n          // Continue with the update even if old PDF deletion fails\n        }\n      }\n      \n      // Handle product image storage cleanup if new image was uploaded\n      if (productImageData instanceof File && currentProduct?.productImage?.filePath) {\n        // Delete the old image from storage since we have a new one\n        try {\n          await deleteImageFromStorage(currentProduct.productImage.filePath);\n        } catch (error) {\n          console.error('Failed to delete old product image from storage:', error);\n          // Continue with the update even if old image deletion fails\n        }\n      }\n      \n      // Handle product image removal\n      if (removeProductImage && !productImageData) {\n        // Delete the existing image from storage\n        if (currentProduct?.productImage?.filePath) {\n          try {\n            await deleteImageFromStorage(currentProduct.productImage.filePath);\n          } catch (error) {\n            console.error('Failed to delete product image from storage:', error);\n          }\n        }\n        updateData.productImage = null; // This will clear the field in Firestore\n      }\n      \n      // Ensure new uploads are persisted\n      if (catalogPdf) {\n        updateData.cataloguePdf = catalogPdf;\n      }\n      if (productImage) {\n        updateData.productImage = productImage;\n      }\n      \n      // Remove undefined values from updateData as Firestore doesn't accept them\n      const cleanedUpdateData: any = {};\n      for (const [key, value] of Object.entries(updateData)) {\n        if (value !== undefined) {\n          cleanedUpdateData[key] = value;\n        }\n      }\n      \n      console.log('[updateProduct] cleanedUpdateData keys:', Object.keys(cleanedUpdateData));\n      console.log('[updateProduct] cleanedUpdateData.productImage:', cleanedUpdateData.productImage);\n      \n      await dbUpdateProduct(id, cleanedUpdateData);\n    } catch (error) {\n      return { message: 'Database Error: Failed to update product.' };\n    }\n\n    revalidatePath('/products');\n    revalidatePath('/leads');\n    return { message: 'Successfully updated product.' };\n  }\n  \n  export async function deleteProduct(id: string) {\n    try {\n      // Get the current product to check for PDF before deletion\n      const currentProduct = await getProducts().then(products => \n        products.find(p => p.id === id)\n      );\n      \n      // Delete the PDF from Firebase Storage if it exists\n      if (currentProduct?.cataloguePdf?.filePath) {\n        try {\n          await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n        } catch (error) {\n          console.error('Failed to delete PDF from storage:', error);\n          // Continue with product deletion even if PDF deletion fails\n        }\n      }\n      \n      await dbDeleteProduct(id);\n    } catch (error) {\n      return { message: 'Database Error: Failed to delete product.' };\n    }\n\n    revalidatePath('/products');\n    revalidatePath('/leads');\n    return { message: 'Successfully deleted product.' };\n  }\n\n\nconst LogActivitySchema = z.object({\n    leadId: z.string(),\n    type: z.enum(['Meeting', 'Call', 'Email', 'Revision Request', 'Proposal Sent']),\n    notes: z.string().optional(),\n    summary: z.string().optional(),\n});\n\nexport async function logActivity(formData: FormData) {\n    const validatedFields = LogActivitySchema.safeParse({\n        leadId: formData.get('leadId'),\n        type: formData.get('type'),\n        notes: formData.get('notes'),\n        summary: formData.get('summary') || undefined,\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to log activity.',\n        };\n    }\n\n    try {\n        const { leadId, ...activityData } = validatedFields.data;\n        await addActivityToLead(leadId, activityData);\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        console.error('LogActivity Error:', message);\n        if (message.includes('Lead not found')) {\n            return { message: 'Lead not found. Please refresh the page and try again.' };\n        }\n        return { message: 'Database Error: Failed to log activity.' };\n    }\n\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    revalidatePath('/');\n    return { message: 'Successfully logged activity.' };\n}\n\nexport async function getSummaryForNotes(notes: string): Promise<{ summary?: string; error?: string }> {\n  if (!notes || notes.trim().length < 50) {\n    return { error: 'Please provide at least 50 characters of notes to summarize.' };\n  }\n  try {\n    const result = await summarizeMeetingNotes({ notes });\n    return result;\n  } catch (e) {\n    console.error('AI Summarization Error:', e);\n    return { error: 'Failed to generate summary due to an internal error.' };\n  }\n}\n\n\nexport async function updateLeadStatusAction(leadId: string, status: LeadStatus, userId?: string, userName?: string) {\n  try {\n    // Get the current lead to capture the previous status\n    const currentLead = await dbGetLeadById(leadId);\n    if (!currentLead) {\n      return { message: 'Lead not found.' };\n    }\n    \n    const previousStatus = currentLead.status;\n    \n    // Only update if status is actually changing\n    if (previousStatus === status) {\n      return { message: 'Status is already set to this value.' };\n    }\n    \n    // Update the status\n    await updateStatus(leadId, status);\n    \n    // Add a status change activity\n    const changedBy = userName || userId || 'Unknown User';\n    const statusChangeNotes = `Status changed from \"${previousStatus}\" to \"${status}\" by ${changedBy}`;\n    \n    await addActivityToLead(leadId, {\n      type: 'Status Change',\n      notes: statusChangeNotes\n    });\n    \n  } catch (error) {\n    return { message: 'Database Error: Failed to update status.' };\n  }\n  revalidatePath(`/leads/${leadId}`);\n  revalidatePath('/leads');\n  revalidatePath('/');\n  return { message: 'Status updated successfully.' };\n}\n\nexport async function deleteLeadAction(leadId: string) {\n  try {\n    await dbDeleteLead(leadId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete lead.' };\n  }\n  revalidatePath('/leads');\n  revalidatePath('/');\n  return { message: 'Successfully deleted lead.' };\n}\n\nconst AddLeadSourceSchema = z.object({\n    name: z.string().min(2, 'Source name must be at least 2 characters'),\n});\n\nexport async function addLeadSourceAction(formData: FormData) {\n    const validatedFields = AddLeadSourceSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddLeadSource(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add lead source.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/leads');\n    return { message: `Successfully added '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteLeadSourceAction(id: string) {\n    try {\n        await dbDeleteLeadSource(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete lead source.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/leads');\n    return { message: 'Successfully deleted lead source.' };\n}\n\nconst AddProductCategorySchema = z.object({\n    name: z.string().min(2, 'Category name must be at least 2 characters'),\n    description: z.string().optional().nullable(),\n});\n\nexport async function addProductCategoryAction(formData: FormData) {\n    const validatedFields = AddProductCategorySchema.safeParse({\n        name: formData.get('name'),\n        description: formData.get('description'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        // Convert null to undefined for optional description\n        const description = validatedFields.data.description || '';\n        await dbAddProductCategory(validatedFields.data.name, description);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add product category.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: `Successfully added '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteProductCategoryAction(id: string) {\n    try {\n        await dbDeleteProductCategory(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete product category.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: 'Successfully deleted product category.' };\n}\n\n// Update an existing product category's name/description\nexport async function updateProductCategoryAction(id: string, name: string, description?: string) {\n    try {\n        await dbUpdateProductCategory(id, name, description || '');\n    } catch (error) {\n        const message = error instanceof Error ? error.message : 'Unknown error';\n        return { message: `Database Error: Failed to update product category. ${message}` };\n    }\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: 'Successfully updated product category.' };\n}\n\nexport async function getProductCategoriesAction() {\n    try {\n        const categories = await getProductCategories();\n        return categories;\n    } catch (error) {\n        console.error('Error fetching product categories:', error);\n        return [];\n    }\n}\n\n\nconst CreateQuotationSchema = z.object({\n  leadId: z.string().min(1),\n  templateId: z.string().min(1),\n  date: z.string(),\n  validUntil: z.string(),\n  status: z.enum(['Draft', 'Sent', 'Accepted', 'Rejected']),\n  products: z.string(), // JSON string\n  subTotal: z.coerce.number(),\n  totalGst: z.coerce.number(),\n  grandTotal: z.coerce.number(),\n  quotationPrefix: z.string().optional(),\n  // Overridable template fields\n  companyName: z.string().min(1),\n  companyAddress: z.string().min(1),\n  companyGst: z.string().optional().or(z.literal('')).nullable(),\n  // Client billing fields\n  client_address: z.string().optional().or(z.literal('')).nullable(),\n  client_gst_no: z.string().optional().or(z.literal('')).nullable(),\n  termsAndConditions: z.string(),\n  logoUrl: z.string().optional().nullable(),\n  // Additional charges (numeric or empty/null)\n  freightCharges: z.coerce.number().min(0).optional().or(z.literal('')).nullable(),\n  courierCharges: z.coerce.number().min(0).optional().or(z.literal('')).nullable(),\n  // Flags to show/hide charges in PDF\n  showFreight: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return false; // default to false\n  }, z.boolean()).optional(),\n  showCourier: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return false; // default to false\n  }, z.boolean()).optional(),\n  // GST visibility control\n  showGst: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return true; // default to true for backward compatibility\n  }, z.boolean()).optional(),\n  // Currency fields\n  currencyCode: z.string().optional(),\n  currencySymbol: z.string().optional(),\n  conversionRate: z.coerce.number().optional(),\n});\n\n\nexport async function addQuotation(formData: FormData) {\n    console.log('Server received quotationPrefix:', formData.get('quotationPrefix'));\n    const validatedFields = CreateQuotationSchema.safeParse({\n        leadId: formData.get('leadId'),\n        templateId: formData.get('templateId'),\n        date: formData.get('date'),\n        validUntil: formData.get('validUntil'),\n        status: formData.get('status'),\n        products: formData.get('products'),\n        subTotal: formData.get('subTotal'),\n        totalGst: formData.get('totalGst'),\n        grandTotal: formData.get('grandTotal'),\n        quotationPrefix: formData.get('quotationPrefix') || '',\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        client_address: formData.get('client_address'),\n        client_gst_no: formData.get('client_gst_no'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n        freightCharges: formData.get('freightCharges'),\n        courierCharges: formData.get('courierCharges'),\n        showFreight: formData.get('showFreight'),\n        showCourier: formData.get('showCourier'),\n        showGst: formData.get('showGst'),\n        currencyCode: formData.get('currencyCode'),\n        currencySymbol: formData.get('currencySymbol'),\n        conversionRate: formData.get('conversionRate'),\n      });\n    \n      if (!validatedFields.success) {\n        console.error(validatedFields.error.flatten().fieldErrors);\n        return {\n          errors: validatedFields.error.flatten().fieldErrors,\n          message: 'Validation Error: Failed to create quotation.',\n        };\n      }\n      \n      let newQuotation: Quotation | undefined;\n      try {\n        const data = validatedFields.data;\n        const parsedProducts = JSON.parse(data.products);\n        const prefix = (data.quotationPrefix?.trim() || 'QUO');\n        console.log('Using prefix:', prefix);\n        const { quotationPrefix: _omitPrefix, logoUrl, ...rest } = data as any;\n        \n        // Clean up null values - convert to undefined for Firestore\n        const payload: any = {\n          ...rest,\n          products: parsedProducts,\n          companyGst: rest.companyGst || undefined,\n          client_address: rest.client_address || undefined,\n          client_gst_no: rest.client_gst_no || undefined,\n          freightCharges: rest.freightCharges || undefined,\n          courierCharges: rest.courierCharges || undefined,\n          showFreight: rest.showFreight === true || rest.showFreight === 'true',\n          showCourier: rest.showCourier === true || rest.showCourier === 'true',\n        };\n        if (logoUrl) payload.logoUrl = logoUrl;\n        newQuotation = await dbAddQuotation(payload, prefix);\n\n        // Log activity on the lead\n        await addActivityToLead(data.leadId, {\n            type: 'Proposal Sent',\n            notes: `Quotation ${newQuotation.quotationNumber} was created and sent.`\n        });\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return { message: `Database Error: Failed to Create Quotation. ${message}` };\n      }\n\n    revalidatePath('/quotations');\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    return { message: 'Successfully created quotation.' };\n}\n\nexport async function updateQuotation(id: string, formData: FormData) {\n    const validatedFields = CreateQuotationSchema.safeParse({\n        leadId: formData.get('leadId'),\n        templateId: formData.get('templateId'),\n        date: formData.get('date'),\n        validUntil: formData.get('validUntil'),\n        status: formData.get('status'),\n        products: formData.get('products'),\n        subTotal: formData.get('subTotal'),\n        totalGst: formData.get('totalGst'),\n        grandTotal: formData.get('grandTotal'),\n        quotationPrefix: formData.get('quotationPrefix') || '',\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        client_address: formData.get('client_address'),\n        client_gst_no: formData.get('client_gst_no'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n        freightCharges: formData.get('freightCharges'),\n        courierCharges: formData.get('courierCharges'),\n        showFreight: formData.get('showFreight'),\n        showCourier: formData.get('showCourier'),\n        showGst: formData.get('showGst'),\n        currencyCode: formData.get('currencyCode'),\n        currencySymbol: formData.get('currencySymbol'),\n        conversionRate: formData.get('conversionRate'),\n      });\n    \n      if (!validatedFields.success) {\n        console.error(validatedFields.error.flatten().fieldErrors);\n        return {\n          errors: validatedFields.error.flatten().fieldErrors,\n          message: 'Validation Error: Failed to update quotation.',\n        };\n      }\n      \n      try {\n        const data = validatedFields.data;\n        const parsedProducts = JSON.parse(data.products);\n        \n        // Clean up null values - convert to undefined for Firestore\n        await dbUpdateQuotation(id, {\n            ...data,\n            logoUrl: data.logoUrl || undefined,\n            companyGst: data.companyGst || undefined,\n            client_address: data.client_address || undefined,\n            client_gst_no: data.client_gst_no || undefined,\n            freightCharges: data.freightCharges || undefined,\n            courierCharges: data.courierCharges || undefined,\n            showFreight: data.showFreight === true || data.showFreight === 'true',\n            showCourier: data.showCourier === true || data.showCourier === 'true',\n            products: parsedProducts,\n        });\n\n        // Log activity on the lead\n        await addActivityToLead(data.leadId, {\n            type: 'Revision Request',\n            notes: `Quotation was updated.`\n        });\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return { message: `Database Error: Failed to Update Quotation. ${message}` };\n      }\n\n    revalidatePath('/quotations');\n    revalidatePath(`/quotations/${id}`);\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    return { message: 'Successfully updated quotation.' };\n}\n\nexport async function deleteQuotationAction(quotationId: string) {\n  try {\n    await dbDeleteQuotation(quotationId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete quotation.' };\n  }\n  revalidatePath('/quotations');\n  revalidatePath('/');\n  return { message: 'Successfully deleted quotation.' };\n}\n\n\nconst QuotationTemplateSchema = z.object({\n    name: z.string().min(3, 'Template name must be at least 3 characters.'),\n    prefix: z.string().min(1, 'Prefix is required.'),\n    companyName: z.string().min(3, 'Company name is required.'),\n    companyAddress: z.string().min(10, 'Full company address is required.'),\n    companyGst: z.string().min(15, 'A valid GSTIN is required.').max(15),\n    termsAndConditions: z.string().min(20, 'Terms and conditions are required.'),\n    logoUrl: z.string().url('Please enter a valid URL for the logo.').optional().or(z.literal('')),\n});\n\nexport async function addQuotationTemplateAction(formData: FormData) {\n    const validatedFields = QuotationTemplateSchema.safeParse({\n        name: formData.get('name'),\n        prefix: formData.get('prefix'),\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to create template. Please check the fields.',\n        };\n    }\n\n    try {\n        await dbAddQuotationTemplate(validatedFields.data as NewQuotationTemplate);\n    } catch (error) {\n        return { message: 'Database Error: Failed to create template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully created quotation template.' };\n}\n\nexport async function updateQuotationTemplateAction(id: string, formData: FormData) {\n    const validatedFields = QuotationTemplateSchema.safeParse({\n        name: formData.get('name'),\n        prefix: formData.get('prefix'),\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to update template. Please check the fields.',\n        };\n    }\n\n    try {\n        await dbUpdateQuotationTemplate(id, validatedFields.data as QuotationTemplate);\n    } catch (error) {\n        return { message: 'Database Error: Failed to update template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully updated quotation template.' };\n}\n\nexport async function deleteQuotationTemplateAction(id: string) {\n    try {\n        await dbDeleteQuotationTemplate(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully deleted quotation template.' };\n}\n\n\nconst AddEmployeeSchema = z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters.'),\n    email: z.string().email('Please enter a valid email.'),\n    phone: z.string().min(10, 'Please enter a valid phone number.'),\n    role: z.string({\n      required_error: \"You need to select a role.\",\n    }),\n    department: z.string({\n        required_error: \"You need to select a department.\",\n    }),\n    address: z.string().min(10, 'Address is required.'),\n});\n\nexport async function addEmployeeAction(formData: FormData) {\n    const validatedFields = AddEmployeeSchema.safeParse({\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        role: formData.get('role'),\n        department: formData.get('department'),\n        address: formData.get('address'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to add employee.',\n        };\n    }\n\n    const [employeeRoles, departments] = await Promise.all([\n        getEmployeeRoles(),\n        getDepartments(),\n    ]);\n\n    const roleExists = employeeRoles.some(r => r.name === validatedFields.data.role);\n    if (!roleExists) {\n        return { message: 'Invalid role selected.' };\n    }\n    const departmentExists = departments.some(d => d.name === validatedFields.data.department);\n    if (!departmentExists) {\n        return { message: 'Invalid department selected.' };\n    }\n\n    try {\n        // Check if Firebase Admin environment variables are configured\n        const requiredEnvVars = ['FIREBASE_PROJECT_ID', 'FIREBASE_PRIVATE_KEY', 'FIREBASE_CLIENT_EMAIL'];\n        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n        \n        if (missingVars.length > 0) {\n            console.warn(`Firebase Admin not configured. Missing: ${missingVars.join(', ')}`);\n            // Just add to database without Firebase Auth integration\n            await dbAddEmployee(validatedFields.data as NewEmployee);\n            revalidatePath('/employees');\n            return { \n                message: 'Employee added to database. Note: Firebase Auth integration requires environment variables to be configured for automatic account creation and email sending.'\n            };\n        }\n\n        // Initialize Firebase Admin\n        initializeFirebaseAdmin();\n        const auth = getAuth();\n\n        // Create user in Firebase Auth\n        const userRecord = await auth.createUser({\n            email: validatedFields.data.email,\n            displayName: validatedFields.data.name,\n            emailVerified: false,\n        });\n\n        // Add employee to database first\n        await dbAddEmployee(validatedFields.data as NewEmployee);\n\n        // Set a temporary password for the user\n        const tempPassword = Math.random().toString(36).slice(-12) + 'A1!'; // Ensure it meets Firebase requirements\n        \n        // Update the user with the temporary password\n        await auth.updateUser(userRecord.uid, {\n            password: tempPassword,\n        });\n\n        // Send password reset email using Firebase Auth's REST API\n        try {\n            const webApiKey = process.env.FIREBASE_WEB_API_KEY;\n            \n            if (!webApiKey) {\n                throw new Error('FIREBASE_WEB_API_KEY not configured');\n            }\n\n            // Use Firebase Auth REST API to send password reset email\n            const response = await fetch(`https://identitytoolkit.googleapis.com/v1/accounts:sendOobCode?key=${webApiKey}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    requestType: 'PASSWORD_RESET',\n                    email: validatedFields.data.email,\n                    continueUrl: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/login`,\n                }),\n            });\n\n            if (response.ok) {\n                const responseData = await response.json();\n                console.log('='.repeat(80));\n                console.log(`‚úÖ EMPLOYEE CREATED: ${validatedFields.data.name}`);\n                console.log(`üìß Email: ${validatedFields.data.email}`);\n                console.log(`üì® Password reset email sent successfully!`);\n                console.log(`üì¨ Email will be delivered by Firebase Auth`);\n                console.log('='.repeat(80));\n\n                revalidatePath('/employees');\n                return { \n                    message: `Successfully added employee ${validatedFields.data.name}. Password reset email has been sent to ${validatedFields.data.email}.`,\n                };\n            } else {\n                const errorData = await response.json();\n                console.error('Failed to send password reset email:', errorData);\n                throw new Error(`Email sending failed: ${errorData.error?.message || 'Unknown error'}`);\n            }\n        } catch (emailError) {\n            console.error('Error sending password reset email:', emailError);\n            \n            // Fallback: generate link for manual sharing\n            const resetLink = await auth.generatePasswordResetLink(validatedFields.data.email, {\n                url: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/login`,\n                handleCodeInApp: false,\n            });\n\n            console.log('='.repeat(80));\n            console.log(`‚úÖ EMPLOYEE CREATED: ${validatedFields.data.name}`);\n            console.log(`üìß Email: ${validatedFields.data.email}`);\n            console.log(`‚ùå Email sending failed: ${emailError.message}`);\n            console.log(`üîó Manual Reset Link: ${resetLink}`);\n            console.log(`üìù Please share this link with the employee`);\n            console.log('='.repeat(80));\n\n            revalidatePath('/employees');\n            return { \n                message: `Successfully added employee ${validatedFields.data.name}. Email sending failed - please share the reset link manually (check console).`,\n                resetLink: resetLink\n            };\n        }\n    } catch (error: any) {\n        console.error('Error adding employee:', error);\n        \n        // Handle specific Firebase errors\n        if (error.code === 'auth/email-already-exists') {\n            return { message: 'An account with this email already exists.' };\n        }\n        \n        if (error.message?.includes('Missing required Firebase environment variables')) {\n            // Fallback: add to database only\n            try {\n                await dbAddEmployee(validatedFields.data as NewEmployee);\n                revalidatePath('/employees');\n                return { \n                    message: 'Employee added to database. Firebase Auth integration requires proper environment configuration for automatic account creation.'\n                };\n            } catch (dbError) {\n                return { message: 'Failed to add employee to database.' };\n            }\n        }\n        \n        return { message: 'Failed to add employee. Please check Firebase configuration and try again.' };\n    }\n}\n\nexport async function deleteEmployeeAction(employeeId: string) {\n  try {\n    await dbDeleteEmployee(employeeId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete employee.' };\n  }\n  revalidatePath('/employees');\n  revalidatePath('/');\n  return { message: 'Successfully deleted employee.' };\n}\n\nconst UpdateEmployeeSchema = z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters.'),\n    email: z.string().email('Please enter a valid email.'),\n    phone: z.string().min(10, 'Please enter a valid phone number.'),\n    role: z.string(),\n    department: z.string(),\n    address: z.string().min(10, 'Address is required.'),\n});\n\nexport async function updateEmployeeAction(id: string, formData: FormData) {\n    const validatedFields = UpdateEmployeeSchema.safeParse({\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        role: formData.get('role'),\n        department: formData.get('department'),\n        address: formData.get('address'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to update employee.',\n        };\n    }\n\n    try {\n        await dbUpdateEmployee(id, validatedFields.data as NewEmployee);\n    } catch (error) {\n        return { message: 'Database Error: Failed to update employee.' };\n    }\n\n    revalidatePath('/employees');\n    revalidatePath('/');\n    return { message: 'Successfully updated employee.' };\n}\n\n\nconst AddEmployeeRoleSchema = z.object({\n    name: z.string().min(2, 'Role name must be at least 2 characters'),\n});\n\nexport async function addEmployeeRoleAction(formData: FormData) {\n    const validatedFields = AddEmployeeRoleSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddEmployeeRole(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add role.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: `Successfully added role '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteEmployeeRoleAction(id: string) {\n    try {\n        await dbDeleteEmployeeRole(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete role.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: 'Successfully deleted role.' };\n}\n\nconst AddDepartmentSchema = z.object({\n    name: z.string().min(2, 'Department name must be at least 2 characters'),\n});\n\nexport async function addDepartmentAction(formData: FormData) {\n    const validatedFields = AddDepartmentSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddDepartment(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add department.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: `Successfully added department '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteDepartmentAction(id: string) {\n    try {\n        await dbDeleteDepartment(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete department.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: 'Successfully deleted department.' };\n}\n\n// CSV Import Actions\nconst ImportProductSchema = z.object({\n    name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n    price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n    gstRate: z.coerce.number().min(0).max(100),\n    skus: z.array(z.string()).optional(),\n    catalogueUrl: z.string().url('Please enter a valid URL.').optional().or(z.literal('')),\n});\n\nexport async function importProductsFromCSV(csvData: any[]) {\n    const results = {\n        success: 0,\n        failed: 0,\n        errors: [] as string[]\n    };\n\n// Get all existing product categories to match against\nconst allCategories = await getProductCategories();\n\n    for (let i = 0; i < csvData.length; i++) {\n        const row = csvData[i];\n        \n        try {\n            // Parse SKUs from comma-separated string\n            const skus = row.skus ? row.skus.split(',').map((sku: string) => sku.trim()).filter(Boolean) : [];\n            \n// Match category by exact name (single category)\nlet categoryId: string | undefined = undefined;\nconst categoryName = (row.category || row.categories || '').toString().trim();\nif (categoryName) {\n    const existingCategory = allCategories.find((c) => c.name === categoryName);\n    if (existingCategory) {\n        categoryId = existingCategory.id;\n    } else {\n        results.errors.push(`Row ${i + 1}: Category not found: ${categoryName}. Please create this category first.`);\n    }\n}\n            \n// Prepare data for validation, including optional fields\n            const dataForValidation = {\n                name: row.name,\n                price: row.price,\n                gstRate: row.gstRate,\n                ...(skus.length > 0 && { skus }),\n                ...(row.catalogueUrl && row.catalogueUrl.trim() && { catalogueUrl: row.catalogueUrl }),\n            };\n\n            const validatedData = ImportProductSchema.parse(dataForValidation);\n\n            // Prepare data for database - only include defined fields\nconst productData = {\n    name: validatedData.name,\n    price: validatedData.price,\n    gstRate: validatedData.gstRate,\n    ...(validatedData.skus && { skus: validatedData.skus }),\n    ...(validatedData.catalogueUrl && { catalogueUrl: validatedData.catalogueUrl }),\n    ...(categoryId && { categoryId }),\n};\n\n            await dbAddProduct(productData);\n            \n            results.success++;\n        } catch (error) {\n            results.failed++;\n            if (error instanceof z.ZodError) {\n                const errorMessages = error.errors.map(e => `Row ${i + 1}: ${e.path.join('.')} - ${e.message}`);\n                results.errors.push(...errorMessages);\n            } else {\n                results.errors.push(`Row ${i + 1}: Failed to import product - ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        }\n    }\n\n    // Revalidate pages after import\n    revalidatePath('/products');\n    revalidatePath('/leads');\n\n    return {\n        success: results.failed === 0,\n        message: `Import completed. ${results.success} products imported successfully${results.failed > 0 ? `, ${results.failed} failed` : ''}.`,\n        errors: results.errors.length > 0 ? results.errors : undefined\n    };\n}\n\n// Count Actions\nexport async function getLeadsCountAction(): Promise<number> {\n    try {\n        return await getLeadsCount();\n    } catch (error) {\n        console.error('Error getting leads count:', error);\n        return 0;\n    }\n}\n\nexport async function getQuotationsCountAction(): Promise<number> {\n    try {\n        return await getQuotationsCount();\n    } catch (error) {\n        console.error('Error getting quotations count:', error);\n        return 0;\n    }\n}\n\nexport async function getProductsCountAction(): Promise<number> {\n    try {\n        return await getProductsCount();\n    } catch (error) {\n        console.error('Error getting products count:', error);\n        return 0;\n    }\n}\n\nexport async function getEmployeesCountAction(): Promise<number> {\n    try {\n        return await getEmployeesCount();\n    } catch (error) {\n        console.error('Error getting employees count:', error);\n        return 0;\n    }\n}\n\nexport async function getLeadsCountByStatusAction(status: LeadStatus): Promise<number> {\n    try {\n        return await getLeadsCountByStatus(status);\n    } catch (error) {\n        console.error(`Error getting leads count for status ${status}:`, error);\n        return 0;\n    }\n}\n\nexport async function getQuotationsCountByStatusAction(status: 'Draft' | 'Sent' | 'Accepted' | 'Rejected'): Promise<number> {\n    try {\n        return await getQuotationsCountByStatus(status);\n    } catch (error) {\n        console.error(`Error getting quotations count for status ${status}:`, error);\n        return 0;\n    }\n}\n\nexport async function getActiveProductsCountAction(): Promise<number> {\n    try {\n        return await getActiveProductsCount();\n    } catch (error) {\n        console.error('Error getting active products count:', error);\n        return 0;\n    }\n}\n\nexport async function getActiveEmployeesCountAction(): Promise<number> {\n    try {\n        return await getActiveEmployeesCount();\n    } catch (error) {\n        console.error('Error getting active employees count:', error);\n        return 0;\n    }\n}\n\n// Communication Activity Actions\nconst CommunicationActivitySchema = z.object({\n  leadId: z.string().min(1, 'Lead ID is required'),\n  type: z.enum(['WhatsApp', 'Email']),\n  message: z.string().min(1, 'Message is required'),\n  contact: z.string().min(1, 'Contact is required'),\n  sentBy: z.string().min(1, 'Sent by is required'),\n});\n\nexport async function logCommunicationActivityAction(formData: FormData) {\n  const validatedFields = CommunicationActivitySchema.safeParse({\n    leadId: formData.get('leadId'),\n    type: formData.get('type'),\n    message: formData.get('message'),\n    contact: formData.get('contact'),\n    sentBy: formData.get('sentBy'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Missing Fields. Failed to log communication activity.',\n    };\n  }\n\n  const { leadId, type, message, contact, sentBy } = validatedFields.data;\n\n  try {\n    const activityNotes = `${type} message sent to ${contact} by ${sentBy}:\\n\\n\"${message}\"`;\n    \n    await addActivityToLead(leadId, {\n      type: type as 'WhatsApp' | 'Email',\n      notes: activityNotes\n    });\n  } catch (error) {\n    const errMsg = error instanceof Error ? error.message : String(error);\n    console.error('LogCommunicationActivity Error:', errMsg);\n    if (errMsg.includes('Lead not found')) {\n      return { message: 'Lead not found. Please refresh the page and try again.' };\n    }\n    return { message: 'Database Error: Failed to log communication activity.' };\n  }\n\n  return { message: `Successfully logged ${type} communication.` };\n}\n\nexport async function getCurrentUserEmployeeAction(email: string): Promise<Employee | null> {\n    try {\n        return await getEmployeeByEmail(email);\n    } catch (error) {\n        console.error('Error getting current user employee:', error);\n        return null;\n    }\n}\n\n// ==================== Currency Actions ====================\nimport { addCurrency as dbAddCurrency, updateCurrency as dbUpdateCurrency, deleteCurrency as dbDeleteCurrency } from './firestore-service';\n\nconst CurrencySchema = z.object({\n  code: z.string().min(2, 'Currency code must be at least 2 characters').max(5, 'Currency code must be at most 5 characters'),\n  name: z.string().min(2, 'Currency name is required'),\n  symbol: z.string().min(1, 'Currency symbol is required'),\n  conversionRate: z.coerce.number().positive('Conversion rate must be positive'),\n});\n\nexport async function addCurrencyAction(formData: FormData) {\n  const validatedFields = CurrencySchema.safeParse({\n    code: formData.get('code'),\n    name: formData.get('name'),\n    symbol: formData.get('symbol'),\n    conversionRate: formData.get('conversionRate'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Validation Error: Failed to add currency.',\n    };\n  }\n\n  try {\n    await dbAddCurrency(validatedFields.data);\n  } catch (error) {\n    return { message: 'Database Error: Failed to add currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully added currency.' };\n}\n\nexport async function updateCurrencyAction(id: string, formData: FormData) {\n  const validatedFields = CurrencySchema.safeParse({\n    code: formData.get('code'),\n    name: formData.get('name'),\n    symbol: formData.get('symbol'),\n    conversionRate: formData.get('conversionRate'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Validation Error: Failed to update currency.',\n    };\n  }\n\n  try {\n    await dbUpdateCurrency(id, validatedFields.data);\n  } catch (error) {\n    return { message: 'Database Error: Failed to update currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully updated currency.' };\n}\n\nexport async function deleteCurrencyAction(id: string) {\n  try {\n    await dbDeleteCurrency(id);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully deleted currency.' };\n}\n\n"],"names":[],"mappings":";;;;;;IAuTsB,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 3204, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/products/edit-product-sheet.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useEffect } from 'react';\nimport { useForm, useFieldArray, Controller } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { PlusCircle, Trash2, X } from 'lucide-react';\n\nimport { Button } from '@/components/ui/button';\nimport {\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetFooter,\n  SheetHeader,\n  SheetTitle,\n} from '@/components/ui/sheet';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Textarea } from '@/components/ui/textarea';\nimport { updateProduct } from '@/lib/actions';\nimport { useToast } from '@/hooks/use-toast';\nimport { Badge } from '@/components/ui/badge';\nimport { Product } from '@/lib/business-types';\nimport { PDFUpload } from '@/components/pdf-upload';\nimport { ImageUpload } from '@/components/image-upload';\nimport { UploadResult, deletePDF, deleteImageFromStorage } from '@/lib/storage-utils';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { getProductCategoriesAction } from '@/lib/actions';\nimport { ProductCategory } from '@/lib/types';\n\nconst productSchema = z.object({\n  name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n  price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n  gstRate: z.coerce.number().min(0, { message: 'GST rate must be a positive number.' }).max(100, { message: 'GST rate cannot exceed 100.' }),\n  categoryId: z.string().optional(),\n  description: z.string().optional(),\n  skus: z.array(z.object({ value: z.string().min(1, \"SKU cannot be empty.\") })).optional(),\n});\n\ntype ProductFormData = z.infer<typeof productSchema>;\n\ntype EditProductSheetProps = {\n  product: Product;\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n};\n\nexport function EditProductSheet({ product, open, onOpenChange }: EditProductSheetProps) {\n  const [currentSku, setCurrentSku] = useState('');\n  const [availableCategories, setAvailableCategories] = useState<ProductCategory[]>([]);\n  const [selectedCategoryId, setSelectedCategoryId] = useState<string | undefined>(undefined);\n  const [catalogPdf, setCatalogPdf] = useState<UploadResult | null>(null);\n  // Track if user explicitly removed the existing PDF (when editing an item that already had a catalogue)\n  const [removedExistingPdf, setRemovedExistingPdf] = useState(false);\n  const [pdfError, setPdfError] = useState<string>('');\n  const [productImage, setProductImage] = useState<UploadResult | null>(null);\n  const [productImageFile, setProductImageFile] = useState<File | null>(null);\n  const [removedExistingImage, setRemovedExistingImage] = useState(false);\n  const [imageError, setImageError] = useState<string>('');\n  const [isImageUploading, setIsImageUploading] = useState(false);\n  const { toast } = useToast();\n  const { register, handleSubmit, reset, control, setValue, formState: { errors, isSubmitting } } = useForm<ProductFormData>({\n    resolver: zodResolver(productSchema),\n  });\n  \n  const { fields: skuFields, append: appendSku, remove: removeSku } = useFieldArray({\n    control,\n    name: \"skus\"\n  });\n\n  useEffect(() => {\n    if (open) {\n      reset({\n        ...product,\n        skus: product.skus?.map(sku => ({ value: sku })) || [],\n        categoryId: product.categoryId,\n        description: (product as any).description || '',\n      });\n      setSelectedCategoryId(product.categoryId);\n      // Reset local PDF and image state flags whenever the sheet is (re)opened\n      setCatalogPdf(null);\n      setRemovedExistingPdf(false);\n      setPdfError('');\n      setProductImage(null);\n      setProductImageFile(null);\n      setRemovedExistingImage(false);\n      setImageError('');\n      setIsImageUploading(false);\n      \n      // Fetch available categories\n      const fetchCategories = async () => {\n        try {\n          const categories = await getProductCategoriesAction();\n          setAvailableCategories(categories);\n        } catch (error) {\n          console.error('Error fetching categories:', error);\n        }\n      };\n      fetchCategories();\n    }\n  }, [product, open, reset]);\n\n  const handleAddSku = () => {\n    if (currentSku.trim() !== '') {\n      appendSku({ value: currentSku.trim() });\n      setCurrentSku('');\n    }\n  };\n\n  const onSubmit = async (data: ProductFormData) => {\n    const formData = new FormData();\n    Object.entries(data).forEach(([key, value]) => {\n      if (key === 'skus') {\n        formData.append(key, JSON.stringify((value as {value: string}[]).map(s => s.value)));\n      } else if (key === 'categoryId') {\n        if (selectedCategoryId) formData.append('categoryId', selectedCategoryId);\n      } else if (value !== undefined && value !== null) {\n        formData.append(key, String(value));\n      }\n    });\n\n    // Add catalog PDF data if available (only send URL + metadata)\n    if (catalogPdf) {\n      formData.append('catalogPdf', JSON.stringify({\n        url: catalogPdf.url,\n        fileName: catalogPdf.fileName,\n        filePath: catalogPdf.path,\n        uploadedAt: new Date().toISOString()\n      }));\n    }\n\n    // If user removed the existing PDF and did not upload a new one, inform backend to clear it\n    if (!catalogPdf && removedExistingPdf) {\n      formData.append('removeCatalogPdf', 'true');\n    }\n\n    // Add new image file if user uploaded one\n    if (productImageFile) {\n      formData.append('productImage', productImageFile);\n    } else if (!removedExistingImage && product.productImage) {\n      // Keep existing image metadata (send as JSON for backend to preserve)\n      formData.append('existingProductImage', JSON.stringify({\n        url: product.productImage.url,\n        fileName: product.productImage.fileName,\n        filePath: product.productImage.filePath,\n        uploadedAt: product.productImage.uploadedAt || new Date().toISOString(),\n      }));\n    }\n\n    // If user removed the existing image and did not upload a new one, inform backend to clear it\n    if (!productImageFile && removedExistingImage) {\n      formData.append('removeProductImage', 'true');\n    }\n\n    if (!product.id) {\n      toast({\n        variant: 'destructive',\n        title: 'Error',\n        description: 'Product ID is missing',\n      });\n      return;\n    }\n\n    const result = await updateProduct(product.id, formData);\n\n    if (result?.message === 'Successfully updated product.') {\n      toast({\n        title: 'Product Updated',\n        description: `\"${data.name}\" has been successfully updated.`,\n      });\n      onOpenChange(false);\n    } else {\n      toast({\n        variant: 'destructive',\n        title: 'Error',\n        description: result?.message || 'An error occurred while updating the product.',\n      });\n    }\n  };\n\n  return (\n    <Sheet open={open} onOpenChange={onOpenChange}>\n      <SheetContent className=\"sm:max-w-xl\">\n        <SheetHeader>\n          <SheetTitle>Edit Product</SheetTitle>\n          <SheetDescription>\n            Update the details for this product or service.\n          </SheetDescription>\n        </SheetHeader>\n        <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-4 py-6 max-h-[90vh] overflow-y-auto pr-6\">\n          <div>\n            <Label htmlFor=\"name\">Product Name</Label>\n            <Input id=\"name\" {...register('name')} className={errors.name ? 'border-destructive' : ''} />\n            {errors.name && <p className=\"text-xs text-destructive mt-1\">{errors.name.message}</p>}\n          </div>\n          <div className=\"space-y-2\">\n            <Label>Product Category</Label>\n            <Controller\n              control={control}\n              name=\"categoryId\"\n              render={({ field }) => (\n                <Select onValueChange={(val) => { field.onChange(val); setSelectedCategoryId(val); }} value={field.value}>\n                  <SelectTrigger>\n                    <SelectValue placeholder=\"Select a category...\" />\n                  </SelectTrigger>\n                  <SelectContent>\n                    {availableCategories.map(cat => (\n                      <SelectItem key={cat.id} value={cat.id}>{cat.name}</SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              )}\n            />\n            {errors.categoryId && <p className=\"text-xs text-destructive mt-1\">{errors.categoryId.message}</p>}\n          </div>\n        <div>\n          <Label htmlFor=\"description\">Description</Label>\n          <Textarea id=\"description\" rows={3} placeholder=\"Optional product description\" {...register('description')} />\n        </div>\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div>\n                <Label htmlFor=\"price\">Price (‚Çπ)</Label>\n                <Input id=\"price\" type=\"number\" step=\"0.01\" {...register('price')} className={errors.price ? 'border-destructive' : ''} />\n                {errors.price && <p className=\"text-xs text-destructive mt-1\">{errors.price.message}</p>}\n            </div>\n            <div>\n                <Label htmlFor=\"gstRate\">GST Rate (%)</Label>\n                <Input id=\"gstRate\" type=\"number\" step=\"0.01\" {...register('gstRate')} className={errors.gstRate ? 'border-destructive' : ''} />\n                {errors.gstRate && <p className=\"text-xs text-destructive mt-1\">{errors.gstRate.message}</p>}\n            </div>\n          </div>\n          \n          <div>\n            <PDFUpload\n              onUploadComplete={(result) => {\n                setCatalogPdf(result);\n                setPdfError('');\n                setRemovedExistingPdf(false); // A new upload supersedes any prior removal\n              }}\n              onUploadError={(error) => {\n                setPdfError(error);\n                setCatalogPdf(null);\n              }}\n              currentPdf={\n                // If user removed existing PDF, don't show it. Otherwise prefer newly uploaded, else show existing.\n                removedExistingPdf\n                  ? null\n                  : (catalogPdf || (product.cataloguePdf ? {\n                      url: product.cataloguePdf.url,\n                      fileName: product.cataloguePdf.fileName,\n                      filePath: product.cataloguePdf.filePath\n                    } : null))\n              }\n              onRemove={() => {\n                setCatalogPdf(null);\n                setPdfError('');\n                // Mark the existing PDF as removed so UI hides it and backend clears it if no new upload\n                if (product.cataloguePdf) {\n                  setRemovedExistingPdf(true);\n                }\n              }}\n              label=\"Catalog PDF\"\n              description=\"Upload a PDF catalog file (max 10MB)\"\n            />\n            {pdfError && <p className=\"text-xs text-destructive mt-1\">{pdfError}</p>}\n          </div>\n          \n          <div>\n            <ImageUpload\n              onUploadComplete={(result) => {\n                setProductImage(result);\n                setImageError('');\n                setRemovedExistingImage(false);\n                setIsImageUploading(false);\n              }}\n              onUploadError={(error) => {\n                setImageError(error);\n                setProductImage(null);\n                setProductImageFile(null);\n                setIsImageUploading(false);\n              }}\n              onFileSelect={(file) => {\n                setProductImageFile(file);\n                setIsImageUploading(true);\n              }}\n              currentImage={\n                removedExistingImage\n                  ? null\n                  : (productImage || (product.productImage ? {\n                      url: product.productImage.url,\n                      fileName: product.productImage.fileName,\n                      filePath: product.productImage.filePath\n                    } : null))\n              }\n              onRemove={() => {\n                setProductImage(null);\n                setProductImageFile(null);\n                setImageError('');\n                if (product.productImage) {\n                  setRemovedExistingImage(true);\n                }\n              }}\n              label=\"Product Image\"\n              description=\"Upload a product image (max 10MB)\"\n            />\n            {imageError && <p className=\"text-xs text-destructive mt-1\">{imageError}</p>}\n          </div>\n          <div className=\"space-y-2\">\n            <Label>SKUs</Label>\n            <div className=\"flex items-center gap-2\">\n              <Input\n                value={currentSku}\n                onChange={(e) => setCurrentSku(e.target.value)}\n                placeholder=\"Enter SKU and press Add\"\n              />\n              <Button type=\"button\" variant=\"outline\" onClick={handleAddSku}>\n                Add\n              </Button>\n            </div>\n            <div className=\"flex flex-wrap gap-2 pt-2\">\n              {skuFields.map((field, index) => (\n                <Badge key={field.id} variant=\"secondary\">\n                  {field.value}\n                  <button\n                    type=\"button\"\n                    className=\"ml-2 rounded-full outline-none ring-offset-background focus:ring-2 focus:ring-ring focus:ring-offset-2\"\n                    onClick={() => removeSku(index)}\n                  >\n                    <X className=\"h-3 w-3 text-muted-foreground hover:text-foreground\" />\n                  </button>\n                </Badge>\n              ))}\n            </div>\n            {errors.skus && <p className=\"text-xs text-destructive mt-1\">{errors.skus.message}</p>}\n          </div>\n          <SheetFooter className=\"pt-4 sticky bottom-0 bg-background\">\n            <Button type=\"submit\" disabled={isSubmitting || isImageUploading} className=\"w-full\">\n              {isImageUploading ? 'Uploading Image...' : isSubmitting ? 'Saving Changes...' : 'Save Changes'}\n            </Button>\n          </SheetFooter>\n        </form>\n      </SheetContent>\n    </Sheet>\n  );\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3858, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/ui/alert-dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3985, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { getAuth } from 'firebase-admin/auth';\nimport { initializeApp, getApps, cert } from 'firebase-admin/app';\nimport { summarizeMeetingNotes } from '@/ai/flows/summarize-meeting-notes';\nimport { addLead as dbAddLead, addActivityToLead, updateLeadStatus as updateStatus, addProduct as dbAddProduct, addLeadSource as dbAddLeadSource, deleteLeadSource as dbDeleteLeadSource, addProductCategory as dbAddProductCategory, deleteProductCategory as dbDeleteProductCategory, getProductCategories, updateLead as dbUpdateLead, getLeadById as dbGetLeadById, deleteLead as dbDeleteLead, addQuotation as dbAddQuotation, updateQuotation as dbUpdateQuotation, deleteQuotation as dbDeleteQuotation, addQuotationTemplate as dbAddQuotationTemplate, updateProduct as dbUpdateProduct, deleteProduct as dbDeleteProduct, addEmployee as dbAddEmployee, deleteEmployee as dbDeleteEmployee, updateEmployee as dbUpdateEmployee, getEmployeeByEmail, getEmployeeRoles, addEmployeeRole as dbAddEmployeeRole, deleteEmployeeRole as dbDeleteEmployeeRole, getDepartments, addDepartment as dbAddDepartment, deleteDepartment as dbDeleteDepartment, updateQuotationTemplate as dbUpdateQuotationTemplate, deleteQuotationTemplate as dbDeleteQuotationTemplate, getLeadsCount, getQuotationsCount, getProductsCount, getEmployeesCount, getLeadsCountByStatus, getQuotationsCountByStatus, getActiveProductsCount, getActiveEmployeesCount, updateProductCategory as dbUpdateProductCategory } from './data';\nimport { deletePDFFromStorage, deleteImageFromStorage, uploadImageToStorage } from './storage-utils';\nimport type { Lead, LeadStatus, LeadProduct, UpdatableLeadData, Product, NewQuotationTemplate, Quotation, NewEmployee, QuotationTemplate } from './types';\nimport type { Employee } from './business-types';\nimport { getProducts } from './data';\n\n// Initialize Firebase Admin SDK\nfunction initializeFirebaseAdmin() {\n  if (getApps().length === 0) {\n    // Check if all required environment variables are present\n    const requiredEnvVars = [\n      'FIREBASE_PROJECT_ID',\n      'FIREBASE_PRIVATE_KEY',\n      'FIREBASE_CLIENT_EMAIL'\n    ];\n    \n    const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n    \n    if (missingVars.length > 0) {\n      throw new Error(`Missing required Firebase environment variables: ${missingVars.join(', ')}`);\n    }\n\n    const serviceAccount = {\n      type: \"service_account\",\n      project_id: process.env.FIREBASE_PROJECT_ID!,\n      private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,\n      private_key: process.env.FIREBASE_PRIVATE_KEY!.replace(/\\\\n/g, '\\n'),\n      client_email: process.env.FIREBASE_CLIENT_EMAIL!,\n      client_id: process.env.FIREBASE_CLIENT_ID,\n      auth_uri: \"https://accounts.google.com/o/oauth2/auth\",\n      token_uri: \"https://oauth2.googleapis.com/token\",\n      auth_provider_x509_cert_url: \"https://www.googleapis.com/oauth2/v1/certs\",\n      client_x509_cert_url: `https://www.googleapis.com/robot/v1/metadata/x509/${process.env.FIREBASE_CLIENT_EMAIL}`\n    };\n\n    initializeApp({\n      credential: cert(serviceAccount as any),\n      projectId: process.env.FIREBASE_PROJECT_ID,\n    });\n  }\n}\n\nconst LeadProductSchema = z.object({\n    productId: z.string().min(1, 'Product must be selected'),\n    quantity: z.coerce.number().min(1),\n    rate: z.coerce.number().min(0),\n    selectedSku: z.string().optional(),\n});\n\nconst CreateLeadSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  company: z.string().min(2, 'Company must be at least 2 characters'),\n  email: z.string().email('Invalid email address'),\n  phone: z.string().min(10, 'Phone number seems too short'),\n  whatsappNumber: z.string().optional().or(z.literal('')),\n  client_address: z.string().optional().or(z.literal('')),\n  client_gst_no: z.string().optional().or(z.literal('')),\n  status: z.enum(['New', 'In Discussion', 'Negotiation', 'Closed - Won', 'Closed - Lost']),\n  source: z.string().min(1, 'Please select a lead source'),\n  notes: z.string().optional(),\n  products: z.array(LeadProductSchema).optional(),\n  createdBy: z.string().min(1, 'Created by field is required'),\n});\n\nexport async function createLead(formData: FormData) {\n  const productsJSON = formData.get('products');\n  const products = productsJSON ? JSON.parse(productsJSON as string) : [];\n\n  const validatedFields = CreateLeadSchema.safeParse({\n    name: formData.get('name'),\n    company: formData.get('company'),\n    email: formData.get('email'),\n    phone: formData.get('phone'),\n    whatsappNumber: formData.get('whatsappNumber'),\n    client_address: formData.get('client_address'),\n    client_gst_no: formData.get('client_gst_no'),\n    status: formData.get('status'),\n    source: formData.get('source'),\n    notes: formData.get('notes'),\n    products: products,\n    createdBy: formData.get('createdBy'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Failed to create lead.',\n    };\n  }\n  \n  let newLeadId: string | undefined;\n  try {\n    const leadData = {\n      ...validatedFields.data,\n      products: validatedFields.data.products || []\n    };\n    const newLead = await dbAddLead(leadData);\n    newLeadId = newLead.id;\n  } catch (error) {\n    return { message: 'Database Error: Failed to Create Lead.' };\n  }\n\n  revalidatePath('/leads');\n  revalidatePath('/');\n  if (newLeadId) {\n    revalidatePath(`/leads/${newLeadId}`);\n  }\n  return { message: 'Successfully created lead.' };\n}\n\nconst UpdateLeadSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  company: z.string().min(2, 'Company must be at least 2 characters'),\n  email: z.string().email('Invalid email address'),\n  phone: z.string().min(10, 'Phone number seems too short'),\n  whatsappNumber: z.string().optional().or(z.literal('')),\n  client_address: z.string().optional().or(z.literal('')),\n  client_gst_no: z.string().optional().or(z.literal('')),\n  status: z.enum(['New', 'In Discussion', 'Negotiation', 'Closed - Won', 'Closed - Lost']),\n  source: z.string().min(1, 'Please select a lead source'),\n  products: z.array(LeadProductSchema).optional(),\n});\n\nfunction generateChangeNotes(oldLead: Lead, newLeadData: UpdatableLeadData, allProducts: Product[]): string {\n    const changes: string[] = [];\n\n    if (oldLead.name !== newLeadData.name) {\n        changes.push(`Name changed from \"${oldLead.name}\" to \"${newLeadData.name}\".`);\n    }\n    if (oldLead.company !== newLeadData.company) {\n        changes.push(`Company changed from \"${oldLead.company}\" to \"${newLeadData.company}\".`);\n    }\n    if (oldLead.email !== newLeadData.email) {\n        changes.push(`Email changed from \"${oldLead.email}\" to \"${newLeadData.email}\".`);\n    }\n    if (oldLead.phone !== newLeadData.phone) {\n        changes.push(`Phone changed from \"${oldLead.phone}\" to \"${newLeadData.phone}\".`);\n    }\n    if (oldLead.whatsappNumber !== newLeadData.whatsappNumber) {\n        changes.push(`WhatsApp Number changed from \"${oldLead.whatsappNumber || 'N/A'}\" to \"${newLeadData.whatsappNumber || 'N/A'}\".`);\n    }\n    if (oldLead.client_address !== newLeadData.client_address) {\n        changes.push(`Client Address changed from \"${oldLead.client_address || 'N/A'}\" to \"${newLeadData.client_address || 'N/A'}\".`);\n    }\n    if (oldLead.client_gst_no !== newLeadData.client_gst_no) {\n        changes.push(`Client GST Number changed from \"${oldLead.client_gst_no || 'N/A'}\" to \"${newLeadData.client_gst_no || 'N/A'}\".`);\n    }\n    if (oldLead.status !== newLeadData.status) {\n        changes.push(`Status changed from \"${oldLead.status}\" to \"${newLeadData.status}\".`);\n    }\n    if (oldLead.source !== newLeadData.source) {\n        changes.push(`Source changed from \"${oldLead.source}\" to \"${newLeadData.source}\".`);\n    }\n\n    const oldProducts = oldLead.products || [];\n    const newProducts = newLeadData.products || [];\n    if (JSON.stringify(oldProducts) !== JSON.stringify(newProducts)) {\n        const getProductName = (productId: string) => allProducts.find(p => p.id === productId)?.name || productId;\n        \n        const formatProduct = (p: LeadProduct) => `${getProductName(p.productId)} (Qty: ${p.quantity}, Rate: ${p.rate}, SKU: ${p.selectedSku || 'N/A'})`;\n\n        const oldProductStr = oldProducts.map(formatProduct).join(', ') || 'None';\n        const newProductStr = newProducts.map(formatProduct).join(', ') || 'None';\n\n        changes.push(`Interested products updated.\\n- Old: ${oldProductStr}\\n- New: ${newProductStr}`);\n    }\n\n    if (changes.length === 0) {\n        return 'No changes were made to the lead details.';\n    }\n\n    return 'Lead details were updated:\\n' + changes.map(c => `- ${c}`).join('\\n');\n}\n\nexport async function updateLead(leadId: string, formData: FormData) {\n    const [oldLead, allProducts] = await Promise.all([\n        dbGetLeadById(leadId),\n        getProducts()\n    ]);\n\n    if (!oldLead) {\n        return { message: 'Error: Lead not found.' };\n    }\n\n    const productsJSON = formData.get('products');\n    const products = productsJSON ? JSON.parse(productsJSON as string) : [];\n  \n    const validatedFields = UpdateLeadSchema.safeParse({\n      name: formData.get('name'),\n      company: formData.get('company'),\n      email: formData.get('email'),\n      phone: formData.get('phone'),\n      whatsappNumber: formData.get('whatsappNumber'),\n      client_address: formData.get('client_address'),\n      client_gst_no: formData.get('client_gst_no'),\n      status: formData.get('status'),\n      source: formData.get('source'),\n      products: products,\n    });\n  \n    if (!validatedFields.success) {\n      return {\n        errors: validatedFields.error.flatten().fieldErrors,\n        message: 'Failed to update lead.',\n      };\n    }\n\n    const newLeadData = validatedFields.data as UpdatableLeadData;\n    const changeNotes = generateChangeNotes(oldLead, newLeadData, allProducts);\n  \n    try {\n        await dbUpdateLead(leadId, newLeadData);\n        if (changeNotes !== 'No changes were made to the lead details.') {\n            await addActivityToLead(leadId, {\n                type: 'Revision Request',\n                notes: changeNotes\n            });\n        }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'An unknown error occurred';\n      return { message: `Database Error: Failed to Update Lead. ${message}` };\n    }\n  \n    revalidatePath('/leads');\n    revalidatePath('/');\n    revalidatePath(`/leads/${leadId}`);\n    return { message: 'Successfully updated lead.' };\n}\n\nconst ProductSchema = z.object({\n    name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n    price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n    gstRate: z.coerce.number().min(0).max(100),\n    categoryId: z.string().optional(),\n    description: z.string().optional(),\n    skus: z.array(z.string()).optional(),\n    catalogueUrl: z.string().url('Please enter a valid URL.').optional().or(z.literal('')),\n    cataloguePdf: z.object({\n        url: z.string(),\n        fileName: z.string(),\n        filePath: z.string(),\n        uploadedAt: z.string(),\n    }).optional(),\n    productImage: z.object({\n        url: z.string(),\n        fileName: z.string(),\n        filePath: z.string(),\n        uploadedAt: z.string(),\n    }).optional(),\n});\n\nexport async function addProduct(formData: FormData) {\n  const skusJSON = formData.get('skus');\n  const skus = skusJSON ? JSON.parse(skusJSON as string) : [];\n  \n  const catalogPdfJSON = formData.get('catalogPdf');\n  const catalogPdf = catalogPdfJSON ? JSON.parse(catalogPdfJSON as string) : undefined;\n  \n  const productImageJSON = formData.get('productImage');\n  console.log('Product Image JSON received:', productImageJSON);\n  const productImage = productImageJSON ? JSON.parse(productImageJSON as string) : undefined;\n  console.log('Product Image parsed:', productImage);\n  \n  const validatedFields = ProductSchema.safeParse({\n    name: formData.get('name'),\n    price: formData.get('price'),\n    gstRate: formData.get('gstRate'),\n    categoryId: formData.get('categoryId'),\n    description: formData.get('description') || undefined,\n    skus: skus,\n    catalogueUrl: formData.get('catalogueUrl') || '',\n    cataloguePdf: catalogPdf,\n    productImage: productImage,\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Failed to add product.',\n    };\n  }\n\n  try {\n    const data = validatedFields.data;\n    // Remove undefined values before sending to Firestore\n    const cleanData = Object.fromEntries(\n      Object.entries(data).filter(([_, v]) => v !== undefined)\n    );\n    \n    console.log('Clean data being sent to database:', JSON.stringify(cleanData, null, 2));\n    \n    // Create the product\n    const newProduct = await dbAddProduct(cleanData as any);\n    \n  } catch (error) {\n    return { message: 'Database Error: Failed to add product.' };\n  }\n\n  revalidatePath('/products');\n  revalidatePath('/leads'); // Revalidate leads in case product info is needed\n  return { message: 'Successfully added product.' };\n}\n\nexport async function updateProduct(id: string, formData: FormData) {\n    const skusJSON = formData.get('skus');\n    const skus = skusJSON ? JSON.parse(skusJSON as string) : [];\n\n    const catalogPdfJSON = formData.get('catalogPdf');\n    const catalogPdf = catalogPdfJSON ? JSON.parse(catalogPdfJSON as string) : undefined;\n    const removeCatalogPdf = String(formData.get('removeCatalogPdf') || '').toLowerCase() === 'true';\n\n    // Handle product image - can be File object (new upload) or JSON string (existing metadata)\n    const productImageData = formData.get('productImage');\n    const existingProductImageJSON = formData.get('existingProductImage');\n    const removeProductImage = String(formData.get('removeProductImage') || '').toLowerCase() === 'true';\n    \n    let productImage: any = undefined;\n    \n    // If there's a new file upload, handle it\n    if (productImageData instanceof File) {\n      try {\n        const uploadResult = await uploadImageToStorage(productImageData, 'products');\n        productImage = {\n          url: uploadResult.url,\n          fileName: uploadResult.fileName,\n          filePath: uploadResult.path,\n          uploadedAt: new Date().toISOString(),\n        };\n      } catch (error) {\n        console.error('Failed to upload product image:', error);\n        return { message: 'Failed to upload product image.' };\n      }\n    } else if (existingProductImageJSON && !removeProductImage) {\n      // Keep existing image metadata\n      productImage = JSON.parse(existingProductImageJSON as string);\n    }\n\n    // Debug logs removed\n    \n    const validatedFields = ProductSchema.safeParse({\n      name: formData.get('name'),\n      price: formData.get('price'),\n      gstRate: formData.get('gstRate'),\n      categoryId: formData.get('categoryId'),\n      description: formData.get('description') || undefined,\n      skus: skus,\n      catalogueUrl: formData.get('catalogueUrl') || '',\n      cataloguePdf: catalogPdf,\n      productImage: productImage,\n    });\n\n    if (!validatedFields.success) {\n      return {\n        errors: validatedFields.error.flatten().fieldErrors,\n        message: 'Failed to update product.',\n      };\n    }\n\n    try {\n      // Get the current product to check for existing PDF\n      const currentProduct = await getProducts().then(products => \n        products.find(p => p.id === id)\n      );\n      \n      const data = validatedFields.data as any;\n      const updateData: any = { ...data };\n      \n      // If user explicitly removed the existing PDF and didn't upload a new one, clear the field\n      if (removeCatalogPdf && !catalogPdf) {\n        // Delete the old PDF from Firebase Storage if it exists\n        if (currentProduct?.cataloguePdf?.filePath) {\n          try {\n            await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n          } catch (error) {\n            console.error('Failed to delete PDF from storage:', error);\n            // Continue with the update even if PDF deletion fails\n          }\n        }\n        updateData.cataloguePdf = null; // This will clear the field in Firestore\n      } else if (catalogPdf && currentProduct?.cataloguePdf?.filePath && \n                 currentProduct.cataloguePdf.filePath !== catalogPdf.filePath) {\n        // If a new PDF was uploaded, delete the old one from storage\n        try {\n          await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n        } catch (error) {\n          console.error('Failed to delete old PDF from storage:', error);\n          // Continue with the update even if old PDF deletion fails\n        }\n      }\n      \n      // Handle product image storage cleanup if new image was uploaded\n      if (productImageData instanceof File && currentProduct?.productImage?.filePath) {\n        // Delete the old image from storage since we have a new one\n        try {\n          await deleteImageFromStorage(currentProduct.productImage.filePath);\n        } catch (error) {\n          console.error('Failed to delete old product image from storage:', error);\n          // Continue with the update even if old image deletion fails\n        }\n      }\n      \n      // Handle product image removal\n      if (removeProductImage && !productImageData) {\n        // Delete the existing image from storage\n        if (currentProduct?.productImage?.filePath) {\n          try {\n            await deleteImageFromStorage(currentProduct.productImage.filePath);\n          } catch (error) {\n            console.error('Failed to delete product image from storage:', error);\n          }\n        }\n        updateData.productImage = null; // This will clear the field in Firestore\n      }\n      \n      // Ensure new uploads are persisted\n      if (catalogPdf) {\n        updateData.cataloguePdf = catalogPdf;\n      }\n      if (productImage) {\n        updateData.productImage = productImage;\n      }\n      \n      // Remove undefined values from updateData as Firestore doesn't accept them\n      const cleanedUpdateData: any = {};\n      for (const [key, value] of Object.entries(updateData)) {\n        if (value !== undefined) {\n          cleanedUpdateData[key] = value;\n        }\n      }\n      \n      console.log('[updateProduct] cleanedUpdateData keys:', Object.keys(cleanedUpdateData));\n      console.log('[updateProduct] cleanedUpdateData.productImage:', cleanedUpdateData.productImage);\n      \n      await dbUpdateProduct(id, cleanedUpdateData);\n    } catch (error) {\n      return { message: 'Database Error: Failed to update product.' };\n    }\n\n    revalidatePath('/products');\n    revalidatePath('/leads');\n    return { message: 'Successfully updated product.' };\n  }\n  \n  export async function deleteProduct(id: string) {\n    try {\n      // Get the current product to check for PDF before deletion\n      const currentProduct = await getProducts().then(products => \n        products.find(p => p.id === id)\n      );\n      \n      // Delete the PDF from Firebase Storage if it exists\n      if (currentProduct?.cataloguePdf?.filePath) {\n        try {\n          await deletePDFFromStorage(currentProduct.cataloguePdf.filePath);\n        } catch (error) {\n          console.error('Failed to delete PDF from storage:', error);\n          // Continue with product deletion even if PDF deletion fails\n        }\n      }\n      \n      await dbDeleteProduct(id);\n    } catch (error) {\n      return { message: 'Database Error: Failed to delete product.' };\n    }\n\n    revalidatePath('/products');\n    revalidatePath('/leads');\n    return { message: 'Successfully deleted product.' };\n  }\n\n\nconst LogActivitySchema = z.object({\n    leadId: z.string(),\n    type: z.enum(['Meeting', 'Call', 'Email', 'Revision Request', 'Proposal Sent']),\n    notes: z.string().optional(),\n    summary: z.string().optional(),\n});\n\nexport async function logActivity(formData: FormData) {\n    const validatedFields = LogActivitySchema.safeParse({\n        leadId: formData.get('leadId'),\n        type: formData.get('type'),\n        notes: formData.get('notes'),\n        summary: formData.get('summary') || undefined,\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to log activity.',\n        };\n    }\n\n    try {\n        const { leadId, ...activityData } = validatedFields.data;\n        await addActivityToLead(leadId, activityData);\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        console.error('LogActivity Error:', message);\n        if (message.includes('Lead not found')) {\n            return { message: 'Lead not found. Please refresh the page and try again.' };\n        }\n        return { message: 'Database Error: Failed to log activity.' };\n    }\n\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    revalidatePath('/');\n    return { message: 'Successfully logged activity.' };\n}\n\nexport async function getSummaryForNotes(notes: string): Promise<{ summary?: string; error?: string }> {\n  if (!notes || notes.trim().length < 50) {\n    return { error: 'Please provide at least 50 characters of notes to summarize.' };\n  }\n  try {\n    const result = await summarizeMeetingNotes({ notes });\n    return result;\n  } catch (e) {\n    console.error('AI Summarization Error:', e);\n    return { error: 'Failed to generate summary due to an internal error.' };\n  }\n}\n\n\nexport async function updateLeadStatusAction(leadId: string, status: LeadStatus, userId?: string, userName?: string) {\n  try {\n    // Get the current lead to capture the previous status\n    const currentLead = await dbGetLeadById(leadId);\n    if (!currentLead) {\n      return { message: 'Lead not found.' };\n    }\n    \n    const previousStatus = currentLead.status;\n    \n    // Only update if status is actually changing\n    if (previousStatus === status) {\n      return { message: 'Status is already set to this value.' };\n    }\n    \n    // Update the status\n    await updateStatus(leadId, status);\n    \n    // Add a status change activity\n    const changedBy = userName || userId || 'Unknown User';\n    const statusChangeNotes = `Status changed from \"${previousStatus}\" to \"${status}\" by ${changedBy}`;\n    \n    await addActivityToLead(leadId, {\n      type: 'Status Change',\n      notes: statusChangeNotes\n    });\n    \n  } catch (error) {\n    return { message: 'Database Error: Failed to update status.' };\n  }\n  revalidatePath(`/leads/${leadId}`);\n  revalidatePath('/leads');\n  revalidatePath('/');\n  return { message: 'Status updated successfully.' };\n}\n\nexport async function deleteLeadAction(leadId: string) {\n  try {\n    await dbDeleteLead(leadId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete lead.' };\n  }\n  revalidatePath('/leads');\n  revalidatePath('/');\n  return { message: 'Successfully deleted lead.' };\n}\n\nconst AddLeadSourceSchema = z.object({\n    name: z.string().min(2, 'Source name must be at least 2 characters'),\n});\n\nexport async function addLeadSourceAction(formData: FormData) {\n    const validatedFields = AddLeadSourceSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddLeadSource(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add lead source.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/leads');\n    return { message: `Successfully added '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteLeadSourceAction(id: string) {\n    try {\n        await dbDeleteLeadSource(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete lead source.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/leads');\n    return { message: 'Successfully deleted lead source.' };\n}\n\nconst AddProductCategorySchema = z.object({\n    name: z.string().min(2, 'Category name must be at least 2 characters'),\n    description: z.string().optional().nullable(),\n});\n\nexport async function addProductCategoryAction(formData: FormData) {\n    const validatedFields = AddProductCategorySchema.safeParse({\n        name: formData.get('name'),\n        description: formData.get('description'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        // Convert null to undefined for optional description\n        const description = validatedFields.data.description || '';\n        await dbAddProductCategory(validatedFields.data.name, description);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add product category.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: `Successfully added '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteProductCategoryAction(id: string) {\n    try {\n        await dbDeleteProductCategory(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete product category.' };\n    }\n\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: 'Successfully deleted product category.' };\n}\n\n// Update an existing product category's name/description\nexport async function updateProductCategoryAction(id: string, name: string, description?: string) {\n    try {\n        await dbUpdateProductCategory(id, name, description || '');\n    } catch (error) {\n        const message = error instanceof Error ? error.message : 'Unknown error';\n        return { message: `Database Error: Failed to update product category. ${message}` };\n    }\n    revalidatePath('/setup');\n    revalidatePath('/products');\n    return { message: 'Successfully updated product category.' };\n}\n\nexport async function getProductCategoriesAction() {\n    try {\n        const categories = await getProductCategories();\n        return categories;\n    } catch (error) {\n        console.error('Error fetching product categories:', error);\n        return [];\n    }\n}\n\n\nconst CreateQuotationSchema = z.object({\n  leadId: z.string().min(1),\n  templateId: z.string().min(1),\n  date: z.string(),\n  validUntil: z.string(),\n  status: z.enum(['Draft', 'Sent', 'Accepted', 'Rejected']),\n  products: z.string(), // JSON string\n  subTotal: z.coerce.number(),\n  totalGst: z.coerce.number(),\n  grandTotal: z.coerce.number(),\n  quotationPrefix: z.string().optional(),\n  // Overridable template fields\n  companyName: z.string().min(1),\n  companyAddress: z.string().min(1),\n  companyGst: z.string().optional().or(z.literal('')).nullable(),\n  // Client billing fields\n  client_address: z.string().optional().or(z.literal('')).nullable(),\n  client_gst_no: z.string().optional().or(z.literal('')).nullable(),\n  termsAndConditions: z.string(),\n  logoUrl: z.string().optional().nullable(),\n  // Additional charges (numeric or empty/null)\n  freightCharges: z.coerce.number().min(0).optional().or(z.literal('')).nullable(),\n  courierCharges: z.coerce.number().min(0).optional().or(z.literal('')).nullable(),\n  // Flags to show/hide charges in PDF\n  showFreight: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return false; // default to false\n  }, z.boolean()).optional(),\n  showCourier: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return false; // default to false\n  }, z.boolean()).optional(),\n  // GST visibility control\n  showGst: z.preprocess((val) => {\n    if (val === 'true' || val === true) return true;\n    if (val === 'false' || val === false) return false;\n    return true; // default to true for backward compatibility\n  }, z.boolean()).optional(),\n  // Currency fields\n  currencyCode: z.string().optional(),\n  currencySymbol: z.string().optional(),\n  conversionRate: z.coerce.number().optional(),\n});\n\n\nexport async function addQuotation(formData: FormData) {\n    console.log('Server received quotationPrefix:', formData.get('quotationPrefix'));\n    const validatedFields = CreateQuotationSchema.safeParse({\n        leadId: formData.get('leadId'),\n        templateId: formData.get('templateId'),\n        date: formData.get('date'),\n        validUntil: formData.get('validUntil'),\n        status: formData.get('status'),\n        products: formData.get('products'),\n        subTotal: formData.get('subTotal'),\n        totalGst: formData.get('totalGst'),\n        grandTotal: formData.get('grandTotal'),\n        quotationPrefix: formData.get('quotationPrefix') || '',\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        client_address: formData.get('client_address'),\n        client_gst_no: formData.get('client_gst_no'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n        freightCharges: formData.get('freightCharges'),\n        courierCharges: formData.get('courierCharges'),\n        showFreight: formData.get('showFreight'),\n        showCourier: formData.get('showCourier'),\n        showGst: formData.get('showGst'),\n        currencyCode: formData.get('currencyCode'),\n        currencySymbol: formData.get('currencySymbol'),\n        conversionRate: formData.get('conversionRate'),\n      });\n    \n      if (!validatedFields.success) {\n        console.error(validatedFields.error.flatten().fieldErrors);\n        return {\n          errors: validatedFields.error.flatten().fieldErrors,\n          message: 'Validation Error: Failed to create quotation.',\n        };\n      }\n      \n      let newQuotation: Quotation | undefined;\n      try {\n        const data = validatedFields.data;\n        const parsedProducts = JSON.parse(data.products);\n        const prefix = (data.quotationPrefix?.trim() || 'QUO');\n        console.log('Using prefix:', prefix);\n        const { quotationPrefix: _omitPrefix, logoUrl, ...rest } = data as any;\n        \n        // Clean up null values - convert to undefined for Firestore\n        const payload: any = {\n          ...rest,\n          products: parsedProducts,\n          companyGst: rest.companyGst || undefined,\n          client_address: rest.client_address || undefined,\n          client_gst_no: rest.client_gst_no || undefined,\n          freightCharges: rest.freightCharges || undefined,\n          courierCharges: rest.courierCharges || undefined,\n          showFreight: rest.showFreight === true || rest.showFreight === 'true',\n          showCourier: rest.showCourier === true || rest.showCourier === 'true',\n        };\n        if (logoUrl) payload.logoUrl = logoUrl;\n        newQuotation = await dbAddQuotation(payload, prefix);\n\n        // Log activity on the lead\n        await addActivityToLead(data.leadId, {\n            type: 'Proposal Sent',\n            notes: `Quotation ${newQuotation.quotationNumber} was created and sent.`\n        });\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return { message: `Database Error: Failed to Create Quotation. ${message}` };\n      }\n\n    revalidatePath('/quotations');\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    return { message: 'Successfully created quotation.' };\n}\n\nexport async function updateQuotation(id: string, formData: FormData) {\n    const validatedFields = CreateQuotationSchema.safeParse({\n        leadId: formData.get('leadId'),\n        templateId: formData.get('templateId'),\n        date: formData.get('date'),\n        validUntil: formData.get('validUntil'),\n        status: formData.get('status'),\n        products: formData.get('products'),\n        subTotal: formData.get('subTotal'),\n        totalGst: formData.get('totalGst'),\n        grandTotal: formData.get('grandTotal'),\n        quotationPrefix: formData.get('quotationPrefix') || '',\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        client_address: formData.get('client_address'),\n        client_gst_no: formData.get('client_gst_no'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n        freightCharges: formData.get('freightCharges'),\n        courierCharges: formData.get('courierCharges'),\n        showFreight: formData.get('showFreight'),\n        showCourier: formData.get('showCourier'),\n        showGst: formData.get('showGst'),\n        currencyCode: formData.get('currencyCode'),\n        currencySymbol: formData.get('currencySymbol'),\n        conversionRate: formData.get('conversionRate'),\n      });\n    \n      if (!validatedFields.success) {\n        console.error(validatedFields.error.flatten().fieldErrors);\n        return {\n          errors: validatedFields.error.flatten().fieldErrors,\n          message: 'Validation Error: Failed to update quotation.',\n        };\n      }\n      \n      try {\n        const data = validatedFields.data;\n        const parsedProducts = JSON.parse(data.products);\n        \n        // Clean up null values - convert to undefined for Firestore\n        await dbUpdateQuotation(id, {\n            ...data,\n            logoUrl: data.logoUrl || undefined,\n            companyGst: data.companyGst || undefined,\n            client_address: data.client_address || undefined,\n            client_gst_no: data.client_gst_no || undefined,\n            freightCharges: data.freightCharges || undefined,\n            courierCharges: data.courierCharges || undefined,\n            showFreight: data.showFreight === true || data.showFreight === 'true',\n            showCourier: data.showCourier === true || data.showCourier === 'true',\n            products: parsedProducts,\n        });\n\n        // Log activity on the lead\n        await addActivityToLead(data.leadId, {\n            type: 'Revision Request',\n            notes: `Quotation was updated.`\n        });\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return { message: `Database Error: Failed to Update Quotation. ${message}` };\n      }\n\n    revalidatePath('/quotations');\n    revalidatePath(`/quotations/${id}`);\n    revalidatePath(`/leads/${validatedFields.data.leadId}`);\n    return { message: 'Successfully updated quotation.' };\n}\n\nexport async function deleteQuotationAction(quotationId: string) {\n  try {\n    await dbDeleteQuotation(quotationId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete quotation.' };\n  }\n  revalidatePath('/quotations');\n  revalidatePath('/');\n  return { message: 'Successfully deleted quotation.' };\n}\n\n\nconst QuotationTemplateSchema = z.object({\n    name: z.string().min(3, 'Template name must be at least 3 characters.'),\n    prefix: z.string().min(1, 'Prefix is required.'),\n    companyName: z.string().min(3, 'Company name is required.'),\n    companyAddress: z.string().min(10, 'Full company address is required.'),\n    companyGst: z.string().min(15, 'A valid GSTIN is required.').max(15),\n    termsAndConditions: z.string().min(20, 'Terms and conditions are required.'),\n    logoUrl: z.string().url('Please enter a valid URL for the logo.').optional().or(z.literal('')),\n});\n\nexport async function addQuotationTemplateAction(formData: FormData) {\n    const validatedFields = QuotationTemplateSchema.safeParse({\n        name: formData.get('name'),\n        prefix: formData.get('prefix'),\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to create template. Please check the fields.',\n        };\n    }\n\n    try {\n        await dbAddQuotationTemplate(validatedFields.data as NewQuotationTemplate);\n    } catch (error) {\n        return { message: 'Database Error: Failed to create template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully created quotation template.' };\n}\n\nexport async function updateQuotationTemplateAction(id: string, formData: FormData) {\n    const validatedFields = QuotationTemplateSchema.safeParse({\n        name: formData.get('name'),\n        prefix: formData.get('prefix'),\n        companyName: formData.get('companyName'),\n        companyAddress: formData.get('companyAddress'),\n        companyGst: formData.get('companyGst'),\n        termsAndConditions: formData.get('termsAndConditions'),\n        logoUrl: formData.get('logoUrl'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to update template. Please check the fields.',\n        };\n    }\n\n    try {\n        await dbUpdateQuotationTemplate(id, validatedFields.data as QuotationTemplate);\n    } catch (error) {\n        return { message: 'Database Error: Failed to update template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully updated quotation template.' };\n}\n\nexport async function deleteQuotationTemplateAction(id: string) {\n    try {\n        await dbDeleteQuotationTemplate(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete template.' };\n    }\n\n    revalidatePath('/setup/quotation-templates');\n    return { message: 'Successfully deleted quotation template.' };\n}\n\n\nconst AddEmployeeSchema = z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters.'),\n    email: z.string().email('Please enter a valid email.'),\n    phone: z.string().min(10, 'Please enter a valid phone number.'),\n    role: z.string({\n      required_error: \"You need to select a role.\",\n    }),\n    department: z.string({\n        required_error: \"You need to select a department.\",\n    }),\n    address: z.string().min(10, 'Address is required.'),\n});\n\nexport async function addEmployeeAction(formData: FormData) {\n    const validatedFields = AddEmployeeSchema.safeParse({\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        role: formData.get('role'),\n        department: formData.get('department'),\n        address: formData.get('address'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to add employee.',\n        };\n    }\n\n    const [employeeRoles, departments] = await Promise.all([\n        getEmployeeRoles(),\n        getDepartments(),\n    ]);\n\n    const roleExists = employeeRoles.some(r => r.name === validatedFields.data.role);\n    if (!roleExists) {\n        return { message: 'Invalid role selected.' };\n    }\n    const departmentExists = departments.some(d => d.name === validatedFields.data.department);\n    if (!departmentExists) {\n        return { message: 'Invalid department selected.' };\n    }\n\n    try {\n        // Check if Firebase Admin environment variables are configured\n        const requiredEnvVars = ['FIREBASE_PROJECT_ID', 'FIREBASE_PRIVATE_KEY', 'FIREBASE_CLIENT_EMAIL'];\n        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n        \n        if (missingVars.length > 0) {\n            console.warn(`Firebase Admin not configured. Missing: ${missingVars.join(', ')}`);\n            // Just add to database without Firebase Auth integration\n            await dbAddEmployee(validatedFields.data as NewEmployee);\n            revalidatePath('/employees');\n            return { \n                message: 'Employee added to database. Note: Firebase Auth integration requires environment variables to be configured for automatic account creation and email sending.'\n            };\n        }\n\n        // Initialize Firebase Admin\n        initializeFirebaseAdmin();\n        const auth = getAuth();\n\n        // Create user in Firebase Auth\n        const userRecord = await auth.createUser({\n            email: validatedFields.data.email,\n            displayName: validatedFields.data.name,\n            emailVerified: false,\n        });\n\n        // Add employee to database first\n        await dbAddEmployee(validatedFields.data as NewEmployee);\n\n        // Set a temporary password for the user\n        const tempPassword = Math.random().toString(36).slice(-12) + 'A1!'; // Ensure it meets Firebase requirements\n        \n        // Update the user with the temporary password\n        await auth.updateUser(userRecord.uid, {\n            password: tempPassword,\n        });\n\n        // Send password reset email using Firebase Auth's REST API\n        try {\n            const webApiKey = process.env.FIREBASE_WEB_API_KEY;\n            \n            if (!webApiKey) {\n                throw new Error('FIREBASE_WEB_API_KEY not configured');\n            }\n\n            // Use Firebase Auth REST API to send password reset email\n            const response = await fetch(`https://identitytoolkit.googleapis.com/v1/accounts:sendOobCode?key=${webApiKey}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    requestType: 'PASSWORD_RESET',\n                    email: validatedFields.data.email,\n                    continueUrl: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/login`,\n                }),\n            });\n\n            if (response.ok) {\n                const responseData = await response.json();\n                console.log('='.repeat(80));\n                console.log(`‚úÖ EMPLOYEE CREATED: ${validatedFields.data.name}`);\n                console.log(`üìß Email: ${validatedFields.data.email}`);\n                console.log(`üì® Password reset email sent successfully!`);\n                console.log(`üì¨ Email will be delivered by Firebase Auth`);\n                console.log('='.repeat(80));\n\n                revalidatePath('/employees');\n                return { \n                    message: `Successfully added employee ${validatedFields.data.name}. Password reset email has been sent to ${validatedFields.data.email}.`,\n                };\n            } else {\n                const errorData = await response.json();\n                console.error('Failed to send password reset email:', errorData);\n                throw new Error(`Email sending failed: ${errorData.error?.message || 'Unknown error'}`);\n            }\n        } catch (emailError) {\n            console.error('Error sending password reset email:', emailError);\n            \n            // Fallback: generate link for manual sharing\n            const resetLink = await auth.generatePasswordResetLink(validatedFields.data.email, {\n                url: `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/auth/login`,\n                handleCodeInApp: false,\n            });\n\n            console.log('='.repeat(80));\n            console.log(`‚úÖ EMPLOYEE CREATED: ${validatedFields.data.name}`);\n            console.log(`üìß Email: ${validatedFields.data.email}`);\n            console.log(`‚ùå Email sending failed: ${emailError.message}`);\n            console.log(`üîó Manual Reset Link: ${resetLink}`);\n            console.log(`üìù Please share this link with the employee`);\n            console.log('='.repeat(80));\n\n            revalidatePath('/employees');\n            return { \n                message: `Successfully added employee ${validatedFields.data.name}. Email sending failed - please share the reset link manually (check console).`,\n                resetLink: resetLink\n            };\n        }\n    } catch (error: any) {\n        console.error('Error adding employee:', error);\n        \n        // Handle specific Firebase errors\n        if (error.code === 'auth/email-already-exists') {\n            return { message: 'An account with this email already exists.' };\n        }\n        \n        if (error.message?.includes('Missing required Firebase environment variables')) {\n            // Fallback: add to database only\n            try {\n                await dbAddEmployee(validatedFields.data as NewEmployee);\n                revalidatePath('/employees');\n                return { \n                    message: 'Employee added to database. Firebase Auth integration requires proper environment configuration for automatic account creation.'\n                };\n            } catch (dbError) {\n                return { message: 'Failed to add employee to database.' };\n            }\n        }\n        \n        return { message: 'Failed to add employee. Please check Firebase configuration and try again.' };\n    }\n}\n\nexport async function deleteEmployeeAction(employeeId: string) {\n  try {\n    await dbDeleteEmployee(employeeId);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete employee.' };\n  }\n  revalidatePath('/employees');\n  revalidatePath('/');\n  return { message: 'Successfully deleted employee.' };\n}\n\nconst UpdateEmployeeSchema = z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters.'),\n    email: z.string().email('Please enter a valid email.'),\n    phone: z.string().min(10, 'Please enter a valid phone number.'),\n    role: z.string(),\n    department: z.string(),\n    address: z.string().min(10, 'Address is required.'),\n});\n\nexport async function updateEmployeeAction(id: string, formData: FormData) {\n    const validatedFields = UpdateEmployeeSchema.safeParse({\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        role: formData.get('role'),\n        department: formData.get('department'),\n        address: formData.get('address'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Failed to update employee.',\n        };\n    }\n\n    try {\n        await dbUpdateEmployee(id, validatedFields.data as NewEmployee);\n    } catch (error) {\n        return { message: 'Database Error: Failed to update employee.' };\n    }\n\n    revalidatePath('/employees');\n    revalidatePath('/');\n    return { message: 'Successfully updated employee.' };\n}\n\n\nconst AddEmployeeRoleSchema = z.object({\n    name: z.string().min(2, 'Role name must be at least 2 characters'),\n});\n\nexport async function addEmployeeRoleAction(formData: FormData) {\n    const validatedFields = AddEmployeeRoleSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddEmployeeRole(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add role.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: `Successfully added role '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteEmployeeRoleAction(id: string) {\n    try {\n        await dbDeleteEmployeeRole(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete role.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: 'Successfully deleted role.' };\n}\n\nconst AddDepartmentSchema = z.object({\n    name: z.string().min(2, 'Department name must be at least 2 characters'),\n});\n\nexport async function addDepartmentAction(formData: FormData) {\n    const validatedFields = AddDepartmentSchema.safeParse({\n        name: formData.get('name'),\n    });\n\n    if (!validatedFields.success) {\n        return {\n            message: validatedFields.error.flatten().fieldErrors.name?.[0] ?? 'Invalid name',\n        };\n    }\n\n    try {\n        await dbAddDepartment(validatedFields.data.name);\n    } catch (error) {\n        return { message: 'Database Error: Failed to add department.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: `Successfully added department '${validatedFields.data.name}'.` };\n}\n\nexport async function deleteDepartmentAction(id: string) {\n    try {\n        await dbDeleteDepartment(id);\n    } catch (error) {\n        return { message: 'Database Error: Failed to delete department.' };\n    }\n\n    revalidatePath('/setup');\n    return { message: 'Successfully deleted department.' };\n}\n\n// CSV Import Actions\nconst ImportProductSchema = z.object({\n    name: z.string().min(3, { message: 'Product name must be at least 3 characters.' }),\n    price: z.coerce.number().min(0, { message: 'Price must be a positive number.' }),\n    gstRate: z.coerce.number().min(0).max(100),\n    skus: z.array(z.string()).optional(),\n    catalogueUrl: z.string().url('Please enter a valid URL.').optional().or(z.literal('')),\n});\n\nexport async function importProductsFromCSV(csvData: any[]) {\n    const results = {\n        success: 0,\n        failed: 0,\n        errors: [] as string[]\n    };\n\n// Get all existing product categories to match against\nconst allCategories = await getProductCategories();\n\n    for (let i = 0; i < csvData.length; i++) {\n        const row = csvData[i];\n        \n        try {\n            // Parse SKUs from comma-separated string\n            const skus = row.skus ? row.skus.split(',').map((sku: string) => sku.trim()).filter(Boolean) : [];\n            \n// Match category by exact name (single category)\nlet categoryId: string | undefined = undefined;\nconst categoryName = (row.category || row.categories || '').toString().trim();\nif (categoryName) {\n    const existingCategory = allCategories.find((c) => c.name === categoryName);\n    if (existingCategory) {\n        categoryId = existingCategory.id;\n    } else {\n        results.errors.push(`Row ${i + 1}: Category not found: ${categoryName}. Please create this category first.`);\n    }\n}\n            \n// Prepare data for validation, including optional fields\n            const dataForValidation = {\n                name: row.name,\n                price: row.price,\n                gstRate: row.gstRate,\n                ...(skus.length > 0 && { skus }),\n                ...(row.catalogueUrl && row.catalogueUrl.trim() && { catalogueUrl: row.catalogueUrl }),\n            };\n\n            const validatedData = ImportProductSchema.parse(dataForValidation);\n\n            // Prepare data for database - only include defined fields\nconst productData = {\n    name: validatedData.name,\n    price: validatedData.price,\n    gstRate: validatedData.gstRate,\n    ...(validatedData.skus && { skus: validatedData.skus }),\n    ...(validatedData.catalogueUrl && { catalogueUrl: validatedData.catalogueUrl }),\n    ...(categoryId && { categoryId }),\n};\n\n            await dbAddProduct(productData);\n            \n            results.success++;\n        } catch (error) {\n            results.failed++;\n            if (error instanceof z.ZodError) {\n                const errorMessages = error.errors.map(e => `Row ${i + 1}: ${e.path.join('.')} - ${e.message}`);\n                results.errors.push(...errorMessages);\n            } else {\n                results.errors.push(`Row ${i + 1}: Failed to import product - ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        }\n    }\n\n    // Revalidate pages after import\n    revalidatePath('/products');\n    revalidatePath('/leads');\n\n    return {\n        success: results.failed === 0,\n        message: `Import completed. ${results.success} products imported successfully${results.failed > 0 ? `, ${results.failed} failed` : ''}.`,\n        errors: results.errors.length > 0 ? results.errors : undefined\n    };\n}\n\n// Count Actions\nexport async function getLeadsCountAction(): Promise<number> {\n    try {\n        return await getLeadsCount();\n    } catch (error) {\n        console.error('Error getting leads count:', error);\n        return 0;\n    }\n}\n\nexport async function getQuotationsCountAction(): Promise<number> {\n    try {\n        return await getQuotationsCount();\n    } catch (error) {\n        console.error('Error getting quotations count:', error);\n        return 0;\n    }\n}\n\nexport async function getProductsCountAction(): Promise<number> {\n    try {\n        return await getProductsCount();\n    } catch (error) {\n        console.error('Error getting products count:', error);\n        return 0;\n    }\n}\n\nexport async function getEmployeesCountAction(): Promise<number> {\n    try {\n        return await getEmployeesCount();\n    } catch (error) {\n        console.error('Error getting employees count:', error);\n        return 0;\n    }\n}\n\nexport async function getLeadsCountByStatusAction(status: LeadStatus): Promise<number> {\n    try {\n        return await getLeadsCountByStatus(status);\n    } catch (error) {\n        console.error(`Error getting leads count for status ${status}:`, error);\n        return 0;\n    }\n}\n\nexport async function getQuotationsCountByStatusAction(status: 'Draft' | 'Sent' | 'Accepted' | 'Rejected'): Promise<number> {\n    try {\n        return await getQuotationsCountByStatus(status);\n    } catch (error) {\n        console.error(`Error getting quotations count for status ${status}:`, error);\n        return 0;\n    }\n}\n\nexport async function getActiveProductsCountAction(): Promise<number> {\n    try {\n        return await getActiveProductsCount();\n    } catch (error) {\n        console.error('Error getting active products count:', error);\n        return 0;\n    }\n}\n\nexport async function getActiveEmployeesCountAction(): Promise<number> {\n    try {\n        return await getActiveEmployeesCount();\n    } catch (error) {\n        console.error('Error getting active employees count:', error);\n        return 0;\n    }\n}\n\n// Communication Activity Actions\nconst CommunicationActivitySchema = z.object({\n  leadId: z.string().min(1, 'Lead ID is required'),\n  type: z.enum(['WhatsApp', 'Email']),\n  message: z.string().min(1, 'Message is required'),\n  contact: z.string().min(1, 'Contact is required'),\n  sentBy: z.string().min(1, 'Sent by is required'),\n});\n\nexport async function logCommunicationActivityAction(formData: FormData) {\n  const validatedFields = CommunicationActivitySchema.safeParse({\n    leadId: formData.get('leadId'),\n    type: formData.get('type'),\n    message: formData.get('message'),\n    contact: formData.get('contact'),\n    sentBy: formData.get('sentBy'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Missing Fields. Failed to log communication activity.',\n    };\n  }\n\n  const { leadId, type, message, contact, sentBy } = validatedFields.data;\n\n  try {\n    const activityNotes = `${type} message sent to ${contact} by ${sentBy}:\\n\\n\"${message}\"`;\n    \n    await addActivityToLead(leadId, {\n      type: type as 'WhatsApp' | 'Email',\n      notes: activityNotes\n    });\n  } catch (error) {\n    const errMsg = error instanceof Error ? error.message : String(error);\n    console.error('LogCommunicationActivity Error:', errMsg);\n    if (errMsg.includes('Lead not found')) {\n      return { message: 'Lead not found. Please refresh the page and try again.' };\n    }\n    return { message: 'Database Error: Failed to log communication activity.' };\n  }\n\n  return { message: `Successfully logged ${type} communication.` };\n}\n\nexport async function getCurrentUserEmployeeAction(email: string): Promise<Employee | null> {\n    try {\n        return await getEmployeeByEmail(email);\n    } catch (error) {\n        console.error('Error getting current user employee:', error);\n        return null;\n    }\n}\n\n// ==================== Currency Actions ====================\nimport { addCurrency as dbAddCurrency, updateCurrency as dbUpdateCurrency, deleteCurrency as dbDeleteCurrency } from './firestore-service';\n\nconst CurrencySchema = z.object({\n  code: z.string().min(2, 'Currency code must be at least 2 characters').max(5, 'Currency code must be at most 5 characters'),\n  name: z.string().min(2, 'Currency name is required'),\n  symbol: z.string().min(1, 'Currency symbol is required'),\n  conversionRate: z.coerce.number().positive('Conversion rate must be positive'),\n});\n\nexport async function addCurrencyAction(formData: FormData) {\n  const validatedFields = CurrencySchema.safeParse({\n    code: formData.get('code'),\n    name: formData.get('name'),\n    symbol: formData.get('symbol'),\n    conversionRate: formData.get('conversionRate'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Validation Error: Failed to add currency.',\n    };\n  }\n\n  try {\n    await dbAddCurrency(validatedFields.data);\n  } catch (error) {\n    return { message: 'Database Error: Failed to add currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully added currency.' };\n}\n\nexport async function updateCurrencyAction(id: string, formData: FormData) {\n  const validatedFields = CurrencySchema.safeParse({\n    code: formData.get('code'),\n    name: formData.get('name'),\n    symbol: formData.get('symbol'),\n    conversionRate: formData.get('conversionRate'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Validation Error: Failed to update currency.',\n    };\n  }\n\n  try {\n    await dbUpdateCurrency(id, validatedFields.data);\n  } catch (error) {\n    return { message: 'Database Error: Failed to update currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully updated currency.' };\n}\n\nexport async function deleteCurrencyAction(id: string) {\n  try {\n    await dbDeleteCurrency(id);\n  } catch (error) {\n    return { message: 'Database Error: Failed to delete currency.' };\n  }\n\n  revalidatePath('/setup');\n  return { message: 'Successfully deleted currency.' };\n}\n\n"],"names":[],"mappings":";;;;;;IAmcwB,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 3998, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/products/delete-product-dialog.tsx"],"sourcesContent":["'use client';\n\nimport { useState } from 'react';\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from '@/components/ui/alert-dialog';\nimport { Button } from '@/components/ui/button';\nimport { useToast } from '@/hooks/use-toast';\nimport { deleteProduct } from '@/lib/actions';\nimport { Product } from '@/lib/business-types';\n\ntype DeleteProductDialogProps = {\n  product: Product;\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n};\n\nexport function DeleteProductDialog({ product, open, onOpenChange }: DeleteProductDialogProps) {\n  const [isDeleting, setIsDeleting] = useState(false);\n  const { toast } = useToast();\n\n  const handleDelete = async () => {\n    if (!product.id) {\n      toast({\n        variant: 'destructive',\n        title: 'Error',\n        description: 'Product ID is missing',\n      });\n      return;\n    }\n\n    setIsDeleting(true);\n    const result = await deleteProduct(product.id);\n    if (result.message === 'Successfully deleted product.') {\n      toast({\n        title: 'Product Deleted',\n        description: `\"${product.name}\" has been deleted.`,\n      });\n      onOpenChange(false);\n    } else {\n      toast({\n        variant: 'destructive',\n        title: 'Error',\n        description: result.message,\n      });\n    }\n    setIsDeleting(false);\n  };\n\n  return (\n    <AlertDialog open={open} onOpenChange={onOpenChange}>\n      <AlertDialogContent>\n        <AlertDialogHeader>\n          <AlertDialogTitle>Are you sure?</AlertDialogTitle>\n          <AlertDialogDescription>\n            This action cannot be undone. This will permanently delete the product\n            <span className=\"font-semibold\"> {product.name}</span>.\n          </AlertDialogDescription>\n        </AlertDialogHeader>\n        <AlertDialogFooter>\n          <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>\n          <AlertDialogAction asChild>\n            <Button\n              variant=\"destructive\"\n              onClick={handleDelete}\n              disabled={isDeleting}\n            >\n              {isDeleting ? 'Deleting...' : 'Delete'}\n            </Button>\n          </AlertDialogAction>\n        </AlertDialogFooter>\n      </AlertDialogContent>\n    </AlertDialog>\n  );\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AAUA;AACA;AACA;AAfA;;;;;;;AAwBO,SAAS,oBAAoB,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,EAA4B;IAC3F,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAC7C,MAAM,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,4HAAA,CAAA,WAAQ,AAAD;IAEzB,MAAM,eAAe;QACnB,IAAI,CAAC,QAAQ,EAAE,EAAE;YACf,MAAM;gBACJ,SAAS;gBACT,OAAO;gBACP,aAAa;YACf;YACA;QACF;QAEA,cAAc;QACd,MAAM,SAAS,MAAM,CAAA,GAAA,kJAAA,CAAA,gBAAa,AAAD,EAAE,QAAQ,EAAE;QAC7C,IAAI,OAAO,OAAO,KAAK,iCAAiC;YACtD,MAAM;gBACJ,OAAO;gBACP,aAAa,CAAC,CAAC,EAAE,QAAQ,IAAI,CAAC,mBAAmB,CAAC;YACpD;YACA,aAAa;QACf,OAAO;YACL,MAAM;gBACJ,SAAS;gBACT,OAAO;gBACP,aAAa,OAAO,OAAO;YAC7B;QACF;QACA,cAAc;IAChB;IAEA,qBACE,8OAAC,2IAAA,CAAA,cAAW;QAAC,MAAM;QAAM,cAAc;kBACrC,cAAA,8OAAC,2IAAA,CAAA,qBAAkB;;8BACjB,8OAAC,2IAAA,CAAA,oBAAiB;;sCAChB,8OAAC,2IAAA,CAAA,mBAAgB;sCAAC;;;;;;sCAClB,8OAAC,2IAAA,CAAA,yBAAsB;;gCAAC;8CAEtB,8OAAC;oCAAK,WAAU;;wCAAgB;wCAAE,QAAQ,IAAI;;;;;;;gCAAQ;;;;;;;;;;;;;8BAG1D,8OAAC,2IAAA,CAAA,oBAAiB;;sCAChB,8OAAC,2IAAA,CAAA,oBAAiB;4BAAC,UAAU;sCAAY;;;;;;sCACzC,8OAAC,2IAAA,CAAA,oBAAiB;4BAAC,OAAO;sCACxB,cAAA,8OAAC,kIAAA,CAAA,SAAM;gCACL,SAAQ;gCACR,SAAS;gCACT,UAAU;0CAET,aAAa,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAO5C","debugId":null}},
    {"offset": {"line": 4135, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/products/product-actions.tsx"],"sourcesContent":["'use client';\n\nimport { useState } from 'react';\nimport { MoreHorizontal, Edit, Trash2, Eye } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu';\nimport { Product } from '@/lib/business-types';\nimport { EditProductSheet } from './edit-product-sheet';\nimport { DeleteProductDialog } from './delete-product-dialog';\n\nexport function ProductActions({ product }: { product: Product }) {\n  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);\n  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);\n\n  return (\n    <>\n      <EditProductSheet product={product} open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen} />\n      <DeleteProductDialog product={product} open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen} />\n      <DropdownMenu>\n        <DropdownMenuTrigger asChild>\n          <Button variant=\"ghost\" className=\"h-8 w-8 p-0\">\n            <span className=\"sr-only\">Open menu</span>\n            <MoreHorizontal className=\"h-4 w-4\" />\n          </Button>\n        </DropdownMenuTrigger>\n        <DropdownMenuContent align=\"end\">\n          <DropdownMenuLabel>Actions</DropdownMenuLabel>\n          <DropdownMenuSeparator />\n          <DropdownMenuItem onSelect={() => setIsEditDialogOpen(true)}>\n            <Eye className=\"mr-2 h-4 w-4\" />\n            View\n          </DropdownMenuItem>\n          <DropdownMenuItem onSelect={() => setIsEditDialogOpen(true)}>\n            <Edit className=\"mr-2 h-4 w-4\" />\n            Edit\n          </DropdownMenuItem>\n          <DropdownMenuItem\n            onSelect={() => setIsDeleteDialogOpen(true)}\n            className=\"text-destructive focus:bg-destructive/10 focus:text-destructive\"\n          >\n            <Trash2 className=\"mr-2 h-4 w-4\" />\n            Delete\n          </DropdownMenuItem>\n        </DropdownMenuContent>\n      </DropdownMenu>\n    </>\n  );\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AASA;AACA;AAfA;;;;;;;;AAiBO,SAAS,eAAe,EAAE,OAAO,EAAwB;IAC9D,MAAM,CAAC,kBAAkB,oBAAoB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IACzD,MAAM,CAAC,oBAAoB,sBAAsB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAE7D,qBACE;;0BACE,8OAAC,mJAAA,CAAA,mBAAgB;gBAAC,SAAS;gBAAS,MAAM;gBAAkB,cAAc;;;;;;0BAC1E,8OAAC,sJAAA,CAAA,sBAAmB;gBAAC,SAAS;gBAAS,MAAM;gBAAoB,cAAc;;;;;;0BAC/E,8OAAC,4IAAA,CAAA,eAAY;;kCACX,8OAAC,4IAAA,CAAA,sBAAmB;wBAAC,OAAO;kCAC1B,cAAA,8OAAC,kIAAA,CAAA,SAAM;4BAAC,SAAQ;4BAAQ,WAAU;;8CAChC,8OAAC;oCAAK,WAAU;8CAAU;;;;;;8CAC1B,8OAAC,gNAAA,CAAA,iBAAc;oCAAC,WAAU;;;;;;;;;;;;;;;;;kCAG9B,8OAAC,4IAAA,CAAA,sBAAmB;wBAAC,OAAM;;0CACzB,8OAAC,4IAAA,CAAA,oBAAiB;0CAAC;;;;;;0CACnB,8OAAC,4IAAA,CAAA,wBAAqB;;;;;0CACtB,8OAAC,4IAAA,CAAA,mBAAgB;gCAAC,UAAU,IAAM,oBAAoB;;kDACpD,8OAAC,gMAAA,CAAA,MAAG;wCAAC,WAAU;;;;;;oCAAiB;;;;;;;0CAGlC,8OAAC,4IAAA,CAAA,mBAAgB;gCAAC,UAAU,IAAM,oBAAoB;;kDACpD,8OAAC,2MAAA,CAAA,OAAI;wCAAC,WAAU;;;;;;oCAAiB;;;;;;;0CAGnC,8OAAC,4IAAA,CAAA,mBAAgB;gCACf,UAAU,IAAM,sBAAsB;gCACtC,WAAU;;kDAEV,8OAAC,0MAAA,CAAA,SAAM;wCAAC,WAAU;;;;;;oCAAiB;;;;;;;;;;;;;;;;;;;;;AAO/C","debugId":null}},
    {"offset": {"line": 4301, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/components/pdf-viewer.tsx"],"sourcesContent":["'use client';\n\nimport { useState } from 'react';\nimport { Button } from '@/components/ui/button';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from '@/components/ui/dialog';\nimport { FileText, Download, ExternalLink } from 'lucide-react';\nimport { Badge } from '@/components/ui/badge';\n\ninterface PDFViewerProps {\n  pdfData: {\n    url: string; // Firebase Storage download URL\n    fileName: string;\n    filePath: string;\n    uploadedAt: string;\n  };\n  trigger?: React.ReactNode;\n}\n\nexport function PDFViewer({ pdfData, trigger }: PDFViewerProps) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const handleDownload = () => {\n    const link = document.createElement('a');\n    link.href = pdfData.url;\n    link.download = pdfData.fileName;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  };\n\n  const handleOpenInNewTab = () => {\n    const newWindow = window.open();\n    if (newWindow) {\n      newWindow.document.write(`\n        <html>\n          <head>\n            <title>${pdfData.fileName}</title>\n            <style>\n              body { margin: 0; padding: 0; }\n              iframe { width: 100vw; height: 100vh; border: none; }\n            </style>\n          </head>\n          <body>\n            <iframe src=\"${pdfData.url}\" type=\"application/pdf\"></iframe>\n          </body>\n        </html>\n      `);\n      newWindow.document.close();\n    }\n  };\n\n  const formatDate = (dateString: string) => {\n    return new Date(dateString).toLocaleDateString('en-IN', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  };\n\n  const formatFileSize = () => {\n    // Since we're using Firebase Storage, we can't easily get file size from URL\n    // This is a placeholder - in a real implementation, you might want to store file size in metadata\n    return 'PDF File';\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={setIsOpen}>\n      <DialogTrigger asChild>\n        {trigger || (\n          <Button variant=\"outline\" size=\"sm\" className=\"flex items-center gap-1\">\n            <FileText className=\"h-4 w-4\" />\n            View PDF\n          </Button>\n        )}\n      </DialogTrigger>\n      <DialogContent className=\"max-w-[80vw] h-[90vh] flex flex-col\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center gap-2\">\n            <FileText className=\"h-5 w-5\" />\n            {pdfData.fileName}\n          </DialogTitle>\n          <DialogDescription className=\"flex items-center gap-4\">\n            <span>Uploaded: {formatDate(pdfData.uploadedAt)}</span>\n            <Badge variant=\"secondary\">{formatFileSize()}</Badge>\n          </DialogDescription>\n        </DialogHeader>\n        \n        <div className=\"flex gap-2 mb-4\">\n          <Button onClick={handleDownload} variant=\"outline\" size=\"sm\">\n            <Download className=\"h-4 w-4 mr-2\" />\n            Download\n          </Button>\n          <Button onClick={handleOpenInNewTab} variant=\"outline\" size=\"sm\">\n            <ExternalLink className=\"h-4 w-4 mr-2\" />\n            Open in New Tab\n          </Button>\n        </div>\n\n        <div className=\"flex-1 min-h-0\">\n          <iframe\n            src={pdfData.url}\n            className=\"w-full h-full border rounded-md\"\n            title={pdfData.fileName}\n          />\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AAQA;AAAA;AAAA;AACA;AAbA;;;;;;;AAyBO,SAAS,UAAU,EAAE,OAAO,EAAE,OAAO,EAAkB;IAC5D,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAErC,MAAM,iBAAiB;QACrB,MAAM,OAAO,SAAS,aAAa,CAAC;QACpC,KAAK,IAAI,GAAG,QAAQ,GAAG;QACvB,KAAK,QAAQ,GAAG,QAAQ,QAAQ;QAChC,SAAS,IAAI,CAAC,WAAW,CAAC;QAC1B,KAAK,KAAK;QACV,SAAS,IAAI,CAAC,WAAW,CAAC;IAC5B;IAEA,MAAM,qBAAqB;QACzB,MAAM,YAAY,OAAO,IAAI;QAC7B,IAAI,WAAW;YACb,UAAU,QAAQ,CAAC,KAAK,CAAC,CAAC;;;mBAGb,EAAE,QAAQ,QAAQ,CAAC;;;;;;;yBAOb,EAAE,QAAQ,GAAG,CAAC;;;MAGjC,CAAC;YACD,UAAU,QAAQ,CAAC,KAAK;QAC1B;IACF;IAEA,MAAM,aAAa,CAAC;QAClB,OAAO,IAAI,KAAK,YAAY,kBAAkB,CAAC,SAAS;YACtD,MAAM;YACN,OAAO;YACP,KAAK;YACL,MAAM;YACN,QAAQ;QACV;IACF;IAEA,MAAM,iBAAiB;QACrB,6EAA6E;QAC7E,kGAAkG;QAClG,OAAO;IACT;IAEA,qBACE,8OAAC,kIAAA,CAAA,SAAM;QAAC,MAAM;QAAQ,cAAc;;0BAClC,8OAAC,kIAAA,CAAA,gBAAa;gBAAC,OAAO;0BACnB,yBACC,8OAAC,kIAAA,CAAA,SAAM;oBAAC,SAAQ;oBAAU,MAAK;oBAAK,WAAU;;sCAC5C,8OAAC,8MAAA,CAAA,WAAQ;4BAAC,WAAU;;;;;;wBAAY;;;;;;;;;;;;0BAKtC,8OAAC,kIAAA,CAAA,gBAAa;gBAAC,WAAU;;kCACvB,8OAAC,kIAAA,CAAA,eAAY;;0CACX,8OAAC,kIAAA,CAAA,cAAW;gCAAC,WAAU;;kDACrB,8OAAC,8MAAA,CAAA,WAAQ;wCAAC,WAAU;;;;;;oCACnB,QAAQ,QAAQ;;;;;;;0CAEnB,8OAAC,kIAAA,CAAA,oBAAiB;gCAAC,WAAU;;kDAC3B,8OAAC;;4CAAK;4CAAW,WAAW,QAAQ,UAAU;;;;;;;kDAC9C,8OAAC,iIAAA,CAAA,QAAK;wCAAC,SAAQ;kDAAa;;;;;;;;;;;;;;;;;;kCAIhC,8OAAC;wBAAI,WAAU;;0CACb,8OAAC,kIAAA,CAAA,SAAM;gCAAC,SAAS;gCAAgB,SAAQ;gCAAU,MAAK;;kDACtD,8OAAC,0MAAA,CAAA,WAAQ;wCAAC,WAAU;;;;;;oCAAiB;;;;;;;0CAGvC,8OAAC,kIAAA,CAAA,SAAM;gCAAC,SAAS;gCAAoB,SAAQ;gCAAU,MAAK;;kDAC1D,8OAAC,sNAAA,CAAA,eAAY;wCAAC,WAAU;;;;;;oCAAiB;;;;;;;;;;;;;kCAK7C,8OAAC;wBAAI,WAAU;kCACb,cAAA,8OAAC;4BACC,KAAK,QAAQ,GAAG;4BAChB,WAAU;4BACV,OAAO,QAAQ,QAAQ;;;;;;;;;;;;;;;;;;;;;;;AAMnC","debugId":null}},
    {"offset": {"line": 4530, "column": 0}, "map": {"version":3,"sources":["file:///Users/gauravshukla/Downloads/ll/src/app/products/products-filters.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { usePathname, useRouter, useSearchParams } from \"next/navigation\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n} from \"@/components/ui/select\";\r\n\r\ninterface ProductsFiltersProps {\r\n  categories: { id: string; name: string }[];\r\n}\r\n\r\nexport function ProductsFilters({ categories }: ProductsFiltersProps) {\r\n  const router = useRouter();\r\n  const pathname = usePathname();\r\n  const searchParams = useSearchParams();\r\n\r\n  const currentCategory = searchParams.get(\"category\") || \"all\";\r\n\r\n  const handleCategoryChange = (value: string) => {\r\n    const params = new URLSearchParams(searchParams.toString());\r\n\r\n    if (value === \"all\") {\r\n      params.delete(\"category\");\r\n    } else {\r\n      params.set(\"category\", value);\r\n    }\r\n\r\n    const query = params.toString();\r\n    router.replace(query ? `${pathname}?${query}` : pathname);\r\n  };\r\n\r\n  return (\r\n    <div className=\"flex items-center gap-2\">\r\n      <Select value={currentCategory} onValueChange={handleCategoryChange}>\r\n        <SelectTrigger className=\"w-[200px]\">\r\n          <SelectValue placeholder=\"Filter by category\" />\r\n        </SelectTrigger>\r\n        <SelectContent>\r\n          <SelectItem value=\"all\">All categories</SelectItem>\r\n          {categories.map((category) => (\r\n            <SelectItem key={category.id} value={category.id}>\r\n              {category.name}\r\n            </SelectItem>\r\n          ))}\r\n        </SelectContent>\r\n      </Select>\r\n    </div>\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;;AAeO,SAAS,gBAAgB,EAAE,UAAU,EAAwB;IAClE,MAAM,SAAS,CAAA,GAAA,kIAAA,CAAA,YAAS,AAAD;IACvB,MAAM,WAAW,CAAA,GAAA,kIAAA,CAAA,cAAW,AAAD;IAC3B,MAAM,eAAe,CAAA,GAAA,kIAAA,CAAA,kBAAe,AAAD;IAEnC,MAAM,kBAAkB,aAAa,GAAG,CAAC,eAAe;IAExD,MAAM,uBAAuB,CAAC;QAC5B,MAAM,SAAS,IAAI,gBAAgB,aAAa,QAAQ;QAExD,IAAI,UAAU,OAAO;YACnB,OAAO,MAAM,CAAC;QAChB,OAAO;YACL,OAAO,GAAG,CAAC,YAAY;QACzB;QAEA,MAAM,QAAQ,OAAO,QAAQ;QAC7B,OAAO,OAAO,CAAC,QAAQ,GAAG,SAAS,CAAC,EAAE,OAAO,GAAG;IAClD;IAEA,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC,kIAAA,CAAA,SAAM;YAAC,OAAO;YAAiB,eAAe;;8BAC7C,8OAAC,kIAAA,CAAA,gBAAa;oBAAC,WAAU;8BACvB,cAAA,8OAAC,kIAAA,CAAA,cAAW;wBAAC,aAAY;;;;;;;;;;;8BAE3B,8OAAC,kIAAA,CAAA,gBAAa;;sCACZ,8OAAC,kIAAA,CAAA,aAAU;4BAAC,OAAM;sCAAM;;;;;;wBACvB,WAAW,GAAG,CAAC,CAAC,yBACf,8OAAC,kIAAA,CAAA,aAAU;gCAAmB,OAAO,SAAS,EAAE;0CAC7C,SAAS,IAAI;+BADC,SAAS,EAAE;;;;;;;;;;;;;;;;;;;;;;AAQxC","debugId":null}}]
}