"use client";

import { useEffect, useState } from "react";
import type { Batch, ProcessingStageName, ActivityLog } from "@/lib/types";
import { useForm, useFieldArray } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Card, CardContent } from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@/components/ui/form";
import { Checkbox } from "@/components/ui/checkbox";
import { useToast } from "@/hooks/use-toast";
import { format } from "date-fns";
import { useRouter } from "next/navigation";
import {
  subscribeToBatchesForStage,
  updateBatchStage,
  completeStage,
} from "@/lib/firebase";
import { useRawMaterials } from "@/hooks/use-raw-materials";
import { useFinalStock } from "@/hooks/use-final-stock";
import { useActivityLog } from "@/hooks/use-activity-log";

const formSchema = z.object({
  batches: z.array(
    z.object({
      id: z.string(),
      accepted: z.coerce.number().min(0),
      rejected: z.coerce.number().min(0),
      actualConsumption: z.coerce.number().min(0),
      materials: z.array(
        z.object({
          id: z.string(),
          name: z.string(),
          quantity: z.number(),
          unit: z.string(),
          actualConsumption: z.coerce.number().min(0),
        }),
      ),
    }),
  ),
});
</text>

<old_text line=87>
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      batches: batches.map((b) => ({
        id: b.id,
        accepted: b.processingStages[stage]?.accepted || 0,
        rejected: b.processingStages[stage]?.rejected || 0,
        actualConsumption: b.processingStages[stage]?.actualConsumption || 0,
      })),
    },
  });

interface BatchStageProcessorProps {
  stage: ProcessingStageName;
  previousStage: ProcessingStageName | null;
}

export function BatchStageProcessor({
  stage,
  previousStage,
}: BatchStageProcessorProps) {
  const [batches, setBatches] = useState<Batch[]>([]);
  const [selectedBatches, setSelectedBatches] = useState<Set<string>>(
    new Set(),
  );
  const { rawMaterials, updateRawMaterial, deleteRawMaterial } =
    useRawMaterials();
  const { finalStock, createFinalStock } = useFinalStock();
  const { createActivityLog } = useActivityLog();
  const { toast } = useToast();
  const router = useRouter();

  useEffect(() => {
    console.log("[v0] Setting up real-time subscription for stage:", stage);
    const unsubscribe = subscribeToBatchesForStage(stage, (updatedBatches) => {
      console.log(
        "[v0] Received batches for",
        stage,
        ":",
        updatedBatches.length,
      );
      setBatches(updatedBatches);
    });

    return () => {
      console.log("[v0] Cleaning up subscription for stage:", stage);
      unsubscribe();
    };
  }, [stage]);

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      batches: batches.map((b) => ({
        id: b.id,
        accepted: b.processingStages[stage]?.accepted || 0,
        rejected: b.processingStages[stage]?.rejected || 0,
        actualConsumption: b.processingStages[stage]?.actualConsumption || 0,
        materials: b.materials
          .filter((m) => m.stage === stage)
          .map((m) => ({
            id: m.id,
            name: m.name,
            quantity: m.quantity,
            unit: m.unit,
            actualConsumption: 0,
          })),
      })),
    },
  });

  const { fields } = useFieldArray({
    control: form.control,
    name: "batches",
  });

  useEffect(() => {
    form.reset({
      batches: batches.map((b) => ({
        id: b.id,
        accepted: b.processingStages[stage]?.accepted || 0,
        rejected: b.processingStages[stage]?.rejected || 0,
        actualConsumption: b.processingStages[stage]?.actualConsumption || 0,
        materials: b.materials
          .filter((m) => m.stage === stage)
          .map((m) => ({
            id: m.id,
            name: m.name,
            quantity: m.quantity,
            unit: m.unit,
            actualConsumption: 0,
          })),
      })),
    });
  }, [batches, form, stage]);
</text>

<old_text line=972>
              <TableBody>
                {fields.map((field, index) => {
                  const batch = batches[index];
                  if (!batch) return null;

                  const rawMaterialInput = getRawMaterialForStage(batch);
                  const fromPrevStageInput = getInputFromPreviousStage(batch);

                  return (
                    <TableRow key={field.id}>
                      <TableCell>
                        <Checkbox
                          checked={selectedBatches.has(batch.id)}
                          onCheckedChange={(checked) => {
                            const newSelected = new Set(selectedBatches);
                            if (checked) {
                              newSelected.add(batch.id);
                            } else {
                              newSelected.delete(batch.id);
                            }
                            setSelectedBatches(newSelected);
                          }}
                        />
                      </TableCell>
                      <TableCell className="font-mono text-xs">
                        {batch.id}
                      </TableCell>
                      <TableCell className="font-medium">
                        {batch.productName}
                      </TableCell>
                      <TableCell>
                        {format(new Date(batch.createdAt), "MM/dd/yyyy")}
                      </TableCell>
                      {labels.prevStage && (
                        <TableCell>
                          {fromPrevStageInput.toLocaleString()}
                        </TableCell>
                      )}
                      <TableCell>{rawMaterialInput.toLocaleString()}</TableCell>
                      <TableCell>
                        <FormField
                          control={form.control}
                          name={`batches.${index}.actualConsumption`}
                          render={({ field }) => (
                            <FormItem>
                              <FormControl>
                                <Input type="number" {...field} />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </TableCell>
                      <TableCell>
                        <FormField
                          control={form.control}
                          name={`batches.${index}.accepted`}
                          render={({ field }) => (
                            <FormItem>
                              <FormControl>
                                <Input type="number" {...field} />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </TableCell>
                      <TableCell>
                        <FormField
                          control={form.control}
                          name={`batches.${index}.rejected`}
                          render={({ field }) => (
                            <FormItem>
                              <FormControl>
                                <Input type="number" {...field} />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </TableCell>
                    </TableRow>
                  );
                })}

  const addLog = async (
    newLog: Omit<ActivityLog, "id" | "timestamp" | "user">,
  ) => {
    await createActivityLog({
      ...newLog,
      timestamp: new Date().toISOString(),
      user: "System",
    });
  };

  const getRawMaterialForStage = (batch: Batch) => {
    return batch.materials
      .filter((mat) => mat.stage === stage)
      .reduce((sum, mat) => sum + mat.quantity, 0);
  };

  const getInputFromPreviousStage = (batch: Batch) => {
    const selectedProcesses = batch.selectedProcesses || [];
    const currentIndex = selectedProcesses.indexOf(stage);

    if (currentIndex <= 0) return 0;

    const actualPreviousStage = selectedProcesses[currentIndex - 1];
    return batch.processingStages[actualPreviousStage]?.accepted || 0;
  };

  const getTotalInput = (batch: Batch): number => {
    const selectedProcesses = batch.selectedProcesses || [];
    const currentIndex = selectedProcesses.indexOf(stage);

    if (currentIndex === 0) {
      return getRawMaterialForStage(batch);
    }

    return getInputFromPreviousStage(batch);
  };

  const getNextDepartment = (
    batch: Batch,
    currentStage: ProcessingStageName,
  ): string | null => {
    const selectedProcesses = batch.selectedProcesses || [];
    const currentIndex = selectedProcesses.indexOf(currentStage);

    if (currentIndex >= 0 && currentIndex < selectedProcesses.length - 1) {
      return selectedProcesses[currentIndex + 1];
    }

    return "Final Stock";
  };

  const getStageLabels = (stageName: ProcessingStageName, batch?: Batch) => {
    const nextDept = batch ? getNextDepartment(batch, stageName) : null;

    switch (stageName) {
      case "Molding":
        return {
          input: "Molding Raw Mat. Input",
          prevStage: null,
          accepted: "Accepted Moulded",
          rejected: "Rejected Moulded",
          consumption: "Actual Consumption",
          nextDept: nextDept || "Machining",
        };
      case "Machining":
        return {
          input: "Machining Raw Mat. Input",
          prevStage: "From Molding",
          accepted: "Accepted Machined",
          rejected: "Rejected Machined",
          consumption: "Actual Consumption",
          nextDept: nextDept || "Assembling",
        };
      case "Assembling":
        return {
          input: "Assembling Raw Mat. Input",
          prevStage: "From Machining",
          accepted: "Accepted Assembled",
          rejected: "Rejected Assembled",
          consumption: "Actual Consumption",
          nextDept: nextDept || "Testing",
        };
      case "Testing":
        return {
          input: "Testing Raw Mat. Input",
          prevStage: "From Assembling",
          accepted: "Accepted Tested",
          rejected: "Rejected Tested",
          consumption: "Actual Consumption",
          nextDept: nextDept || "Final Stock",
        };
    }
  };

  const labels = getStageLabels(stage);

  async function onSubmit(values: z.infer<typeof formSchema>) {
    console.log(
      "[v0] Submitting form for stage:",
      stage,
      "with values:",
      values,
    );

    if (selectedBatches.size === 0) {
      toast({
        variant: "destructive",
        title: "No Batches Selected",
        description: "Please select at least one batch to proceed.",
      });
      return;
    }

    for (const batch of batches) {
      if (!selectedBatches.has(batch.id)) continue;
      const formData = values.batches.find((b) => b.id === batch.id);
      if (!formData) continue;

      const currentTotal = formData.accepted + formData.rejected;
      const isCompleted = currentTotal > 0;

      console.log(
        "[v0] Processing batch:",
        batch.id,
        "isCompleted:",
        isCompleted,
      );

      try {
        await updateBatchStage(batch.id, stage, {
          accepted: formData.accepted,
          rejected: formData.rejected,
          actualConsumption: formData.actualConsumption,
        });
      } catch (error) {
        console.error(`[v0] Failed to update batch ${batch.id}:`, error);
        toast({
          variant: "destructive",
          title: "Batch Update Failed",
          description: `Failed to update batch ${batch.id}. It may have been deleted.`,
        });
        continue;
      }

      // Always complete the stage when proceeding to next stage
      if (!batch.processingStages[stage]?.completed) {
        const nextDept = getNextDepartment(batch, stage);
        toast({
          title: `${nextDept} Dept. Notification`,
          description: `Batch ${batch.id} for ${batch.productName} has completed the ${stage} stage.`,
        });

        // Update raw materials only if there's consumption
        if (isCompleted) {
          const materialsForStage = batch.materials.filter(
            (m) => m.stage === stage,
          );
          for (const materialInBatch of materialsForStage) {
            const materialToUpdate = rawMaterials.find(
              (rm) => rm.id === materialInBatch.id,
            );
            if (materialToUpdate) {
              const consumptionAmount =
                formData.actualConsumption > 0
                  ? formData.actualConsumption
                  : materialInBatch.quantity;
              const oldQuantity = materialToUpdate.quantity;
              const newQuantity = oldQuantity - consumptionAmount;

              if (newQuantity <= 0) {
                // Delete material if quantity reaches 0 or below
                await deleteRawMaterial(materialToUpdate.id);
                await addLog({
                  recordId: materialToUpdate.id,
                  recordType: "RawMaterial",
                  action: "Deleted",
                  details: `Batch ${batch.id} (${stage}) consumed all remaining stock (${oldQuantity} ${materialToUpdate.unit}). Material deleted.`,
                });
              } else {
                await updateRawMaterial(materialToUpdate.id, {
                  quantity: newQuantity,
                });
                await addLog({
                  recordId: materialToUpdate.id,
                  recordType: "RawMaterial",
                  action: "Stock Adjustment (Batch)",
                  details: `Batch ${batch.id} (${stage}) consumed ${consumptionAmount} ${materialToUpdate.unit}. Old qty: ${oldQuantity}, New qty: ${newQuantity}.`,
                });
              }
            }
          }
        }

        // Check if this is the last stage
        const selectedProcesses = batch.selectedProcesses || [];
        const isLastStage =
          selectedProcesses[selectedProcesses.length - 1] === stage;
        const isMachiningOnly =
          selectedProcesses.length === 1 &&
          selectedProcesses[0] === "Machining";

        // If Moulding stage is completed, create or update moulded material in Store
        if (stage === "Molding" && formData.accepted > 0) {
          const { addRawMaterial } = await import(
            "@/lib/firebase/firestore-operations"
          );
          const materialName = `Moulded ${batch.productName}`;
          const existingMaterial = rawMaterials.find(
            (m) => m.name === materialName && m.isMoulded === true,
          );

          if (existingMaterial) {
            // Update existing material quantity
            const oldQuantity = Number(existingMaterial.quantity) || 0;
            const newQuantity = oldQuantity + Number(formData.accepted);
            await updateRawMaterial(existingMaterial.id, {
              quantity: newQuantity,
            });

            await addLog({
              recordId: existingMaterial.id,
              recordType: "RawMaterial",
              action: "Stock Adjustment (Batch)",
              details: `${formData.accepted} moulded items from batch ${batch.id} added to Store. Old qty: ${oldQuantity}, New qty: ${newQuantity}.`,
            });

            toast({
              title: "Moulded Material Updated",
              description: `${formData.accepted} moulded ${batch.productName} added to existing stock.`,
            });
          } else {
            // Create new material
            const mouldedMaterialId = await addRawMaterial({
              name: materialName,
              sku: `MOULD-${Date.now()}`,
              quantity: formData.accepted,
              unit: "pcs",
              threshold: 10,
              isMoulded: true,
              sourceBatchId: batch.id,
              createdAt: new Date().toISOString(),
            });

            await addLog({
              recordId: mouldedMaterialId,
              recordType: "RawMaterial",
              action: "Created",
              details: `${formData.accepted} moulded items from batch ${batch.id} added to Store.`,
            });

            toast({
              title: "Moulded Material Created",
              description: `${formData.accepted} moulded ${batch.productName} added to Store.`,
            });
          }
        }
        // If Machining-only stage is completed, create or update finished material in Store
        else if (
          stage === "Machining" &&
          isMachiningOnly &&
          formData.accepted > 0
        ) {
          const { addRawMaterial } = await import(
            "@/lib/firebase/firestore-operations"
          );
          const materialName = `Finished ${batch.productName}`;
          const existingMaterial = rawMaterials.find(
            (m) => m.name === materialName && m.isFinished === true,
          );

          if (existingMaterial) {
            // Update existing material quantity
            const oldQuantity = Number(existingMaterial.quantity) || 0;
            const newQuantity = oldQuantity + Number(formData.accepted);
            await updateRawMaterial(existingMaterial.id, {
              quantity: newQuantity,
            });

            await addLog({
              recordId: existingMaterial.id,
              recordType: "RawMaterial",
              action: "Stock Adjustment (Batch)",
              details: `${formData.accepted} finished items from batch ${batch.id} added to Store. Old qty: ${oldQuantity}, New qty: ${newQuantity}.`,
            });

            toast({
              title: "Finished Material Updated",
              description: `${formData.accepted} finished ${batch.productName} added to existing stock.`,
            });
          } else {
            // Create new material
            const finishedMaterialId = await addRawMaterial({
              name: materialName,
              sku: `FINISH-${Date.now()}`,
              quantity: formData.accepted,
              unit: "pcs",
              threshold: 10,
              isFinished: true,
              sourceBatchId: batch.id,
              createdAt: new Date().toISOString(),
            });

            await addLog({
              recordId: finishedMaterialId,
              recordType: "RawMaterial",
              action: "Created",
              details: `${formData.accepted} finished items from batch ${batch.id} added to Store.`,
            });

            toast({
              title: "Finished Material Created",
              description: `${formData.accepted} finished ${batch.productName} added to Store.`,
            });
          }
        }
        // Only add to Final Stock if this is NOT a Moulding-only or Machining-only batch
        else if (isLastStage && stage !== "Molding" && !isMachiningOnly) {
          const { getOrCreateProduct, addBatchToProduct } = await import(
            "@/lib/firebase/firestore-operations"
          );

          const newBatch = {
            batchId: batch.id,
            sourceBatchId: batch.id,
            quantity: formData.accepted,
            sku: `BATCH-${batch.id}`,
            createdAt: new Date().toISOString(),
          };

          // Get or create the product in Firestore (queries directly, not from client state)
          console.log(
            `[BatchStageProcessor] Getting/creating product for: ${batch.productName}`,
          );
          const product = await getOrCreateProduct(batch.productName, {
            imageUrl: "/placeholder.svg?height=100&width=100",
            imageHint: batch.productName,
          });
          console.log(
            `[BatchStageProcessor] Product obtained: ${product.id} - "${product.name}"`,
          );
          console.log(
            `[BatchStageProcessor] New batch to add:`,
            JSON.stringify(newBatch),
          );

          // Add batch to the product
          try {
            await addBatchToProduct(product.id, newBatch);
            console.log(
              `[BatchStageProcessor] ✓ Successfully added batch ${batch.id} to product ${product.name} (${product.id})`,
            );
          } catch (error) {
            console.error(
              `[BatchStageProcessor] ❌ Failed to add batch ${batch.id} to product ${product.id}:`,
              error,
            );
            console.error(
              `[BatchStageProcessor] Product details:`,
              JSON.stringify(product),
            );
            console.error(
              `[BatchStageProcessor] Batch details:`,
              JSON.stringify(newBatch),
            );
            throw error;
          }
        }

        await completeStage(batch.id, stage);
      }
    }

    toast({
      title: "Batches Updated",
      description: `The ${stage} stage has been updated for the submitted batches.`,
    });

    // Navigate to next stage if applicable
    const batchWithNextStage = batches.find((batch) => {
      const selectedProcesses = batch.selectedProcesses || [];
      const currentIndex = selectedProcesses.indexOf(stage);
      return currentIndex >= 0 && currentIndex < selectedProcesses.length - 1;
    });

    if (batchWithNextStage) {
      const selectedProcesses = batchWithNextStage.selectedProcesses || [];
      const currentIndex = selectedProcesses.indexOf(stage);
      const nextStage = selectedProcesses[currentIndex + 1];

      if (nextStage) {
        setTimeout(() => {
          router.push(`/batches/${nextStage.toLowerCase()}`);
        }, 500);
      }
    }
  }

  const handleEndCycle = async () => {
    const values = form.getValues();

    for (const batch of batches) {
      const formData = values.batches.find((b) => b.id === batch.id);
      if (!formData) continue;

      const currentTotal = formData.accepted + formData.rejected;
      const isCompleted = currentTotal > 0;

      try {
        await updateBatchStage(batch.id, stage, {
          accepted: formData.accepted,
          rejected: formData.rejected,
          actualConsumption: formData.actualConsumption,
        });
      } catch (error) {
        console.error(`[v0] Failed to update batch ${batch.id}:`, error);
        continue;
      }

      if (isCompleted && !batch.processingStages[stage]?.completed) {
        // Update raw materials
        const materialsForStage = batch.materials.filter(
          (m) => m.stage === stage,
        );
        for (const materialInBatch of materialsForStage) {
          const materialToUpdate = rawMaterials.find(
            (rm) => rm.id === materialInBatch.id,
          );
          if (materialToUpdate) {
            const consumptionAmount =
              formData.actualConsumption > 0
                ? formData.actualConsumption
                : materialInBatch.quantity;
            const oldQuantity = materialToUpdate.quantity;
            const newQuantity = oldQuantity - consumptionAmount;

            await updateRawMaterial(materialToUpdate.id, {
              quantity: newQuantity,
            });

            await addLog({
              recordId: materialToUpdate.id,
              recordType: "RawMaterial",
              action: "Stock Adjustment (Batch)",
              details: `Batch ${batch.id} (${stage}) consumed ${consumptionAmount} ${materialToUpdate.unit}. Old qty: ${oldQuantity}, New qty: ${newQuantity}.`,
            });
          }
        }

        const selectedProcesses = batch.selectedProcesses || [];
        const isMachiningOnly =
          selectedProcesses.length === 1 &&
          selectedProcesses[0] === "Machining";

        // If Moulding stage is completed, create moulded material for Store
        if (stage === "Molding" && formData.accepted > 0) {
          const { addRawMaterial } = await import(
            "@/lib/firebase/firestore-operations"
          );
          const mouldedMaterialId = await addRawMaterial({
            name: `Moulded ${batch.productName}`,
            sku: `MOULD-${batch.id}`,
            quantity: formData.accepted,
            unit: "pcs",
            threshold: 10,
            isMoulded: true,
            sourceBatchId: batch.id,
            createdAt: new Date().toISOString(),
          });

          await addLog({
            recordId: mouldedMaterialId,
            recordType: "RawMaterial",
            action: "Created",
            details: `${formData.accepted} moulded items from batch ${batch.id} added to Store.`,
          });
        }
        // If Machining-only stage is completed, create finished material for Store
        else if (
          stage === "Machining" &&
          isMachiningOnly &&
          formData.accepted > 0
        ) {
          const { addRawMaterial } = await import(
            "@/lib/firebase/firestore-operations"
          );
          const finishedMaterialId = await addRawMaterial({
            name: `Finished ${batch.productName}`,
            sku: `FINISH-${batch.id}`,
            quantity: formData.accepted,
            unit: "pcs",
            threshold: 10,
            isFinished: true,
            sourceBatchId: batch.id,
            createdAt: new Date().toISOString(),
          });

          await addLog({
            recordId: finishedMaterialId,
            recordType: "RawMaterial",
            action: "Created",
            details: `${formData.accepted} finished items from batch ${batch.id} added to Store.`,
          });
        }
        // Only add to Final Stock if this is NOT Moulding or Machining-only stage
        else if (stage !== "Molding" && !isMachiningOnly) {
          const { getOrCreateProduct, addBatchToProduct } = await import(
            "@/lib/firebase/firestore-operations"
          );

          const newBatch = {
            batchId: batch.id,
            sourceBatchId: batch.id,
            quantity: formData.accepted,
            sku: `BATCH-${batch.id}`,
            createdAt: new Date().toISOString(),
          };

          // Get or create the product in Firestore
          console.log(
            `[BatchStageProcessor:EndCycle] Getting/creating product for: ${batch.productName}`,
          );
          const product = await getOrCreateProduct(batch.productName, {
            imageUrl: "/placeholder.svg?height=100&width=100",
            imageHint: batch.productName,
          });
          console.log(
            `[BatchStageProcessor:EndCycle] Product obtained: ${product.id}`,
          );

          // Add batch to the product
          try {
            await addBatchToProduct(product.id, newBatch);
            console.log(
              `[BatchStageProcessor:EndCycle] ✓ Added batch ${batch.id} to product ${product.id}`,
            );
          } catch (error) {
            console.error(
              `[BatchStageProcessor:EndCycle] ❌ Failed to add batch:`,
              error,
            );
            throw error;
          }
        }

        await completeStage(batch.id, stage);
      }
    }

    toast({
      title: "Cycle Ended",
      description: `The production cycle has been ended at the ${stage} stage for the submitted batches.`,
    });

    setTimeout(() => {
      router.push("/batches/overview");
    }, 500);
  };

  const handleFinishBatch = async () => {
    const values = form.getValues();

    const batchesWithThisAsLastStage = batches.filter((batch) => {
      const selectedProcesses = batch.selectedProcesses || [];
      return selectedProcesses[selectedProcesses.length - 1] === stage;
    });

    if (batchesWithThisAsLastStage.length === 0) return;

    // Allow finishing batches even without entering values

    for (const batch of batchesWithThisAsLastStage) {
      const formData = values.batches.find((b) => b.id === batch.id);
      if (!formData) continue;

      const currentTotal = formData.accepted + formData.rejected;
      const isCompleted = currentTotal > 0;

      try {
        await updateBatchStage(batch.id, stage, {
          accepted: formData.accepted,
          rejected: formData.rejected,
          actualConsumption: formData.actualConsumption,
        });
      } catch (error) {
        console.error(`[v0] Failed to update batch ${batch.id}:`, error);
        continue;
      }

      if (!batch.processingStages[stage]?.completed) {
        // Update raw materials only if there's consumption
        if (isCompleted) {
          const materialsForStage = batch.materials.filter(
            (m) => m.stage === stage,
          );
          for (const materialInBatch of materialsForStage) {
            const materialToUpdate = rawMaterials.find(
              (rm) => rm.id === materialInBatch.id,
            );
            if (materialToUpdate) {
              const consumptionAmount =
                formData.actualConsumption > 0
                  ? formData.actualConsumption
                  : materialInBatch.quantity;
              const oldQuantity = materialToUpdate.quantity;
              const newQuantity = oldQuantity - consumptionAmount;

              if (newQuantity <= 0) {
                // Delete material if quantity reaches 0 or below
                await deleteRawMaterial(materialToUpdate.id);
                await addLog({
                  recordId: materialToUpdate.id,
                  recordType: "RawMaterial",
                  action: "Deleted",
                  details: `Batch ${batch.id} (${stage}) consumed all remaining stock (${oldQuantity} ${materialToUpdate.unit}). Material deleted.`,
                });
              } else {
                await updateRawMaterial(materialToUpdate.id, {
                  quantity: newQuantity,
                });
                await addLog({
                  recordId: materialToUpdate.id,
                  recordType: "RawMaterial",
                  action: "Stock Adjustment (Batch)",
                  details: `Batch ${batch.id} (${stage}) consumed ${consumptionAmount} ${materialToUpdate.unit}. Old qty: ${oldQuantity}, New qty: ${newQuantity}.`,
                });
              }
            }
          }
        }

        const selectedProcesses = batch.selectedProcesses || [];
        const isMachiningOnly =
          selectedProcesses.length === 1 &&
          selectedProcesses[0] === "Machining";

        // If Moulding stage is completed, create or update moulded material in Store
        if (stage === "Molding" && formData.accepted > 0) {
          const { addRawMaterial } = await import(
            "@/lib/firebase/firestore-operations"
          );
          const materialName = `Moulded ${batch.productName}`;
          const existingMaterial = rawMaterials.find(
            (m) => m.name === materialName && m.isMoulded === true,
          );

          if (existingMaterial) {
            // Update existing material quantity
            const oldQuantity = Number(existingMaterial.quantity) || 0;
            const newQuantity = oldQuantity + Number(formData.accepted);
            await updateRawMaterial(existingMaterial.id, {
              quantity: newQuantity,
            });

            await addLog({
              recordId: existingMaterial.id,
              recordType: "RawMaterial",
              action: "Stock Adjustment (Batch)",
              details: `${formData.accepted} moulded items from batch ${batch.id} added to Store. Old qty: ${oldQuantity}, New qty: ${newQuantity}.`,
            });
          } else {
            // Create new material
            const mouldedMaterialId = await addRawMaterial({
              name: materialName,
              sku: `MOULD-${Date.now()}`,
              quantity: formData.accepted,
              unit: "pcs",
              threshold: 10,
              isMoulded: true,
              sourceBatchId: batch.id,
              createdAt: new Date().toISOString(),
            });

            await addLog({
              recordId: mouldedMaterialId,
              recordType: "RawMaterial",
              action: "Created",
              details: `${formData.accepted} moulded items from batch ${batch.id} added to Store.`,
            });
          }
        }
        // If Machining-only stage is completed, create or update finished material in Store
        else if (
          stage === "Machining" &&
          isMachiningOnly &&
          formData.accepted > 0
        ) {
          console.log(
            `[DEBUG] Creating/updating finished material for batch ${batch.id} with ${formData.accepted} accepted items`,
          );
          const { addRawMaterial } = await import(
            "@/lib/firebase/firestore-operations"
          );
          const materialName = `Finished ${batch.productName}`;
          const existingMaterial = rawMaterials.find(
            (m) => m.name === materialName && m.isFinished === true,
          );

          if (existingMaterial) {
            // Update existing material quantity
            const oldQuantity = Number(existingMaterial.quantity) || 0;
            const newQuantity = oldQuantity + Number(formData.accepted);
            await updateRawMaterial(existingMaterial.id, {
              quantity: newQuantity,
            });

            await addLog({
              recordId: existingMaterial.id,
              recordType: "RawMaterial",
              action: "Stock Adjustment (Batch)",
              details: `${formData.accepted} finished items from batch ${batch.id} added to Store. Old qty: ${oldQuantity}, New qty: ${newQuantity}.`,
            });

            toast({
              title: "Finished Material Updated",
              description: `${formData.accepted} finished ${batch.productName} added to existing stock.`,
            });
          } else {
            // Create new material
            const finishedMaterialId = await addRawMaterial({
              name: materialName,
              sku: `FINISH-${Date.now()}`,
              quantity: formData.accepted,
              unit: "pcs",
              threshold: 10,
              isFinished: true,
              sourceBatchId: batch.id,
              createdAt: new Date().toISOString(),
            });

            await addLog({
              recordId: finishedMaterialId,
              recordType: "RawMaterial",
              action: "Created",
              details: `${formData.accepted} finished items from batch ${batch.id} added to Store.`,
            });

            toast({
              title: "Finished Material Created",
              description: `${formData.accepted} finished ${batch.productName} added to Store.`,
            });
          }
        }
        // Only add to Final Stock if this is NOT Moulding or Machining-only stage
        else if (stage !== "Molding" && !isMachiningOnly) {
          const { getOrCreateProduct, addBatchToProduct } = await import(
            "@/lib/firebase/firestore-operations"
          );

          const newBatch = {
            batchId: batch.id,
            sourceBatchId: batch.id,
            quantity: formData.accepted,
            sku: `BATCH-${batch.id}`,
            createdAt: new Date().toISOString(),
          };

          // Get or create the product in Firestore
          console.log(
            `[BatchStageProcessor:FinishBatch] Getting/creating product for: ${batch.productName}`,
          );
          const product = await getOrCreateProduct(batch.productName, {
            imageUrl: "/placeholder.svg?height=100&width=100",
            imageHint: batch.productName,
          });
          console.log(
            `[BatchStageProcessor:FinishBatch] Product obtained: ${product.id}`,
          );

          // Add batch to the product
          try {
            await addBatchToProduct(product.id, newBatch);
            console.log(
              `[BatchStageProcessor:FinishBatch] ✓ Added batch ${batch.id} to product ${product.id}`,
            );
          } catch (error) {
            console.error(
              `[BatchStageProcessor:FinishBatch] ❌ Failed to add batch:`,
              error,
            );
            throw error;
          }
        }

        await completeStage(batch.id, stage);
      }
    }

    // Check if any batch is finishing-only for toast message
    const hasMachiningOnlyBatch = batchesWithThisAsLastStage.some((batch) => {
      const selectedProcesses = batch.selectedProcesses || [];
      return (
        selectedProcesses.length === 1 && selectedProcesses[0] === "Machining"
      );
    });

    toast({
      title: "Batch Finished",
      description:
        stage === "Molding"
          ? "Moulding completed. Items have been added to Store."
          : stage === "Machining" && hasMachiningOnlyBatch
            ? "Machining completed. Items have been added to Store."
            : "The batch has been finalized and added to the Final Stock list.",
    });

    setTimeout(() => {
      router.push("/batches/overview");
    }, 500);
  };

  const hasAnyBatchWithThisAsLastStage = batches.some((batch) => {
    const selectedProcesses = batch.selectedProcesses || [];
    return selectedProcesses[selectedProcesses.length - 1] === stage;
  });

  return (
    <Form {...form}>
      <form
        id={`stage-form-${stage.toLowerCase()}`}
        onSubmit={form.handleSubmit(onSubmit)}
      >
        <Card>
          <CardContent className="pt-6">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-[50px]">
                    <Checkbox
                      checked={
                        selectedBatches.size === batches.length &&
                        batches.length > 0
                      }
                      onCheckedChange={(checked) => {
                        if (checked) {
                          setSelectedBatches(new Set(batches.map((b) => b.id)));
                        } else {
                          setSelectedBatches(new Set());
                        }
                      }}
                    />
                  </TableHead>
                  <TableHead>Batch ID</TableHead>
                  <TableHead>Product</TableHead>
                  <TableHead>Date Created</TableHead>
                  {labels.prevStage && (
                    <TableHead>{labels.prevStage}</TableHead>
                  )}
                  <TableHead>{labels.input}</TableHead>
                  <TableHead className="w-[150px]">
                    Actual Consumption
                  </TableHead>
                  <TableHead className="w-[150px]">{labels.accepted}</TableHead>
                  <TableHead className="w-[150px]">{labels.rejected}</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {fields.map((field, index) => {
                  const batch = batches[index];
                  if (!batch) return null;

                  const rawMaterialInput = getRawMaterialForStage(batch);
                  const fromPrevStageInput = getInputFromPreviousStage(batch);
                  const materialsForStage = batch.materials.filter(
                    (m) => m.stage === stage
                  );

                  return (
                    <>
                      {/* Main Batch Row */}
                      <TableRow key={field.id}>
                        <TableCell>
                          <Checkbox
                            checked={selectedBatches.has(batch.id)}
                            onCheckedChange={(checked) => {
                              const newSelected = new Set(selectedBatches);
                              if (checked) {
                                newSelected.add(batch.id);
                              } else {
                                newSelected.delete(batch.id);
                              }
                              setSelectedBatches(newSelected);
                            }}
                          />
                        </TableCell>
                        <TableCell className="font-mono text-xs">
                          {batch.id}
                        </TableCell>
                        <TableCell className="font-medium">
                          {batch.productName}
                        </TableCell>
                        <TableCell>
                          {format(new Date(batch.createdAt), "MM/dd/yyyy")}
                        </TableCell>
                        {labels.prevStage && (
                          <TableCell>
                            {fromPrevStageInput.toLocaleString()}
                          </TableCell>
                        )}
                        <TableCell>{rawMaterialInput.toLocaleString()}</TableCell>
                        <TableCell>
                          <FormField
                            control={form.control}
                            name={`batches.${index}.actualConsumption`}
                            render={({ field }) => (
                              <FormItem>
                                <FormControl>
                                  <Input type="number" {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                        </TableCell>
                        <TableCell>
                          <FormField
                            control={form.control}
                            name={`batches.${index}.accepted`}
                            render={({ field }) => (
                              <FormItem>
                                <FormControl>
                                  <Input type="number" {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                        </TableCell>
                        <TableCell>
                          <FormField
                            control={form.control}
                            name={`batches.${index}.rejected`}
                            render={({ field }) => (
                              <FormItem>
                                <FormControl>
                                  <Input type="number" {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                        </TableCell>
                      </TableRow>

                      {/* Child Rows for Raw Materials */}
                      {materialsForStage.map((material, materialIndex) => (
                        <TableRow
                          key={`${field.id}-material-${material.id}`}
                          className="bg-muted/50"
                        >
                          {/* Empty cell for checkbox column */}
                          <TableCell></TableCell>

                          {/* Material name spans across Batch ID and Product columns */}
                          <TableCell colSpan={2} className="pl-8 text-sm text-muted-foreground">
                            ↳ {material.name}
                          </TableCell>

                          {/* Empty cell for Date Created column */}
                          <TableCell></TableCell>

                          {/* Empty cell for Previous Stage column (conditional) */}
                          {labels.prevStage && <TableCell></TableCell>}

                          {/* Material quantity in Input column */}
                          <TableCell className="text-sm">
                            {material.quantity.toLocaleString()} {material.unit}
                          </TableCell>

                          {/* Actual Consumption input for this material */}
                          <TableCell>
                            <FormField
                              control={form.control}
                              name={`batches.${index}.materials.${materialIndex}.actualConsumption`}
                              render={({ field }) => (
                                <FormItem>
                                  <FormControl>
                                    <Input
                                      type="number"
                                      {...field}
                                      placeholder="0"
                                      className="h-8"
                                    />
                                  </FormControl>
                                  <FormMessage />
                                </FormItem>
                              )}
                            />
                          </TableCell>

                          {/* Empty cells for Accepted and Rejected columns */}
                          <TableCell></TableCell>
                          <TableCell></TableCell>
                        </TableRow>
                      ))}
                    </>
                  );
                })}
                {batches.length === 0 && (
                  <TableRow>
                    <TableCell colSpan={9} className="h-24 text-center">
                      No batches are ready for the {stage} stage.
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          </CardContent>
        </Card>
        {batches.length > 0 && (
          <div className="flex justify-end gap-2 mt-4">
            {hasAnyBatchWithThisAsLastStage ? (
              <>
                <Button
                  type="button"
                  variant="outline"
                  onClick={handleEndCycle}
                >
                  End cycle at this stage
                </Button>
                <Button type="button" onClick={handleFinishBatch}>
                  Finish Batch
                </Button>
              </>
            ) : (
              <>
                <Button
                  type="button"
                  variant="outline"
                  onClick={handleEndCycle}
                >
                  End cycle at this stage
                </Button>
                <Button type="submit">Proceed to next stage</Button>
              </>
            )}
          </div>
        )}
      </form>
    </Form>
  );
}
